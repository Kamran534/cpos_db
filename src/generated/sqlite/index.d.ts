
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Terminal
 * 
 */
export type Terminal = $Result.DefaultSelection<Prisma.$TerminalPayload>
/**
 * Model TerminalSession
 * 
 */
export type TerminalSession = $Result.DefaultSelection<Prisma.$TerminalSessionPayload>
/**
 * Model OperationMode
 * 
 */
export type OperationMode = $Result.DefaultSelection<Prisma.$OperationModePayload>
/**
 * Model ConnectionLog
 * 
 */
export type ConnectionLog = $Result.DefaultSelection<Prisma.$ConnectionLogPayload>
/**
 * Model LocalUser
 * 
 */
export type LocalUser = $Result.DefaultSelection<Prisma.$LocalUserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model Outbox
 * 
 */
export type Outbox = $Result.DefaultSelection<Prisma.$OutboxPayload>
/**
 * Model SyncHistory
 * 
 */
export type SyncHistory = $Result.DefaultSelection<Prisma.$SyncHistoryPayload>
/**
 * Model Store
 * 
 */
export type Store = $Result.DefaultSelection<Prisma.$StorePayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductVariant
 * 
 */
export type ProductVariant = $Result.DefaultSelection<Prisma.$ProductVariantPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model CustomerGroup
 * 
 */
export type CustomerGroup = $Result.DefaultSelection<Prisma.$CustomerGroupPayload>
/**
 * Model CustomerAddress
 * 
 */
export type CustomerAddress = $Result.DefaultSelection<Prisma.$CustomerAddressPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model StockAdjustment
 * 
 */
export type StockAdjustment = $Result.DefaultSelection<Prisma.$StockAdjustmentPayload>
/**
 * Model StockAdjustmentLine
 * 
 */
export type StockAdjustmentLine = $Result.DefaultSelection<Prisma.$StockAdjustmentLinePayload>
/**
 * Model StockTransfer
 * 
 */
export type StockTransfer = $Result.DefaultSelection<Prisma.$StockTransferPayload>
/**
 * Model StockTransferLine
 * 
 */
export type StockTransferLine = $Result.DefaultSelection<Prisma.$StockTransferLinePayload>
/**
 * Model SaleOrder
 * 
 */
export type SaleOrder = $Result.DefaultSelection<Prisma.$SaleOrderPayload>
/**
 * Model SaleOrderLine
 * 
 */
export type SaleOrderLine = $Result.DefaultSelection<Prisma.$SaleOrderLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model ReturnOrder
 * 
 */
export type ReturnOrder = $Result.DefaultSelection<Prisma.$ReturnOrderPayload>
/**
 * Model ReturnOrderLine
 * 
 */
export type ReturnOrderLine = $Result.DefaultSelection<Prisma.$ReturnOrderLinePayload>
/**
 * Model ExchangeOrder
 * 
 */
export type ExchangeOrder = $Result.DefaultSelection<Prisma.$ExchangeOrderPayload>
/**
 * Model ParkedOrder
 * 
 */
export type ParkedOrder = $Result.DefaultSelection<Prisma.$ParkedOrderPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model TaxCategory
 * 
 */
export type TaxCategory = $Result.DefaultSelection<Prisma.$TaxCategoryPayload>
/**
 * Model TaxRate
 * 
 */
export type TaxRate = $Result.DefaultSelection<Prisma.$TaxRatePayload>
/**
 * Model LocalSettings
 * 
 */
export type LocalSettings = $Result.DefaultSelection<Prisma.$LocalSettingsPayload>
/**
 * Model Cache
 * 
 */
export type Cache = $Result.DefaultSelection<Prisma.$CachePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const OperationModeType: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  SYNCING: 'SYNCING',
  MAINTENANCE: 'MAINTENANCE'
};

export type OperationModeType = (typeof OperationModeType)[keyof typeof OperationModeType]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  STORE_MANAGER: 'STORE_MANAGER',
  ASSISTANT_MANAGER: 'ASSISTANT_MANAGER',
  CASHIER: 'CASHIER',
  INVENTORY_MANAGER: 'INVENTORY_MANAGER',
  CUSTOMER_SERVICE: 'CUSTOMER_SERVICE'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SyncOperation: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type SyncOperation = (typeof SyncOperation)[keyof typeof SyncOperation]


export const SyncType: {
  FULL: 'FULL',
  INCREMENTAL: 'INCREMENTAL',
  PUSH_ONLY: 'PUSH_ONLY',
  PULL_ONLY: 'PULL_ONLY'
};

export type SyncType = (typeof SyncType)[keyof typeof SyncType]


export const SyncDirection: {
  UPLOAD: 'UPLOAD',
  DOWNLOAD: 'DOWNLOAD',
  BIDIRECTIONAL: 'BIDIRECTIONAL'
};

export type SyncDirection = (typeof SyncDirection)[keyof typeof SyncDirection]


export const LocationType: {
  STORE: 'STORE',
  WAREHOUSE: 'WAREHOUSE',
  SHOWROOM: 'SHOWROOM',
  KIOSK: 'KIOSK'
};

export type LocationType = (typeof LocationType)[keyof typeof LocationType]


export const ProductType: {
  SIMPLE: 'SIMPLE',
  VARIABLE: 'VARIABLE',
  COMBO: 'COMBO',
  DIGITAL: 'DIGITAL'
};

export type ProductType = (typeof ProductType)[keyof typeof ProductType]


export const CustomerType: {
  REGULAR: 'REGULAR',
  VIP: 'VIP',
  WHOLESALE: 'WHOLESALE',
  EMPLOYEE: 'EMPLOYEE',
  WHOLESALE_VIP: 'WHOLESALE_VIP'
};

export type CustomerType = (typeof CustomerType)[keyof typeof CustomerType]


export const AddressType: {
  BILLING: 'BILLING',
  SHIPPING: 'SHIPPING',
  BOTH: 'BOTH'
};

export type AddressType = (typeof AddressType)[keyof typeof AddressType]


export const StockAdjustmentType: {
  INCREASE: 'INCREASE',
  DECREASE: 'DECREASE',
  STOCK_TAKE: 'STOCK_TAKE',
  DAMAGED: 'DAMAGED',
  EXPIRED: 'EXPIRED',
  FOUND: 'FOUND'
};

export type StockAdjustmentType = (typeof StockAdjustmentType)[keyof typeof StockAdjustmentType]


export const TransferStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  IN_TRANSIT: 'IN_TRANSIT',
  RECEIVED: 'RECEIVED',
  CANCELLED: 'CANCELLED',
  PARTIALLY_RECEIVED: 'PARTIALLY_RECEIVED'
};

export type TransferStatus = (typeof TransferStatus)[keyof typeof TransferStatus]


export const OrderType: {
  SALE: 'SALE',
  RETURN: 'RETURN',
  EXCHANGE: 'EXCHANGE',
  QUOTE: 'QUOTE',
  LAYAWAY: 'LAYAWAY'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const OrderStatus: {
  OPEN: 'OPEN',
  COMPLETED: 'COMPLETED',
  VOIDED: 'VOIDED',
  PARKED: 'PARKED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const OrderSource: {
  POS: 'POS',
  ONLINE: 'ONLINE',
  MOBILE: 'MOBILE',
  PHONE: 'PHONE',
  MARKETPLACE: 'MARKETPLACE'
};

export type OrderSource = (typeof OrderSource)[keyof typeof OrderSource]


export const PaymentMethod: {
  CASH: 'CASH',
  CARD: 'CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  GIFT_CARD: 'GIFT_CARD',
  STORE_CREDIT: 'STORE_CREDIT',
  DIGITAL_WALLET: 'DIGITAL_WALLET',
  CHECK: 'CHECK',
  CRYPTO: 'CRYPTO'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const DiscountType: {
  PERCENTAGE: 'PERCENTAGE',
  FIXED_AMOUNT: 'FIXED_AMOUNT',
  BUY_X_GET_Y: 'BUY_X_GET_Y',
  COUPON: 'COUPON',
  PROMOTIONAL: 'PROMOTIONAL',
  LOYALTY: 'LOYALTY'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const ReturnReason: {
  DEFECTIVE: 'DEFECTIVE',
  WRONG_ITEM: 'WRONG_ITEM',
  SIZE_ISSUE: 'SIZE_ISSUE',
  COLOR_ISSUE: 'COLOR_ISSUE',
  QUALITY_ISSUE: 'QUALITY_ISSUE',
  NO_LONGER_NEEDED: 'NO_LONGER_NEEDED',
  BETTER_PRICE: 'BETTER_PRICE',
  UNWANTED_GIFT: 'UNWANTED_GIFT',
  DAMAGED: 'DAMAGED',
  INCORRECT_DESCRIPTION: 'INCORRECT_DESCRIPTION'
};

export type ReturnReason = (typeof ReturnReason)[keyof typeof ReturnReason]


export const RefundMethod: {
  ORIGINAL_PAYMENT: 'ORIGINAL_PAYMENT',
  STORE_CREDIT: 'STORE_CREDIT',
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  GIFT_CARD: 'GIFT_CARD'
};

export type RefundMethod = (typeof RefundMethod)[keyof typeof RefundMethod]


export const ReturnStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  COMPLETED: 'COMPLETED',
  REJECTED: 'REJECTED',
  PARTIALLY_APPROVED: 'PARTIALLY_APPROVED'
};

export type ReturnStatus = (typeof ReturnStatus)[keyof typeof ReturnStatus]


export const ShiftStatus: {
  OPEN: 'OPEN',
  CLOSED: 'CLOSED',
  SUSPENDED: 'SUSPENDED'
};

export type ShiftStatus = (typeof ShiftStatus)[keyof typeof ShiftStatus]

}

export type OperationModeType = $Enums.OperationModeType

export const OperationModeType: typeof $Enums.OperationModeType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SyncOperation = $Enums.SyncOperation

export const SyncOperation: typeof $Enums.SyncOperation

export type SyncType = $Enums.SyncType

export const SyncType: typeof $Enums.SyncType

export type SyncDirection = $Enums.SyncDirection

export const SyncDirection: typeof $Enums.SyncDirection

export type LocationType = $Enums.LocationType

export const LocationType: typeof $Enums.LocationType

export type ProductType = $Enums.ProductType

export const ProductType: typeof $Enums.ProductType

export type CustomerType = $Enums.CustomerType

export const CustomerType: typeof $Enums.CustomerType

export type AddressType = $Enums.AddressType

export const AddressType: typeof $Enums.AddressType

export type StockAdjustmentType = $Enums.StockAdjustmentType

export const StockAdjustmentType: typeof $Enums.StockAdjustmentType

export type TransferStatus = $Enums.TransferStatus

export const TransferStatus: typeof $Enums.TransferStatus

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type OrderSource = $Enums.OrderSource

export const OrderSource: typeof $Enums.OrderSource

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type ReturnReason = $Enums.ReturnReason

export const ReturnReason: typeof $Enums.ReturnReason

export type RefundMethod = $Enums.RefundMethod

export const RefundMethod: typeof $Enums.RefundMethod

export type ReturnStatus = $Enums.ReturnStatus

export const ReturnStatus: typeof $Enums.ReturnStatus

export type ShiftStatus = $Enums.ShiftStatus

export const ShiftStatus: typeof $Enums.ShiftStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Terminals
 * const terminals = await prisma.terminal.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Terminals
   * const terminals = await prisma.terminal.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.terminal`: Exposes CRUD operations for the **Terminal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terminals
    * const terminals = await prisma.terminal.findMany()
    * ```
    */
  get terminal(): Prisma.TerminalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.terminalSession`: Exposes CRUD operations for the **TerminalSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TerminalSessions
    * const terminalSessions = await prisma.terminalSession.findMany()
    * ```
    */
  get terminalSession(): Prisma.TerminalSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operationMode`: Exposes CRUD operations for the **OperationMode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperationModes
    * const operationModes = await prisma.operationMode.findMany()
    * ```
    */
  get operationMode(): Prisma.OperationModeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.connectionLog`: Exposes CRUD operations for the **ConnectionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConnectionLogs
    * const connectionLogs = await prisma.connectionLog.findMany()
    * ```
    */
  get connectionLog(): Prisma.ConnectionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localUser`: Exposes CRUD operations for the **LocalUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalUsers
    * const localUsers = await prisma.localUser.findMany()
    * ```
    */
  get localUser(): Prisma.LocalUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.outbox`: Exposes CRUD operations for the **Outbox** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outboxes
    * const outboxes = await prisma.outbox.findMany()
    * ```
    */
  get outbox(): Prisma.OutboxDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncHistory`: Exposes CRUD operations for the **SyncHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncHistories
    * const syncHistories = await prisma.syncHistory.findMany()
    * ```
    */
  get syncHistory(): Prisma.SyncHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.store`: Exposes CRUD operations for the **Store** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.store.findMany()
    * ```
    */
  get store(): Prisma.StoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productVariant`: Exposes CRUD operations for the **ProductVariant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductVariants
    * const productVariants = await prisma.productVariant.findMany()
    * ```
    */
  get productVariant(): Prisma.ProductVariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerGroup`: Exposes CRUD operations for the **CustomerGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerGroups
    * const customerGroups = await prisma.customerGroup.findMany()
    * ```
    */
  get customerGroup(): Prisma.CustomerGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerAddress`: Exposes CRUD operations for the **CustomerAddress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerAddresses
    * const customerAddresses = await prisma.customerAddress.findMany()
    * ```
    */
  get customerAddress(): Prisma.CustomerAddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockAdjustment`: Exposes CRUD operations for the **StockAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockAdjustments
    * const stockAdjustments = await prisma.stockAdjustment.findMany()
    * ```
    */
  get stockAdjustment(): Prisma.StockAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockAdjustmentLine`: Exposes CRUD operations for the **StockAdjustmentLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockAdjustmentLines
    * const stockAdjustmentLines = await prisma.stockAdjustmentLine.findMany()
    * ```
    */
  get stockAdjustmentLine(): Prisma.StockAdjustmentLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransfer`: Exposes CRUD operations for the **StockTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransfers
    * const stockTransfers = await prisma.stockTransfer.findMany()
    * ```
    */
  get stockTransfer(): Prisma.StockTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockTransferLine`: Exposes CRUD operations for the **StockTransferLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockTransferLines
    * const stockTransferLines = await prisma.stockTransferLine.findMany()
    * ```
    */
  get stockTransferLine(): Prisma.StockTransferLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleOrder`: Exposes CRUD operations for the **SaleOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleOrders
    * const saleOrders = await prisma.saleOrder.findMany()
    * ```
    */
  get saleOrder(): Prisma.SaleOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleOrderLine`: Exposes CRUD operations for the **SaleOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleOrderLines
    * const saleOrderLines = await prisma.saleOrderLine.findMany()
    * ```
    */
  get saleOrderLine(): Prisma.SaleOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnOrder`: Exposes CRUD operations for the **ReturnOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnOrders
    * const returnOrders = await prisma.returnOrder.findMany()
    * ```
    */
  get returnOrder(): Prisma.ReturnOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.returnOrderLine`: Exposes CRUD operations for the **ReturnOrderLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReturnOrderLines
    * const returnOrderLines = await prisma.returnOrderLine.findMany()
    * ```
    */
  get returnOrderLine(): Prisma.ReturnOrderLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangeOrder`: Exposes CRUD operations for the **ExchangeOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeOrders
    * const exchangeOrders = await prisma.exchangeOrder.findMany()
    * ```
    */
  get exchangeOrder(): Prisma.ExchangeOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parkedOrder`: Exposes CRUD operations for the **ParkedOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParkedOrders
    * const parkedOrders = await prisma.parkedOrder.findMany()
    * ```
    */
  get parkedOrder(): Prisma.ParkedOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxCategory`: Exposes CRUD operations for the **TaxCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxCategories
    * const taxCategories = await prisma.taxCategory.findMany()
    * ```
    */
  get taxCategory(): Prisma.TaxCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxRate`: Exposes CRUD operations for the **TaxRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxRates
    * const taxRates = await prisma.taxRate.findMany()
    * ```
    */
  get taxRate(): Prisma.TaxRateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.localSettings`: Exposes CRUD operations for the **LocalSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocalSettings
    * const localSettings = await prisma.localSettings.findMany()
    * ```
    */
  get localSettings(): Prisma.LocalSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache`: Exposes CRUD operations for the **Cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caches
    * const caches = await prisma.cache.findMany()
    * ```
    */
  get cache(): Prisma.CacheDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Terminal: 'Terminal',
    TerminalSession: 'TerminalSession',
    OperationMode: 'OperationMode',
    ConnectionLog: 'ConnectionLog',
    LocalUser: 'LocalUser',
    UserSession: 'UserSession',
    Outbox: 'Outbox',
    SyncHistory: 'SyncHistory',
    Store: 'Store',
    Location: 'Location',
    Product: 'Product',
    ProductVariant: 'ProductVariant',
    Category: 'Category',
    Brand: 'Brand',
    Customer: 'Customer',
    CustomerGroup: 'CustomerGroup',
    CustomerAddress: 'CustomerAddress',
    InventoryItem: 'InventoryItem',
    StockAdjustment: 'StockAdjustment',
    StockAdjustmentLine: 'StockAdjustmentLine',
    StockTransfer: 'StockTransfer',
    StockTransferLine: 'StockTransferLine',
    SaleOrder: 'SaleOrder',
    SaleOrderLine: 'SaleOrderLine',
    Payment: 'Payment',
    Discount: 'Discount',
    ReturnOrder: 'ReturnOrder',
    ReturnOrderLine: 'ReturnOrderLine',
    ExchangeOrder: 'ExchangeOrder',
    ParkedOrder: 'ParkedOrder',
    Shift: 'Shift',
    TaxCategory: 'TaxCategory',
    TaxRate: 'TaxRate',
    LocalSettings: 'LocalSettings',
    Cache: 'Cache'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "terminal" | "terminalSession" | "operationMode" | "connectionLog" | "localUser" | "userSession" | "outbox" | "syncHistory" | "store" | "location" | "product" | "productVariant" | "category" | "brand" | "customer" | "customerGroup" | "customerAddress" | "inventoryItem" | "stockAdjustment" | "stockAdjustmentLine" | "stockTransfer" | "stockTransferLine" | "saleOrder" | "saleOrderLine" | "payment" | "discount" | "returnOrder" | "returnOrderLine" | "exchangeOrder" | "parkedOrder" | "shift" | "taxCategory" | "taxRate" | "localSettings" | "cache"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Terminal: {
        payload: Prisma.$TerminalPayload<ExtArgs>
        fields: Prisma.TerminalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerminalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerminalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          findFirst: {
            args: Prisma.TerminalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerminalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          findMany: {
            args: Prisma.TerminalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>[]
          }
          create: {
            args: Prisma.TerminalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          createMany: {
            args: Prisma.TerminalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerminalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>[]
          }
          delete: {
            args: Prisma.TerminalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          update: {
            args: Prisma.TerminalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          deleteMany: {
            args: Prisma.TerminalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerminalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TerminalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>[]
          }
          upsert: {
            args: Prisma.TerminalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          aggregate: {
            args: Prisma.TerminalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerminal>
          }
          groupBy: {
            args: Prisma.TerminalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerminalCountArgs<ExtArgs>
            result: $Utils.Optional<TerminalCountAggregateOutputType> | number
          }
        }
      }
      TerminalSession: {
        payload: Prisma.$TerminalSessionPayload<ExtArgs>
        fields: Prisma.TerminalSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerminalSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerminalSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          findFirst: {
            args: Prisma.TerminalSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerminalSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          findMany: {
            args: Prisma.TerminalSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
          }
          create: {
            args: Prisma.TerminalSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          createMany: {
            args: Prisma.TerminalSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerminalSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
          }
          delete: {
            args: Prisma.TerminalSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          update: {
            args: Prisma.TerminalSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          deleteMany: {
            args: Prisma.TerminalSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerminalSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TerminalSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>[]
          }
          upsert: {
            args: Prisma.TerminalSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalSessionPayload>
          }
          aggregate: {
            args: Prisma.TerminalSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerminalSession>
          }
          groupBy: {
            args: Prisma.TerminalSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminalSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerminalSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TerminalSessionCountAggregateOutputType> | number
          }
        }
      }
      OperationMode: {
        payload: Prisma.$OperationModePayload<ExtArgs>
        fields: Prisma.OperationModeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperationModeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperationModeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          findFirst: {
            args: Prisma.OperationModeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperationModeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          findMany: {
            args: Prisma.OperationModeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>[]
          }
          create: {
            args: Prisma.OperationModeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          createMany: {
            args: Prisma.OperationModeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperationModeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>[]
          }
          delete: {
            args: Prisma.OperationModeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          update: {
            args: Prisma.OperationModeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          deleteMany: {
            args: Prisma.OperationModeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperationModeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperationModeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>[]
          }
          upsert: {
            args: Prisma.OperationModeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperationModePayload>
          }
          aggregate: {
            args: Prisma.OperationModeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperationMode>
          }
          groupBy: {
            args: Prisma.OperationModeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperationModeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperationModeCountArgs<ExtArgs>
            result: $Utils.Optional<OperationModeCountAggregateOutputType> | number
          }
        }
      }
      ConnectionLog: {
        payload: Prisma.$ConnectionLogPayload<ExtArgs>
        fields: Prisma.ConnectionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          findFirst: {
            args: Prisma.ConnectionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          findMany: {
            args: Prisma.ConnectionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>[]
          }
          create: {
            args: Prisma.ConnectionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          createMany: {
            args: Prisma.ConnectionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConnectionLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>[]
          }
          delete: {
            args: Prisma.ConnectionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          update: {
            args: Prisma.ConnectionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConnectionLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>[]
          }
          upsert: {
            args: Prisma.ConnectionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConnectionLogPayload>
          }
          aggregate: {
            args: Prisma.ConnectionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConnectionLog>
          }
          groupBy: {
            args: Prisma.ConnectionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConnectionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionLogCountArgs<ExtArgs>
            result: $Utils.Optional<ConnectionLogCountAggregateOutputType> | number
          }
        }
      }
      LocalUser: {
        payload: Prisma.$LocalUserPayload<ExtArgs>
        fields: Prisma.LocalUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          findFirst: {
            args: Prisma.LocalUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          findMany: {
            args: Prisma.LocalUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>[]
          }
          create: {
            args: Prisma.LocalUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          createMany: {
            args: Prisma.LocalUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>[]
          }
          delete: {
            args: Prisma.LocalUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          update: {
            args: Prisma.LocalUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          deleteMany: {
            args: Prisma.LocalUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocalUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>[]
          }
          upsert: {
            args: Prisma.LocalUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalUserPayload>
          }
          aggregate: {
            args: Prisma.LocalUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalUser>
          }
          groupBy: {
            args: Prisma.LocalUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalUserCountArgs<ExtArgs>
            result: $Utils.Optional<LocalUserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      Outbox: {
        payload: Prisma.$OutboxPayload<ExtArgs>
        fields: Prisma.OutboxFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OutboxFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OutboxFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          findFirst: {
            args: Prisma.OutboxFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OutboxFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          findMany: {
            args: Prisma.OutboxFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>[]
          }
          create: {
            args: Prisma.OutboxCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          createMany: {
            args: Prisma.OutboxCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OutboxCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>[]
          }
          delete: {
            args: Prisma.OutboxDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          update: {
            args: Prisma.OutboxUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          deleteMany: {
            args: Prisma.OutboxDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OutboxUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OutboxUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>[]
          }
          upsert: {
            args: Prisma.OutboxUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OutboxPayload>
          }
          aggregate: {
            args: Prisma.OutboxAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOutbox>
          }
          groupBy: {
            args: Prisma.OutboxGroupByArgs<ExtArgs>
            result: $Utils.Optional<OutboxGroupByOutputType>[]
          }
          count: {
            args: Prisma.OutboxCountArgs<ExtArgs>
            result: $Utils.Optional<OutboxCountAggregateOutputType> | number
          }
        }
      }
      SyncHistory: {
        payload: Prisma.$SyncHistoryPayload<ExtArgs>
        fields: Prisma.SyncHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findFirst: {
            args: Prisma.SyncHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          findMany: {
            args: Prisma.SyncHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          create: {
            args: Prisma.SyncHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          createMany: {
            args: Prisma.SyncHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          delete: {
            args: Prisma.SyncHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          update: {
            args: Prisma.SyncHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SyncHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>[]
          }
          upsert: {
            args: Prisma.SyncHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncHistoryPayload>
          }
          aggregate: {
            args: Prisma.SyncHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncHistory>
          }
          groupBy: {
            args: Prisma.SyncHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SyncHistoryCountAggregateOutputType> | number
          }
        }
      }
      Store: {
        payload: Prisma.$StorePayload<ExtArgs>
        fields: Prisma.StoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findFirst: {
            args: Prisma.StoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          findMany: {
            args: Prisma.StoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          create: {
            args: Prisma.StoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          createMany: {
            args: Prisma.StoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          delete: {
            args: Prisma.StoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          update: {
            args: Prisma.StoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          deleteMany: {
            args: Prisma.StoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>[]
          }
          upsert: {
            args: Prisma.StoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorePayload>
          }
          aggregate: {
            args: Prisma.StoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStore>
          }
          groupBy: {
            args: Prisma.StoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreCountArgs<ExtArgs>
            result: $Utils.Optional<StoreCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductVariant: {
        payload: Prisma.$ProductVariantPayload<ExtArgs>
        fields: Prisma.ProductVariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductVariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductVariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findFirst: {
            args: Prisma.ProductVariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductVariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          findMany: {
            args: Prisma.ProductVariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          create: {
            args: Prisma.ProductVariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          createMany: {
            args: Prisma.ProductVariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductVariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          delete: {
            args: Prisma.ProductVariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          update: {
            args: Prisma.ProductVariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          deleteMany: {
            args: Prisma.ProductVariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductVariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductVariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>[]
          }
          upsert: {
            args: Prisma.ProductVariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductVariantPayload>
          }
          aggregate: {
            args: Prisma.ProductVariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductVariant>
          }
          groupBy: {
            args: Prisma.ProductVariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductVariantCountArgs<ExtArgs>
            result: $Utils.Optional<ProductVariantCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      CustomerGroup: {
        payload: Prisma.$CustomerGroupPayload<ExtArgs>
        fields: Prisma.CustomerGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findFirst: {
            args: Prisma.CustomerGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          findMany: {
            args: Prisma.CustomerGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          create: {
            args: Prisma.CustomerGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          createMany: {
            args: Prisma.CustomerGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          delete: {
            args: Prisma.CustomerGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          update: {
            args: Prisma.CustomerGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          deleteMany: {
            args: Prisma.CustomerGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>[]
          }
          upsert: {
            args: Prisma.CustomerGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerGroupPayload>
          }
          aggregate: {
            args: Prisma.CustomerGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerGroup>
          }
          groupBy: {
            args: Prisma.CustomerGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerGroupCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupCountAggregateOutputType> | number
          }
        }
      }
      CustomerAddress: {
        payload: Prisma.$CustomerAddressPayload<ExtArgs>
        fields: Prisma.CustomerAddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerAddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerAddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findFirst: {
            args: Prisma.CustomerAddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerAddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          findMany: {
            args: Prisma.CustomerAddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          create: {
            args: Prisma.CustomerAddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          createMany: {
            args: Prisma.CustomerAddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerAddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          delete: {
            args: Prisma.CustomerAddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          update: {
            args: Prisma.CustomerAddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          deleteMany: {
            args: Prisma.CustomerAddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerAddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerAddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>[]
          }
          upsert: {
            args: Prisma.CustomerAddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerAddressPayload>
          }
          aggregate: {
            args: Prisma.CustomerAddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerAddress>
          }
          groupBy: {
            args: Prisma.CustomerAddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerAddressCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerAddressCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      StockAdjustment: {
        payload: Prisma.$StockAdjustmentPayload<ExtArgs>
        fields: Prisma.StockAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.StockAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          findMany: {
            args: Prisma.StockAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>[]
          }
          create: {
            args: Prisma.StockAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          createMany: {
            args: Prisma.StockAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.StockAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          update: {
            args: Prisma.StockAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.StockAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.StockAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.StockAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockAdjustment>
          }
          groupBy: {
            args: Prisma.StockAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<StockAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      StockAdjustmentLine: {
        payload: Prisma.$StockAdjustmentLinePayload<ExtArgs>
        fields: Prisma.StockAdjustmentLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockAdjustmentLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockAdjustmentLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          findFirst: {
            args: Prisma.StockAdjustmentLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockAdjustmentLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          findMany: {
            args: Prisma.StockAdjustmentLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>[]
          }
          create: {
            args: Prisma.StockAdjustmentLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          createMany: {
            args: Prisma.StockAdjustmentLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockAdjustmentLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>[]
          }
          delete: {
            args: Prisma.StockAdjustmentLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          update: {
            args: Prisma.StockAdjustmentLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          deleteMany: {
            args: Prisma.StockAdjustmentLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockAdjustmentLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockAdjustmentLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>[]
          }
          upsert: {
            args: Prisma.StockAdjustmentLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockAdjustmentLinePayload>
          }
          aggregate: {
            args: Prisma.StockAdjustmentLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockAdjustmentLine>
          }
          groupBy: {
            args: Prisma.StockAdjustmentLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockAdjustmentLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockAdjustmentLineCountArgs<ExtArgs>
            result: $Utils.Optional<StockAdjustmentLineCountAggregateOutputType> | number
          }
        }
      }
      StockTransfer: {
        payload: Prisma.$StockTransferPayload<ExtArgs>
        fields: Prisma.StockTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findFirst: {
            args: Prisma.StockTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          findMany: {
            args: Prisma.StockTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          create: {
            args: Prisma.StockTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          createMany: {
            args: Prisma.StockTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          delete: {
            args: Prisma.StockTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          update: {
            args: Prisma.StockTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          deleteMany: {
            args: Prisma.StockTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>[]
          }
          upsert: {
            args: Prisma.StockTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferPayload>
          }
          aggregate: {
            args: Prisma.StockTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransfer>
          }
          groupBy: {
            args: Prisma.StockTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransferCountAggregateOutputType> | number
          }
        }
      }
      StockTransferLine: {
        payload: Prisma.$StockTransferLinePayload<ExtArgs>
        fields: Prisma.StockTransferLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockTransferLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockTransferLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          findFirst: {
            args: Prisma.StockTransferLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockTransferLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          findMany: {
            args: Prisma.StockTransferLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>[]
          }
          create: {
            args: Prisma.StockTransferLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          createMany: {
            args: Prisma.StockTransferLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StockTransferLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>[]
          }
          delete: {
            args: Prisma.StockTransferLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          update: {
            args: Prisma.StockTransferLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          deleteMany: {
            args: Prisma.StockTransferLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockTransferLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StockTransferLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>[]
          }
          upsert: {
            args: Prisma.StockTransferLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockTransferLinePayload>
          }
          aggregate: {
            args: Prisma.StockTransferLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockTransferLine>
          }
          groupBy: {
            args: Prisma.StockTransferLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockTransferLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.StockTransferLineCountArgs<ExtArgs>
            result: $Utils.Optional<StockTransferLineCountAggregateOutputType> | number
          }
        }
      }
      SaleOrder: {
        payload: Prisma.$SaleOrderPayload<ExtArgs>
        fields: Prisma.SaleOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          findFirst: {
            args: Prisma.SaleOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          findMany: {
            args: Prisma.SaleOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>[]
          }
          create: {
            args: Prisma.SaleOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          createMany: {
            args: Prisma.SaleOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>[]
          }
          delete: {
            args: Prisma.SaleOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          update: {
            args: Prisma.SaleOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          deleteMany: {
            args: Prisma.SaleOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>[]
          }
          upsert: {
            args: Prisma.SaleOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderPayload>
          }
          aggregate: {
            args: Prisma.SaleOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleOrder>
          }
          groupBy: {
            args: Prisma.SaleOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleOrderCountArgs<ExtArgs>
            result: $Utils.Optional<SaleOrderCountAggregateOutputType> | number
          }
        }
      }
      SaleOrderLine: {
        payload: Prisma.$SaleOrderLinePayload<ExtArgs>
        fields: Prisma.SaleOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          findFirst: {
            args: Prisma.SaleOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          findMany: {
            args: Prisma.SaleOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>[]
          }
          create: {
            args: Prisma.SaleOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          createMany: {
            args: Prisma.SaleOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>[]
          }
          delete: {
            args: Prisma.SaleOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          update: {
            args: Prisma.SaleOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.SaleOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.SaleOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleOrderLinePayload>
          }
          aggregate: {
            args: Prisma.SaleOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleOrderLine>
          }
          groupBy: {
            args: Prisma.SaleOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<SaleOrderLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      ReturnOrder: {
        payload: Prisma.$ReturnOrderPayload<ExtArgs>
        fields: Prisma.ReturnOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          findFirst: {
            args: Prisma.ReturnOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          findMany: {
            args: Prisma.ReturnOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>[]
          }
          create: {
            args: Prisma.ReturnOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          createMany: {
            args: Prisma.ReturnOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>[]
          }
          delete: {
            args: Prisma.ReturnOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          update: {
            args: Prisma.ReturnOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          deleteMany: {
            args: Prisma.ReturnOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>[]
          }
          upsert: {
            args: Prisma.ReturnOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderPayload>
          }
          aggregate: {
            args: Prisma.ReturnOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnOrder>
          }
          groupBy: {
            args: Prisma.ReturnOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnOrderCountAggregateOutputType> | number
          }
        }
      }
      ReturnOrderLine: {
        payload: Prisma.$ReturnOrderLinePayload<ExtArgs>
        fields: Prisma.ReturnOrderLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReturnOrderLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReturnOrderLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          findFirst: {
            args: Prisma.ReturnOrderLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReturnOrderLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          findMany: {
            args: Prisma.ReturnOrderLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>[]
          }
          create: {
            args: Prisma.ReturnOrderLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          createMany: {
            args: Prisma.ReturnOrderLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReturnOrderLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>[]
          }
          delete: {
            args: Prisma.ReturnOrderLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          update: {
            args: Prisma.ReturnOrderLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          deleteMany: {
            args: Prisma.ReturnOrderLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReturnOrderLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReturnOrderLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>[]
          }
          upsert: {
            args: Prisma.ReturnOrderLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReturnOrderLinePayload>
          }
          aggregate: {
            args: Prisma.ReturnOrderLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReturnOrderLine>
          }
          groupBy: {
            args: Prisma.ReturnOrderLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReturnOrderLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReturnOrderLineCountArgs<ExtArgs>
            result: $Utils.Optional<ReturnOrderLineCountAggregateOutputType> | number
          }
        }
      }
      ExchangeOrder: {
        payload: Prisma.$ExchangeOrderPayload<ExtArgs>
        fields: Prisma.ExchangeOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          findFirst: {
            args: Prisma.ExchangeOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          findMany: {
            args: Prisma.ExchangeOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>[]
          }
          create: {
            args: Prisma.ExchangeOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          createMany: {
            args: Prisma.ExchangeOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>[]
          }
          delete: {
            args: Prisma.ExchangeOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          update: {
            args: Prisma.ExchangeOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          deleteMany: {
            args: Prisma.ExchangeOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExchangeOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>[]
          }
          upsert: {
            args: Prisma.ExchangeOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeOrderPayload>
          }
          aggregate: {
            args: Prisma.ExchangeOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeOrder>
          }
          groupBy: {
            args: Prisma.ExchangeOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeOrderCountAggregateOutputType> | number
          }
        }
      }
      ParkedOrder: {
        payload: Prisma.$ParkedOrderPayload<ExtArgs>
        fields: Prisma.ParkedOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParkedOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParkedOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          findFirst: {
            args: Prisma.ParkedOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParkedOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          findMany: {
            args: Prisma.ParkedOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>[]
          }
          create: {
            args: Prisma.ParkedOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          createMany: {
            args: Prisma.ParkedOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParkedOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>[]
          }
          delete: {
            args: Prisma.ParkedOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          update: {
            args: Prisma.ParkedOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          deleteMany: {
            args: Prisma.ParkedOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParkedOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParkedOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>[]
          }
          upsert: {
            args: Prisma.ParkedOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParkedOrderPayload>
          }
          aggregate: {
            args: Prisma.ParkedOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParkedOrder>
          }
          groupBy: {
            args: Prisma.ParkedOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParkedOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParkedOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ParkedOrderCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      TaxCategory: {
        payload: Prisma.$TaxCategoryPayload<ExtArgs>
        fields: Prisma.TaxCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          findFirst: {
            args: Prisma.TaxCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          findMany: {
            args: Prisma.TaxCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>[]
          }
          create: {
            args: Prisma.TaxCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          createMany: {
            args: Prisma.TaxCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>[]
          }
          delete: {
            args: Prisma.TaxCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          update: {
            args: Prisma.TaxCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TaxCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>[]
          }
          upsert: {
            args: Prisma.TaxCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxCategoryPayload>
          }
          aggregate: {
            args: Prisma.TaxCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxCategory>
          }
          groupBy: {
            args: Prisma.TaxCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TaxCategoryCountAggregateOutputType> | number
          }
        }
      }
      TaxRate: {
        payload: Prisma.$TaxRatePayload<ExtArgs>
        fields: Prisma.TaxRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findFirst: {
            args: Prisma.TaxRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          findMany: {
            args: Prisma.TaxRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          create: {
            args: Prisma.TaxRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          createMany: {
            args: Prisma.TaxRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          delete: {
            args: Prisma.TaxRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          update: {
            args: Prisma.TaxRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          deleteMany: {
            args: Prisma.TaxRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxRateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>[]
          }
          upsert: {
            args: Prisma.TaxRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxRatePayload>
          }
          aggregate: {
            args: Prisma.TaxRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxRate>
          }
          groupBy: {
            args: Prisma.TaxRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxRateCountArgs<ExtArgs>
            result: $Utils.Optional<TaxRateCountAggregateOutputType> | number
          }
        }
      }
      LocalSettings: {
        payload: Prisma.$LocalSettingsPayload<ExtArgs>
        fields: Prisma.LocalSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocalSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocalSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          findFirst: {
            args: Prisma.LocalSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocalSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          findMany: {
            args: Prisma.LocalSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>[]
          }
          create: {
            args: Prisma.LocalSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          createMany: {
            args: Prisma.LocalSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocalSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>[]
          }
          delete: {
            args: Prisma.LocalSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          update: {
            args: Prisma.LocalSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          deleteMany: {
            args: Prisma.LocalSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocalSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocalSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>[]
          }
          upsert: {
            args: Prisma.LocalSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocalSettingsPayload>
          }
          aggregate: {
            args: Prisma.LocalSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocalSettings>
          }
          groupBy: {
            args: Prisma.LocalSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocalSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocalSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<LocalSettingsCountAggregateOutputType> | number
          }
        }
      }
      Cache: {
        payload: Prisma.$CachePayload<ExtArgs>
        fields: Prisma.CacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          findFirst: {
            args: Prisma.CacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          findMany: {
            args: Prisma.CacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>[]
          }
          create: {
            args: Prisma.CacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          createMany: {
            args: Prisma.CacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CacheCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>[]
          }
          delete: {
            args: Prisma.CacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          update: {
            args: Prisma.CacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          deleteMany: {
            args: Prisma.CacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CacheUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>[]
          }
          upsert: {
            args: Prisma.CacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CachePayload>
          }
          aggregate: {
            args: Prisma.CacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache>
          }
          groupBy: {
            args: Prisma.CacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.CacheCountArgs<ExtArgs>
            result: $Utils.Optional<CacheCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    terminal?: TerminalOmit
    terminalSession?: TerminalSessionOmit
    operationMode?: OperationModeOmit
    connectionLog?: ConnectionLogOmit
    localUser?: LocalUserOmit
    userSession?: UserSessionOmit
    outbox?: OutboxOmit
    syncHistory?: SyncHistoryOmit
    store?: StoreOmit
    location?: LocationOmit
    product?: ProductOmit
    productVariant?: ProductVariantOmit
    category?: CategoryOmit
    brand?: BrandOmit
    customer?: CustomerOmit
    customerGroup?: CustomerGroupOmit
    customerAddress?: CustomerAddressOmit
    inventoryItem?: InventoryItemOmit
    stockAdjustment?: StockAdjustmentOmit
    stockAdjustmentLine?: StockAdjustmentLineOmit
    stockTransfer?: StockTransferOmit
    stockTransferLine?: StockTransferLineOmit
    saleOrder?: SaleOrderOmit
    saleOrderLine?: SaleOrderLineOmit
    payment?: PaymentOmit
    discount?: DiscountOmit
    returnOrder?: ReturnOrderOmit
    returnOrderLine?: ReturnOrderLineOmit
    exchangeOrder?: ExchangeOrderOmit
    parkedOrder?: ParkedOrderOmit
    shift?: ShiftOmit
    taxCategory?: TaxCategoryOmit
    taxRate?: TaxRateOmit
    localSettings?: LocalSettingsOmit
    cache?: CacheOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TerminalCountOutputType
   */

  export type TerminalCountOutputType = {
    sessions: number
    operationModes: number
    connectionLogs: number
    userSessions: number
    outboxes: number
    syncHistories: number
    saleOrders: number
    shifts: number
  }

  export type TerminalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TerminalCountOutputTypeCountSessionsArgs
    operationModes?: boolean | TerminalCountOutputTypeCountOperationModesArgs
    connectionLogs?: boolean | TerminalCountOutputTypeCountConnectionLogsArgs
    userSessions?: boolean | TerminalCountOutputTypeCountUserSessionsArgs
    outboxes?: boolean | TerminalCountOutputTypeCountOutboxesArgs
    syncHistories?: boolean | TerminalCountOutputTypeCountSyncHistoriesArgs
    saleOrders?: boolean | TerminalCountOutputTypeCountSaleOrdersArgs
    shifts?: boolean | TerminalCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalCountOutputType
     */
    select?: TerminalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminalSessionWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountOperationModesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationModeWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountConnectionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionLogWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountOutboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboxWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountSyncHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncHistoryWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountSaleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }


  /**
   * Count Type LocalUserCountOutputType
   */

  export type LocalUserCountOutputType = {
    shifts: number
    saleOrders: number
    sessions: number
  }

  export type LocalUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | LocalUserCountOutputTypeCountShiftsArgs
    saleOrders?: boolean | LocalUserCountOutputTypeCountSaleOrdersArgs
    sessions?: boolean | LocalUserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * LocalUserCountOutputType without action
   */
  export type LocalUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUserCountOutputType
     */
    select?: LocalUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocalUserCountOutputType without action
   */
  export type LocalUserCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * LocalUserCountOutputType without action
   */
  export type LocalUserCountOutputTypeCountSaleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
  }

  /**
   * LocalUserCountOutputType without action
   */
  export type LocalUserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    saleOrders: number
    inventoryItems: number
    shifts: number
    stockAdjustments: number
    stockTransfersFrom: number
    stockTransfersTo: number
    returnOrders: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleOrders?: boolean | LocationCountOutputTypeCountSaleOrdersArgs
    inventoryItems?: boolean | LocationCountOutputTypeCountInventoryItemsArgs
    shifts?: boolean | LocationCountOutputTypeCountShiftsArgs
    stockAdjustments?: boolean | LocationCountOutputTypeCountStockAdjustmentsArgs
    stockTransfersFrom?: boolean | LocationCountOutputTypeCountStockTransfersFromArgs
    stockTransfersTo?: boolean | LocationCountOutputTypeCountStockTransfersToArgs
    returnOrders?: boolean | LocationCountOutputTypeCountReturnOrdersArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountSaleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAdjustmentWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStockTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountReturnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    variants: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
  }


  /**
   * Count Type ProductVariantCountOutputType
   */

  export type ProductVariantCountOutputType = {
    inventoryItems: number
    saleOrderLines: number
    returnOrderLines: number
    stockAdjustmentLines: number
    stockTransferLines: number
  }

  export type ProductVariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inventoryItems?: boolean | ProductVariantCountOutputTypeCountInventoryItemsArgs
    saleOrderLines?: boolean | ProductVariantCountOutputTypeCountSaleOrderLinesArgs
    returnOrderLines?: boolean | ProductVariantCountOutputTypeCountReturnOrderLinesArgs
    stockAdjustmentLines?: boolean | ProductVariantCountOutputTypeCountStockAdjustmentLinesArgs
    stockTransferLines?: boolean | ProductVariantCountOutputTypeCountStockTransferLinesArgs
  }

  // Custom InputTypes
  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariantCountOutputType
     */
    select?: ProductVariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountSaleOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderLineWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountReturnOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderLineWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockAdjustmentLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAdjustmentLineWhereInput
  }

  /**
   * ProductVariantCountOutputType without action
   */
  export type ProductVariantCountOutputTypeCountStockTransferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferLineWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    children: number
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CategoryCountOutputTypeCountChildrenArgs
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    products: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BrandCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    addresses: number
    saleOrders: number
    returnOrders: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | CustomerCountOutputTypeCountAddressesArgs
    saleOrders?: boolean | CustomerCountOutputTypeCountSaleOrdersArgs
    returnOrders?: boolean | CustomerCountOutputTypeCountReturnOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSaleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountReturnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderWhereInput
  }


  /**
   * Count Type CustomerGroupCountOutputType
   */

  export type CustomerGroupCountOutputType = {
    customers: number
  }

  export type CustomerGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerGroupCountOutputTypeCountCustomersArgs
  }

  // Custom InputTypes
  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroupCountOutputType
     */
    select?: CustomerGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerGroupCountOutputType without action
   */
  export type CustomerGroupCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }


  /**
   * Count Type StockAdjustmentCountOutputType
   */

  export type StockAdjustmentCountOutputType = {
    lineItems: number
  }

  export type StockAdjustmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | StockAdjustmentCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * StockAdjustmentCountOutputType without action
   */
  export type StockAdjustmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentCountOutputType
     */
    select?: StockAdjustmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockAdjustmentCountOutputType without action
   */
  export type StockAdjustmentCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAdjustmentLineWhereInput
  }


  /**
   * Count Type StockTransferCountOutputType
   */

  export type StockTransferCountOutputType = {
    lineItems: number
  }

  export type StockTransferCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineItems?: boolean | StockTransferCountOutputTypeCountLineItemsArgs
  }

  // Custom InputTypes
  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferCountOutputType
     */
    select?: StockTransferCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StockTransferCountOutputType without action
   */
  export type StockTransferCountOutputTypeCountLineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferLineWhereInput
  }


  /**
   * Count Type SaleOrderCountOutputType
   */

  export type SaleOrderCountOutputType = {
    lines: number
    payments: number
    discounts: number
    returnOrders: number
    parkedOrders: number
    exchangesFrom: number
    exchangesTo: number
  }

  export type SaleOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | SaleOrderCountOutputTypeCountLinesArgs
    payments?: boolean | SaleOrderCountOutputTypeCountPaymentsArgs
    discounts?: boolean | SaleOrderCountOutputTypeCountDiscountsArgs
    returnOrders?: boolean | SaleOrderCountOutputTypeCountReturnOrdersArgs
    parkedOrders?: boolean | SaleOrderCountOutputTypeCountParkedOrdersArgs
    exchangesFrom?: boolean | SaleOrderCountOutputTypeCountExchangesFromArgs
    exchangesTo?: boolean | SaleOrderCountOutputTypeCountExchangesToArgs
  }

  // Custom InputTypes
  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderCountOutputType
     */
    select?: SaleOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderLineWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountReturnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountParkedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkedOrderWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountExchangesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeOrderWhereInput
  }

  /**
   * SaleOrderCountOutputType without action
   */
  export type SaleOrderCountOutputTypeCountExchangesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeOrderWhereInput
  }


  /**
   * Count Type ReturnOrderCountOutputType
   */

  export type ReturnOrderCountOutputType = {
    lines: number
  }

  export type ReturnOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | ReturnOrderCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * ReturnOrderCountOutputType without action
   */
  export type ReturnOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderCountOutputType
     */
    select?: ReturnOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReturnOrderCountOutputType without action
   */
  export type ReturnOrderCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderLineWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    saleOrders: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleOrders?: boolean | ShiftCountOutputTypeCountSaleOrdersArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountSaleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
  }


  /**
   * Count Type TaxCategoryCountOutputType
   */

  export type TaxCategoryCountOutputType = {
    products: number
    rates: number
  }

  export type TaxCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | TaxCategoryCountOutputTypeCountProductsArgs
    rates?: boolean | TaxCategoryCountOutputTypeCountRatesArgs
  }

  // Custom InputTypes
  /**
   * TaxCategoryCountOutputType without action
   */
  export type TaxCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategoryCountOutputType
     */
    select?: TaxCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaxCategoryCountOutputType without action
   */
  export type TaxCategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * TaxCategoryCountOutputType without action
   */
  export type TaxCategoryCountOutputTypeCountRatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRateWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Terminal
   */

  export type AggregateTerminal = {
    _count: TerminalCountAggregateOutputType | null
    _min: TerminalMinAggregateOutputType | null
    _max: TerminalMaxAggregateOutputType | null
  }

  export type TerminalMinAggregateOutputType = {
    id: string | null
    terminalCode: string | null
    terminalName: string | null
    macAddress: string | null
    centralTerminalId: string | null
    centralStoreId: string | null
    centralBranchId: string | null
    centralLocationId: string | null
    apiKey: string | null
    sessionToken: string | null
    sessionExpiry: Date | null
    storeName: string | null
    branchName: string | null
    locationName: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    currentShiftId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalMaxAggregateOutputType = {
    id: string | null
    terminalCode: string | null
    terminalName: string | null
    macAddress: string | null
    centralTerminalId: string | null
    centralStoreId: string | null
    centralBranchId: string | null
    centralLocationId: string | null
    apiKey: string | null
    sessionToken: string | null
    sessionExpiry: Date | null
    storeName: string | null
    branchName: string | null
    locationName: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    currentShiftId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalCountAggregateOutputType = {
    id: number
    terminalCode: number
    terminalName: number
    macAddress: number
    centralTerminalId: number
    centralStoreId: number
    centralBranchId: number
    centralLocationId: number
    apiKey: number
    sessionToken: number
    sessionExpiry: number
    storeName: number
    branchName: number
    locationName: number
    features: number
    isActive: number
    lastLoginAt: number
    currentShiftId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerminalMinAggregateInputType = {
    id?: true
    terminalCode?: true
    terminalName?: true
    macAddress?: true
    centralTerminalId?: true
    centralStoreId?: true
    centralBranchId?: true
    centralLocationId?: true
    apiKey?: true
    sessionToken?: true
    sessionExpiry?: true
    storeName?: true
    branchName?: true
    locationName?: true
    isActive?: true
    lastLoginAt?: true
    currentShiftId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalMaxAggregateInputType = {
    id?: true
    terminalCode?: true
    terminalName?: true
    macAddress?: true
    centralTerminalId?: true
    centralStoreId?: true
    centralBranchId?: true
    centralLocationId?: true
    apiKey?: true
    sessionToken?: true
    sessionExpiry?: true
    storeName?: true
    branchName?: true
    locationName?: true
    isActive?: true
    lastLoginAt?: true
    currentShiftId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalCountAggregateInputType = {
    id?: true
    terminalCode?: true
    terminalName?: true
    macAddress?: true
    centralTerminalId?: true
    centralStoreId?: true
    centralBranchId?: true
    centralLocationId?: true
    apiKey?: true
    sessionToken?: true
    sessionExpiry?: true
    storeName?: true
    branchName?: true
    locationName?: true
    features?: true
    isActive?: true
    lastLoginAt?: true
    currentShiftId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerminalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terminal to aggregate.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terminals
    **/
    _count?: true | TerminalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminalMaxAggregateInputType
  }

  export type GetTerminalAggregateType<T extends TerminalAggregateArgs> = {
        [P in keyof T & keyof AggregateTerminal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerminal[P]>
      : GetScalarType<T[P], AggregateTerminal[P]>
  }




  export type TerminalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminalWhereInput
    orderBy?: TerminalOrderByWithAggregationInput | TerminalOrderByWithAggregationInput[]
    by: TerminalScalarFieldEnum[] | TerminalScalarFieldEnum
    having?: TerminalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminalCountAggregateInputType | true
    _min?: TerminalMinAggregateInputType
    _max?: TerminalMaxAggregateInputType
  }

  export type TerminalGroupByOutputType = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId: string | null
    apiKey: string
    sessionToken: string | null
    sessionExpiry: Date | null
    storeName: string | null
    branchName: string | null
    locationName: string | null
    features: JsonValue
    isActive: boolean
    lastLoginAt: Date | null
    currentShiftId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TerminalCountAggregateOutputType | null
    _min: TerminalMinAggregateOutputType | null
    _max: TerminalMaxAggregateOutputType | null
  }

  type GetTerminalGroupByPayload<T extends TerminalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminalGroupByOutputType[P]>
            : GetScalarType<T[P], TerminalGroupByOutputType[P]>
        }
      >
    >


  export type TerminalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalCode?: boolean
    terminalName?: boolean
    macAddress?: boolean
    centralTerminalId?: boolean
    centralStoreId?: boolean
    centralBranchId?: boolean
    centralLocationId?: boolean
    apiKey?: boolean
    sessionToken?: boolean
    sessionExpiry?: boolean
    storeName?: boolean
    branchName?: boolean
    locationName?: boolean
    features?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    currentShiftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | Terminal$sessionsArgs<ExtArgs>
    operationModes?: boolean | Terminal$operationModesArgs<ExtArgs>
    connectionLogs?: boolean | Terminal$connectionLogsArgs<ExtArgs>
    userSessions?: boolean | Terminal$userSessionsArgs<ExtArgs>
    outboxes?: boolean | Terminal$outboxesArgs<ExtArgs>
    syncHistories?: boolean | Terminal$syncHistoriesArgs<ExtArgs>
    saleOrders?: boolean | Terminal$saleOrdersArgs<ExtArgs>
    shifts?: boolean | Terminal$shiftsArgs<ExtArgs>
    _count?: boolean | TerminalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminal"]>

  export type TerminalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalCode?: boolean
    terminalName?: boolean
    macAddress?: boolean
    centralTerminalId?: boolean
    centralStoreId?: boolean
    centralBranchId?: boolean
    centralLocationId?: boolean
    apiKey?: boolean
    sessionToken?: boolean
    sessionExpiry?: boolean
    storeName?: boolean
    branchName?: boolean
    locationName?: boolean
    features?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    currentShiftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["terminal"]>

  export type TerminalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalCode?: boolean
    terminalName?: boolean
    macAddress?: boolean
    centralTerminalId?: boolean
    centralStoreId?: boolean
    centralBranchId?: boolean
    centralLocationId?: boolean
    apiKey?: boolean
    sessionToken?: boolean
    sessionExpiry?: boolean
    storeName?: boolean
    branchName?: boolean
    locationName?: boolean
    features?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    currentShiftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["terminal"]>

  export type TerminalSelectScalar = {
    id?: boolean
    terminalCode?: boolean
    terminalName?: boolean
    macAddress?: boolean
    centralTerminalId?: boolean
    centralStoreId?: boolean
    centralBranchId?: boolean
    centralLocationId?: boolean
    apiKey?: boolean
    sessionToken?: boolean
    sessionExpiry?: boolean
    storeName?: boolean
    branchName?: boolean
    locationName?: boolean
    features?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    currentShiftId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerminalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalCode" | "terminalName" | "macAddress" | "centralTerminalId" | "centralStoreId" | "centralBranchId" | "centralLocationId" | "apiKey" | "sessionToken" | "sessionExpiry" | "storeName" | "branchName" | "locationName" | "features" | "isActive" | "lastLoginAt" | "currentShiftId" | "createdAt" | "updatedAt", ExtArgs["result"]["terminal"]>
  export type TerminalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Terminal$sessionsArgs<ExtArgs>
    operationModes?: boolean | Terminal$operationModesArgs<ExtArgs>
    connectionLogs?: boolean | Terminal$connectionLogsArgs<ExtArgs>
    userSessions?: boolean | Terminal$userSessionsArgs<ExtArgs>
    outboxes?: boolean | Terminal$outboxesArgs<ExtArgs>
    syncHistories?: boolean | Terminal$syncHistoriesArgs<ExtArgs>
    saleOrders?: boolean | Terminal$saleOrdersArgs<ExtArgs>
    shifts?: boolean | Terminal$shiftsArgs<ExtArgs>
    _count?: boolean | TerminalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TerminalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TerminalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TerminalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Terminal"
    objects: {
      sessions: Prisma.$TerminalSessionPayload<ExtArgs>[]
      operationModes: Prisma.$OperationModePayload<ExtArgs>[]
      connectionLogs: Prisma.$ConnectionLogPayload<ExtArgs>[]
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      outboxes: Prisma.$OutboxPayload<ExtArgs>[]
      syncHistories: Prisma.$SyncHistoryPayload<ExtArgs>[]
      saleOrders: Prisma.$SaleOrderPayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalCode: string
      terminalName: string
      macAddress: string
      centralTerminalId: string
      centralStoreId: string
      centralBranchId: string
      centralLocationId: string | null
      apiKey: string
      sessionToken: string | null
      sessionExpiry: Date | null
      storeName: string | null
      branchName: string | null
      locationName: string | null
      features: Prisma.JsonValue
      isActive: boolean
      lastLoginAt: Date | null
      currentShiftId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["terminal"]>
    composites: {}
  }

  type TerminalGetPayload<S extends boolean | null | undefined | TerminalDefaultArgs> = $Result.GetResult<Prisma.$TerminalPayload, S>

  type TerminalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerminalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerminalCountAggregateInputType | true
    }

  export interface TerminalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Terminal'], meta: { name: 'Terminal' } }
    /**
     * Find zero or one Terminal that matches the filter.
     * @param {TerminalFindUniqueArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerminalFindUniqueArgs>(args: SelectSubset<T, TerminalFindUniqueArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Terminal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerminalFindUniqueOrThrowArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerminalFindUniqueOrThrowArgs>(args: SelectSubset<T, TerminalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Terminal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindFirstArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerminalFindFirstArgs>(args?: SelectSubset<T, TerminalFindFirstArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Terminal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindFirstOrThrowArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerminalFindFirstOrThrowArgs>(args?: SelectSubset<T, TerminalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Terminals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terminals
     * const terminals = await prisma.terminal.findMany()
     * 
     * // Get first 10 Terminals
     * const terminals = await prisma.terminal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminalWithIdOnly = await prisma.terminal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerminalFindManyArgs>(args?: SelectSubset<T, TerminalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Terminal.
     * @param {TerminalCreateArgs} args - Arguments to create a Terminal.
     * @example
     * // Create one Terminal
     * const Terminal = await prisma.terminal.create({
     *   data: {
     *     // ... data to create a Terminal
     *   }
     * })
     * 
     */
    create<T extends TerminalCreateArgs>(args: SelectSubset<T, TerminalCreateArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Terminals.
     * @param {TerminalCreateManyArgs} args - Arguments to create many Terminals.
     * @example
     * // Create many Terminals
     * const terminal = await prisma.terminal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerminalCreateManyArgs>(args?: SelectSubset<T, TerminalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Terminals and returns the data saved in the database.
     * @param {TerminalCreateManyAndReturnArgs} args - Arguments to create many Terminals.
     * @example
     * // Create many Terminals
     * const terminal = await prisma.terminal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Terminals and only return the `id`
     * const terminalWithIdOnly = await prisma.terminal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerminalCreateManyAndReturnArgs>(args?: SelectSubset<T, TerminalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Terminal.
     * @param {TerminalDeleteArgs} args - Arguments to delete one Terminal.
     * @example
     * // Delete one Terminal
     * const Terminal = await prisma.terminal.delete({
     *   where: {
     *     // ... filter to delete one Terminal
     *   }
     * })
     * 
     */
    delete<T extends TerminalDeleteArgs>(args: SelectSubset<T, TerminalDeleteArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Terminal.
     * @param {TerminalUpdateArgs} args - Arguments to update one Terminal.
     * @example
     * // Update one Terminal
     * const terminal = await prisma.terminal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerminalUpdateArgs>(args: SelectSubset<T, TerminalUpdateArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Terminals.
     * @param {TerminalDeleteManyArgs} args - Arguments to filter Terminals to delete.
     * @example
     * // Delete a few Terminals
     * const { count } = await prisma.terminal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerminalDeleteManyArgs>(args?: SelectSubset<T, TerminalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terminals
     * const terminal = await prisma.terminal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerminalUpdateManyArgs>(args: SelectSubset<T, TerminalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminals and returns the data updated in the database.
     * @param {TerminalUpdateManyAndReturnArgs} args - Arguments to update many Terminals.
     * @example
     * // Update many Terminals
     * const terminal = await prisma.terminal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Terminals and only return the `id`
     * const terminalWithIdOnly = await prisma.terminal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TerminalUpdateManyAndReturnArgs>(args: SelectSubset<T, TerminalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Terminal.
     * @param {TerminalUpsertArgs} args - Arguments to update or create a Terminal.
     * @example
     * // Update or create a Terminal
     * const terminal = await prisma.terminal.upsert({
     *   create: {
     *     // ... data to create a Terminal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terminal we want to update
     *   }
     * })
     */
    upsert<T extends TerminalUpsertArgs>(args: SelectSubset<T, TerminalUpsertArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Terminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalCountArgs} args - Arguments to filter Terminals to count.
     * @example
     * // Count the number of Terminals
     * const count = await prisma.terminal.count({
     *   where: {
     *     // ... the filter for the Terminals we want to count
     *   }
     * })
    **/
    count<T extends TerminalCountArgs>(
      args?: Subset<T, TerminalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminalAggregateArgs>(args: Subset<T, TerminalAggregateArgs>): Prisma.PrismaPromise<GetTerminalAggregateType<T>>

    /**
     * Group by Terminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerminalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerminalGroupByArgs['orderBy'] }
        : { orderBy?: TerminalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerminalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Terminal model
   */
  readonly fields: TerminalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Terminal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerminalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Terminal$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operationModes<T extends Terminal$operationModesArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$operationModesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    connectionLogs<T extends Terminal$connectionLogsArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$connectionLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSessions<T extends Terminal$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    outboxes<T extends Terminal$outboxesArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$outboxesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    syncHistories<T extends Terminal$syncHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$syncHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleOrders<T extends Terminal$saleOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$saleOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends Terminal$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Terminal model
   */
  interface TerminalFieldRefs {
    readonly id: FieldRef<"Terminal", 'String'>
    readonly terminalCode: FieldRef<"Terminal", 'String'>
    readonly terminalName: FieldRef<"Terminal", 'String'>
    readonly macAddress: FieldRef<"Terminal", 'String'>
    readonly centralTerminalId: FieldRef<"Terminal", 'String'>
    readonly centralStoreId: FieldRef<"Terminal", 'String'>
    readonly centralBranchId: FieldRef<"Terminal", 'String'>
    readonly centralLocationId: FieldRef<"Terminal", 'String'>
    readonly apiKey: FieldRef<"Terminal", 'String'>
    readonly sessionToken: FieldRef<"Terminal", 'String'>
    readonly sessionExpiry: FieldRef<"Terminal", 'DateTime'>
    readonly storeName: FieldRef<"Terminal", 'String'>
    readonly branchName: FieldRef<"Terminal", 'String'>
    readonly locationName: FieldRef<"Terminal", 'String'>
    readonly features: FieldRef<"Terminal", 'Json'>
    readonly isActive: FieldRef<"Terminal", 'Boolean'>
    readonly lastLoginAt: FieldRef<"Terminal", 'DateTime'>
    readonly currentShiftId: FieldRef<"Terminal", 'String'>
    readonly createdAt: FieldRef<"Terminal", 'DateTime'>
    readonly updatedAt: FieldRef<"Terminal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Terminal findUnique
   */
  export type TerminalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal findUniqueOrThrow
   */
  export type TerminalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal findFirst
   */
  export type TerminalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminals.
     */
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal findFirstOrThrow
   */
  export type TerminalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminals.
     */
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal findMany
   */
  export type TerminalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminals to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal create
   */
  export type TerminalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The data needed to create a Terminal.
     */
    data: XOR<TerminalCreateInput, TerminalUncheckedCreateInput>
  }

  /**
   * Terminal createMany
   */
  export type TerminalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terminals.
     */
    data: TerminalCreateManyInput | TerminalCreateManyInput[]
  }

  /**
   * Terminal createManyAndReturn
   */
  export type TerminalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * The data used to create many Terminals.
     */
    data: TerminalCreateManyInput | TerminalCreateManyInput[]
  }

  /**
   * Terminal update
   */
  export type TerminalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The data needed to update a Terminal.
     */
    data: XOR<TerminalUpdateInput, TerminalUncheckedUpdateInput>
    /**
     * Choose, which Terminal to update.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal updateMany
   */
  export type TerminalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terminals.
     */
    data: XOR<TerminalUpdateManyMutationInput, TerminalUncheckedUpdateManyInput>
    /**
     * Filter which Terminals to update
     */
    where?: TerminalWhereInput
    /**
     * Limit how many Terminals to update.
     */
    limit?: number
  }

  /**
   * Terminal updateManyAndReturn
   */
  export type TerminalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * The data used to update Terminals.
     */
    data: XOR<TerminalUpdateManyMutationInput, TerminalUncheckedUpdateManyInput>
    /**
     * Filter which Terminals to update
     */
    where?: TerminalWhereInput
    /**
     * Limit how many Terminals to update.
     */
    limit?: number
  }

  /**
   * Terminal upsert
   */
  export type TerminalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The filter to search for the Terminal to update in case it exists.
     */
    where: TerminalWhereUniqueInput
    /**
     * In case the Terminal found by the `where` argument doesn't exist, create a new Terminal with this data.
     */
    create: XOR<TerminalCreateInput, TerminalUncheckedCreateInput>
    /**
     * In case the Terminal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerminalUpdateInput, TerminalUncheckedUpdateInput>
  }

  /**
   * Terminal delete
   */
  export type TerminalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter which Terminal to delete.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal deleteMany
   */
  export type TerminalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terminals to delete
     */
    where?: TerminalWhereInput
    /**
     * Limit how many Terminals to delete.
     */
    limit?: number
  }

  /**
   * Terminal.sessions
   */
  export type Terminal$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    where?: TerminalSessionWhereInput
    orderBy?: TerminalSessionOrderByWithRelationInput | TerminalSessionOrderByWithRelationInput[]
    cursor?: TerminalSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TerminalSessionScalarFieldEnum | TerminalSessionScalarFieldEnum[]
  }

  /**
   * Terminal.operationModes
   */
  export type Terminal$operationModesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    where?: OperationModeWhereInput
    orderBy?: OperationModeOrderByWithRelationInput | OperationModeOrderByWithRelationInput[]
    cursor?: OperationModeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperationModeScalarFieldEnum | OperationModeScalarFieldEnum[]
  }

  /**
   * Terminal.connectionLogs
   */
  export type Terminal$connectionLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    where?: ConnectionLogWhereInput
    orderBy?: ConnectionLogOrderByWithRelationInput | ConnectionLogOrderByWithRelationInput[]
    cursor?: ConnectionLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionLogScalarFieldEnum | ConnectionLogScalarFieldEnum[]
  }

  /**
   * Terminal.userSessions
   */
  export type Terminal$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * Terminal.outboxes
   */
  export type Terminal$outboxesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    where?: OutboxWhereInput
    orderBy?: OutboxOrderByWithRelationInput | OutboxOrderByWithRelationInput[]
    cursor?: OutboxWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OutboxScalarFieldEnum | OutboxScalarFieldEnum[]
  }

  /**
   * Terminal.syncHistories
   */
  export type Terminal$syncHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    where?: SyncHistoryWhereInput
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    cursor?: SyncHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * Terminal.saleOrders
   */
  export type Terminal$saleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    cursor?: SaleOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * Terminal.shifts
   */
  export type Terminal$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Terminal without action
   */
  export type TerminalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
  }


  /**
   * Model TerminalSession
   */

  export type AggregateTerminalSession = {
    _count: TerminalSessionCountAggregateOutputType | null
    _min: TerminalSessionMinAggregateOutputType | null
    _max: TerminalSessionMaxAggregateOutputType | null
  }

  export type TerminalSessionMinAggregateOutputType = {
    id: string | null
    terminalId: string | null
    sessionToken: string | null
    startedAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    ipAddress: string | null
    isActive: boolean | null
  }

  export type TerminalSessionMaxAggregateOutputType = {
    id: string | null
    terminalId: string | null
    sessionToken: string | null
    startedAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    ipAddress: string | null
    isActive: boolean | null
  }

  export type TerminalSessionCountAggregateOutputType = {
    id: number
    terminalId: number
    sessionToken: number
    startedAt: number
    expiresAt: number
    lastActivityAt: number
    ipAddress: number
    isActive: number
    _all: number
  }


  export type TerminalSessionMinAggregateInputType = {
    id?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    ipAddress?: true
    isActive?: true
  }

  export type TerminalSessionMaxAggregateInputType = {
    id?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    ipAddress?: true
    isActive?: true
  }

  export type TerminalSessionCountAggregateInputType = {
    id?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    ipAddress?: true
    isActive?: true
    _all?: true
  }

  export type TerminalSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerminalSession to aggregate.
     */
    where?: TerminalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSessions to fetch.
     */
    orderBy?: TerminalSessionOrderByWithRelationInput | TerminalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerminalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TerminalSessions
    **/
    _count?: true | TerminalSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminalSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminalSessionMaxAggregateInputType
  }

  export type GetTerminalSessionAggregateType<T extends TerminalSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTerminalSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerminalSession[P]>
      : GetScalarType<T[P], AggregateTerminalSession[P]>
  }




  export type TerminalSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminalSessionWhereInput
    orderBy?: TerminalSessionOrderByWithAggregationInput | TerminalSessionOrderByWithAggregationInput[]
    by: TerminalSessionScalarFieldEnum[] | TerminalSessionScalarFieldEnum
    having?: TerminalSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminalSessionCountAggregateInputType | true
    _min?: TerminalSessionMinAggregateInputType
    _max?: TerminalSessionMaxAggregateInputType
  }

  export type TerminalSessionGroupByOutputType = {
    id: string
    terminalId: string
    sessionToken: string
    startedAt: Date
    expiresAt: Date
    lastActivityAt: Date
    ipAddress: string | null
    isActive: boolean
    _count: TerminalSessionCountAggregateOutputType | null
    _min: TerminalSessionMinAggregateOutputType | null
    _max: TerminalSessionMaxAggregateOutputType | null
  }

  type GetTerminalSessionGroupByPayload<T extends TerminalSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminalSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminalSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminalSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TerminalSessionGroupByOutputType[P]>
        }
      >
    >


  export type TerminalSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    ipAddress?: boolean
    isActive?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSession"]>

  export type TerminalSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    ipAddress?: boolean
    isActive?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSession"]>

  export type TerminalSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    ipAddress?: boolean
    isActive?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminalSession"]>

  export type TerminalSessionSelectScalar = {
    id?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    ipAddress?: boolean
    isActive?: boolean
  }

  export type TerminalSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalId" | "sessionToken" | "startedAt" | "expiresAt" | "lastActivityAt" | "ipAddress" | "isActive", ExtArgs["result"]["terminalSession"]>
  export type TerminalSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type TerminalSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type TerminalSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $TerminalSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TerminalSession"
    objects: {
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalId: string
      sessionToken: string
      startedAt: Date
      expiresAt: Date
      lastActivityAt: Date
      ipAddress: string | null
      isActive: boolean
    }, ExtArgs["result"]["terminalSession"]>
    composites: {}
  }

  type TerminalSessionGetPayload<S extends boolean | null | undefined | TerminalSessionDefaultArgs> = $Result.GetResult<Prisma.$TerminalSessionPayload, S>

  type TerminalSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TerminalSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TerminalSessionCountAggregateInputType | true
    }

  export interface TerminalSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TerminalSession'], meta: { name: 'TerminalSession' } }
    /**
     * Find zero or one TerminalSession that matches the filter.
     * @param {TerminalSessionFindUniqueArgs} args - Arguments to find a TerminalSession
     * @example
     * // Get one TerminalSession
     * const terminalSession = await prisma.terminalSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerminalSessionFindUniqueArgs>(args: SelectSubset<T, TerminalSessionFindUniqueArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TerminalSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TerminalSessionFindUniqueOrThrowArgs} args - Arguments to find a TerminalSession
     * @example
     * // Get one TerminalSession
     * const terminalSession = await prisma.terminalSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerminalSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TerminalSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerminalSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionFindFirstArgs} args - Arguments to find a TerminalSession
     * @example
     * // Get one TerminalSession
     * const terminalSession = await prisma.terminalSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerminalSessionFindFirstArgs>(args?: SelectSubset<T, TerminalSessionFindFirstArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TerminalSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionFindFirstOrThrowArgs} args - Arguments to find a TerminalSession
     * @example
     * // Get one TerminalSession
     * const terminalSession = await prisma.terminalSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerminalSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TerminalSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TerminalSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TerminalSessions
     * const terminalSessions = await prisma.terminalSession.findMany()
     * 
     * // Get first 10 TerminalSessions
     * const terminalSessions = await prisma.terminalSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminalSessionWithIdOnly = await prisma.terminalSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerminalSessionFindManyArgs>(args?: SelectSubset<T, TerminalSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TerminalSession.
     * @param {TerminalSessionCreateArgs} args - Arguments to create a TerminalSession.
     * @example
     * // Create one TerminalSession
     * const TerminalSession = await prisma.terminalSession.create({
     *   data: {
     *     // ... data to create a TerminalSession
     *   }
     * })
     * 
     */
    create<T extends TerminalSessionCreateArgs>(args: SelectSubset<T, TerminalSessionCreateArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TerminalSessions.
     * @param {TerminalSessionCreateManyArgs} args - Arguments to create many TerminalSessions.
     * @example
     * // Create many TerminalSessions
     * const terminalSession = await prisma.terminalSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerminalSessionCreateManyArgs>(args?: SelectSubset<T, TerminalSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TerminalSessions and returns the data saved in the database.
     * @param {TerminalSessionCreateManyAndReturnArgs} args - Arguments to create many TerminalSessions.
     * @example
     * // Create many TerminalSessions
     * const terminalSession = await prisma.terminalSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TerminalSessions and only return the `id`
     * const terminalSessionWithIdOnly = await prisma.terminalSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerminalSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TerminalSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TerminalSession.
     * @param {TerminalSessionDeleteArgs} args - Arguments to delete one TerminalSession.
     * @example
     * // Delete one TerminalSession
     * const TerminalSession = await prisma.terminalSession.delete({
     *   where: {
     *     // ... filter to delete one TerminalSession
     *   }
     * })
     * 
     */
    delete<T extends TerminalSessionDeleteArgs>(args: SelectSubset<T, TerminalSessionDeleteArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TerminalSession.
     * @param {TerminalSessionUpdateArgs} args - Arguments to update one TerminalSession.
     * @example
     * // Update one TerminalSession
     * const terminalSession = await prisma.terminalSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerminalSessionUpdateArgs>(args: SelectSubset<T, TerminalSessionUpdateArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TerminalSessions.
     * @param {TerminalSessionDeleteManyArgs} args - Arguments to filter TerminalSessions to delete.
     * @example
     * // Delete a few TerminalSessions
     * const { count } = await prisma.terminalSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerminalSessionDeleteManyArgs>(args?: SelectSubset<T, TerminalSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerminalSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TerminalSessions
     * const terminalSession = await prisma.terminalSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerminalSessionUpdateManyArgs>(args: SelectSubset<T, TerminalSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TerminalSessions and returns the data updated in the database.
     * @param {TerminalSessionUpdateManyAndReturnArgs} args - Arguments to update many TerminalSessions.
     * @example
     * // Update many TerminalSessions
     * const terminalSession = await prisma.terminalSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TerminalSessions and only return the `id`
     * const terminalSessionWithIdOnly = await prisma.terminalSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TerminalSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, TerminalSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TerminalSession.
     * @param {TerminalSessionUpsertArgs} args - Arguments to update or create a TerminalSession.
     * @example
     * // Update or create a TerminalSession
     * const terminalSession = await prisma.terminalSession.upsert({
     *   create: {
     *     // ... data to create a TerminalSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TerminalSession we want to update
     *   }
     * })
     */
    upsert<T extends TerminalSessionUpsertArgs>(args: SelectSubset<T, TerminalSessionUpsertArgs<ExtArgs>>): Prisma__TerminalSessionClient<$Result.GetResult<Prisma.$TerminalSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TerminalSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionCountArgs} args - Arguments to filter TerminalSessions to count.
     * @example
     * // Count the number of TerminalSessions
     * const count = await prisma.terminalSession.count({
     *   where: {
     *     // ... the filter for the TerminalSessions we want to count
     *   }
     * })
    **/
    count<T extends TerminalSessionCountArgs>(
      args?: Subset<T, TerminalSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminalSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TerminalSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminalSessionAggregateArgs>(args: Subset<T, TerminalSessionAggregateArgs>): Prisma.PrismaPromise<GetTerminalSessionAggregateType<T>>

    /**
     * Group by TerminalSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerminalSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerminalSessionGroupByArgs['orderBy'] }
        : { orderBy?: TerminalSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerminalSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminalSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TerminalSession model
   */
  readonly fields: TerminalSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TerminalSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerminalSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TerminalSession model
   */
  interface TerminalSessionFieldRefs {
    readonly id: FieldRef<"TerminalSession", 'String'>
    readonly terminalId: FieldRef<"TerminalSession", 'String'>
    readonly sessionToken: FieldRef<"TerminalSession", 'String'>
    readonly startedAt: FieldRef<"TerminalSession", 'DateTime'>
    readonly expiresAt: FieldRef<"TerminalSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"TerminalSession", 'DateTime'>
    readonly ipAddress: FieldRef<"TerminalSession", 'String'>
    readonly isActive: FieldRef<"TerminalSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TerminalSession findUnique
   */
  export type TerminalSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSession to fetch.
     */
    where: TerminalSessionWhereUniqueInput
  }

  /**
   * TerminalSession findUniqueOrThrow
   */
  export type TerminalSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSession to fetch.
     */
    where: TerminalSessionWhereUniqueInput
  }

  /**
   * TerminalSession findFirst
   */
  export type TerminalSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSession to fetch.
     */
    where?: TerminalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSessions to fetch.
     */
    orderBy?: TerminalSessionOrderByWithRelationInput | TerminalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerminalSessions.
     */
    cursor?: TerminalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerminalSessions.
     */
    distinct?: TerminalSessionScalarFieldEnum | TerminalSessionScalarFieldEnum[]
  }

  /**
   * TerminalSession findFirstOrThrow
   */
  export type TerminalSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSession to fetch.
     */
    where?: TerminalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSessions to fetch.
     */
    orderBy?: TerminalSessionOrderByWithRelationInput | TerminalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TerminalSessions.
     */
    cursor?: TerminalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TerminalSessions.
     */
    distinct?: TerminalSessionScalarFieldEnum | TerminalSessionScalarFieldEnum[]
  }

  /**
   * TerminalSession findMany
   */
  export type TerminalSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter, which TerminalSessions to fetch.
     */
    where?: TerminalSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TerminalSessions to fetch.
     */
    orderBy?: TerminalSessionOrderByWithRelationInput | TerminalSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TerminalSessions.
     */
    cursor?: TerminalSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TerminalSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TerminalSessions.
     */
    skip?: number
    distinct?: TerminalSessionScalarFieldEnum | TerminalSessionScalarFieldEnum[]
  }

  /**
   * TerminalSession create
   */
  export type TerminalSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TerminalSession.
     */
    data: XOR<TerminalSessionCreateInput, TerminalSessionUncheckedCreateInput>
  }

  /**
   * TerminalSession createMany
   */
  export type TerminalSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TerminalSessions.
     */
    data: TerminalSessionCreateManyInput | TerminalSessionCreateManyInput[]
  }

  /**
   * TerminalSession createManyAndReturn
   */
  export type TerminalSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * The data used to create many TerminalSessions.
     */
    data: TerminalSessionCreateManyInput | TerminalSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TerminalSession update
   */
  export type TerminalSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TerminalSession.
     */
    data: XOR<TerminalSessionUpdateInput, TerminalSessionUncheckedUpdateInput>
    /**
     * Choose, which TerminalSession to update.
     */
    where: TerminalSessionWhereUniqueInput
  }

  /**
   * TerminalSession updateMany
   */
  export type TerminalSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TerminalSessions.
     */
    data: XOR<TerminalSessionUpdateManyMutationInput, TerminalSessionUncheckedUpdateManyInput>
    /**
     * Filter which TerminalSessions to update
     */
    where?: TerminalSessionWhereInput
    /**
     * Limit how many TerminalSessions to update.
     */
    limit?: number
  }

  /**
   * TerminalSession updateManyAndReturn
   */
  export type TerminalSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * The data used to update TerminalSessions.
     */
    data: XOR<TerminalSessionUpdateManyMutationInput, TerminalSessionUncheckedUpdateManyInput>
    /**
     * Filter which TerminalSessions to update
     */
    where?: TerminalSessionWhereInput
    /**
     * Limit how many TerminalSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TerminalSession upsert
   */
  export type TerminalSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TerminalSession to update in case it exists.
     */
    where: TerminalSessionWhereUniqueInput
    /**
     * In case the TerminalSession found by the `where` argument doesn't exist, create a new TerminalSession with this data.
     */
    create: XOR<TerminalSessionCreateInput, TerminalSessionUncheckedCreateInput>
    /**
     * In case the TerminalSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerminalSessionUpdateInput, TerminalSessionUncheckedUpdateInput>
  }

  /**
   * TerminalSession delete
   */
  export type TerminalSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
    /**
     * Filter which TerminalSession to delete.
     */
    where: TerminalSessionWhereUniqueInput
  }

  /**
   * TerminalSession deleteMany
   */
  export type TerminalSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TerminalSessions to delete
     */
    where?: TerminalSessionWhereInput
    /**
     * Limit how many TerminalSessions to delete.
     */
    limit?: number
  }

  /**
   * TerminalSession without action
   */
  export type TerminalSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalSession
     */
    select?: TerminalSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TerminalSession
     */
    omit?: TerminalSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalSessionInclude<ExtArgs> | null
  }


  /**
   * Model OperationMode
   */

  export type AggregateOperationMode = {
    _count: OperationModeCountAggregateOutputType | null
    _avg: OperationModeAvgAggregateOutputType | null
    _sum: OperationModeSumAggregateOutputType | null
    _min: OperationModeMinAggregateOutputType | null
    _max: OperationModeMaxAggregateOutputType | null
  }

  export type OperationModeAvgAggregateOutputType = {
    heartbeatInterval: number | null
    maxOfflineHours: number | null
  }

  export type OperationModeSumAggregateOutputType = {
    heartbeatInterval: number | null
    maxOfflineHours: number | null
  }

  export type OperationModeMinAggregateOutputType = {
    id: string | null
    terminalId: string | null
    currentMode: $Enums.OperationModeType | null
    lastModeChange: Date | null
    lastOnlineCheck: Date | null
    centralBaseURL: string | null
    syncEndpoint: string | null
    heartbeatInterval: number | null
    maxOfflineHours: number | null
    offlineSince: Date | null
  }

  export type OperationModeMaxAggregateOutputType = {
    id: string | null
    terminalId: string | null
    currentMode: $Enums.OperationModeType | null
    lastModeChange: Date | null
    lastOnlineCheck: Date | null
    centralBaseURL: string | null
    syncEndpoint: string | null
    heartbeatInterval: number | null
    maxOfflineHours: number | null
    offlineSince: Date | null
  }

  export type OperationModeCountAggregateOutputType = {
    id: number
    terminalId: number
    currentMode: number
    lastModeChange: number
    lastOnlineCheck: number
    centralBaseURL: number
    syncEndpoint: number
    heartbeatInterval: number
    maxOfflineHours: number
    offlineSince: number
    _all: number
  }


  export type OperationModeAvgAggregateInputType = {
    heartbeatInterval?: true
    maxOfflineHours?: true
  }

  export type OperationModeSumAggregateInputType = {
    heartbeatInterval?: true
    maxOfflineHours?: true
  }

  export type OperationModeMinAggregateInputType = {
    id?: true
    terminalId?: true
    currentMode?: true
    lastModeChange?: true
    lastOnlineCheck?: true
    centralBaseURL?: true
    syncEndpoint?: true
    heartbeatInterval?: true
    maxOfflineHours?: true
    offlineSince?: true
  }

  export type OperationModeMaxAggregateInputType = {
    id?: true
    terminalId?: true
    currentMode?: true
    lastModeChange?: true
    lastOnlineCheck?: true
    centralBaseURL?: true
    syncEndpoint?: true
    heartbeatInterval?: true
    maxOfflineHours?: true
    offlineSince?: true
  }

  export type OperationModeCountAggregateInputType = {
    id?: true
    terminalId?: true
    currentMode?: true
    lastModeChange?: true
    lastOnlineCheck?: true
    centralBaseURL?: true
    syncEndpoint?: true
    heartbeatInterval?: true
    maxOfflineHours?: true
    offlineSince?: true
    _all?: true
  }

  export type OperationModeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationMode to aggregate.
     */
    where?: OperationModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationModes to fetch.
     */
    orderBy?: OperationModeOrderByWithRelationInput | OperationModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperationModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperationModes
    **/
    _count?: true | OperationModeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OperationModeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OperationModeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperationModeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperationModeMaxAggregateInputType
  }

  export type GetOperationModeAggregateType<T extends OperationModeAggregateArgs> = {
        [P in keyof T & keyof AggregateOperationMode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperationMode[P]>
      : GetScalarType<T[P], AggregateOperationMode[P]>
  }




  export type OperationModeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperationModeWhereInput
    orderBy?: OperationModeOrderByWithAggregationInput | OperationModeOrderByWithAggregationInput[]
    by: OperationModeScalarFieldEnum[] | OperationModeScalarFieldEnum
    having?: OperationModeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperationModeCountAggregateInputType | true
    _avg?: OperationModeAvgAggregateInputType
    _sum?: OperationModeSumAggregateInputType
    _min?: OperationModeMinAggregateInputType
    _max?: OperationModeMaxAggregateInputType
  }

  export type OperationModeGroupByOutputType = {
    id: string
    terminalId: string
    currentMode: $Enums.OperationModeType
    lastModeChange: Date
    lastOnlineCheck: Date | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval: number
    maxOfflineHours: number
    offlineSince: Date | null
    _count: OperationModeCountAggregateOutputType | null
    _avg: OperationModeAvgAggregateOutputType | null
    _sum: OperationModeSumAggregateOutputType | null
    _min: OperationModeMinAggregateOutputType | null
    _max: OperationModeMaxAggregateOutputType | null
  }

  type GetOperationModeGroupByPayload<T extends OperationModeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperationModeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperationModeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperationModeGroupByOutputType[P]>
            : GetScalarType<T[P], OperationModeGroupByOutputType[P]>
        }
      >
    >


  export type OperationModeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    currentMode?: boolean
    lastModeChange?: boolean
    lastOnlineCheck?: boolean
    centralBaseURL?: boolean
    syncEndpoint?: boolean
    heartbeatInterval?: boolean
    maxOfflineHours?: boolean
    offlineSince?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMode"]>

  export type OperationModeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    currentMode?: boolean
    lastModeChange?: boolean
    lastOnlineCheck?: boolean
    centralBaseURL?: boolean
    syncEndpoint?: boolean
    heartbeatInterval?: boolean
    maxOfflineHours?: boolean
    offlineSince?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMode"]>

  export type OperationModeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    currentMode?: boolean
    lastModeChange?: boolean
    lastOnlineCheck?: boolean
    centralBaseURL?: boolean
    syncEndpoint?: boolean
    heartbeatInterval?: boolean
    maxOfflineHours?: boolean
    offlineSince?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operationMode"]>

  export type OperationModeSelectScalar = {
    id?: boolean
    terminalId?: boolean
    currentMode?: boolean
    lastModeChange?: boolean
    lastOnlineCheck?: boolean
    centralBaseURL?: boolean
    syncEndpoint?: boolean
    heartbeatInterval?: boolean
    maxOfflineHours?: boolean
    offlineSince?: boolean
  }

  export type OperationModeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalId" | "currentMode" | "lastModeChange" | "lastOnlineCheck" | "centralBaseURL" | "syncEndpoint" | "heartbeatInterval" | "maxOfflineHours" | "offlineSince", ExtArgs["result"]["operationMode"]>
  export type OperationModeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type OperationModeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type OperationModeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $OperationModePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperationMode"
    objects: {
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalId: string
      currentMode: $Enums.OperationModeType
      lastModeChange: Date
      lastOnlineCheck: Date | null
      centralBaseURL: string
      syncEndpoint: string
      heartbeatInterval: number
      maxOfflineHours: number
      offlineSince: Date | null
    }, ExtArgs["result"]["operationMode"]>
    composites: {}
  }

  type OperationModeGetPayload<S extends boolean | null | undefined | OperationModeDefaultArgs> = $Result.GetResult<Prisma.$OperationModePayload, S>

  type OperationModeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperationModeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperationModeCountAggregateInputType | true
    }

  export interface OperationModeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperationMode'], meta: { name: 'OperationMode' } }
    /**
     * Find zero or one OperationMode that matches the filter.
     * @param {OperationModeFindUniqueArgs} args - Arguments to find a OperationMode
     * @example
     * // Get one OperationMode
     * const operationMode = await prisma.operationMode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperationModeFindUniqueArgs>(args: SelectSubset<T, OperationModeFindUniqueArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperationMode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperationModeFindUniqueOrThrowArgs} args - Arguments to find a OperationMode
     * @example
     * // Get one OperationMode
     * const operationMode = await prisma.operationMode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperationModeFindUniqueOrThrowArgs>(args: SelectSubset<T, OperationModeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationMode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeFindFirstArgs} args - Arguments to find a OperationMode
     * @example
     * // Get one OperationMode
     * const operationMode = await prisma.operationMode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperationModeFindFirstArgs>(args?: SelectSubset<T, OperationModeFindFirstArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperationMode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeFindFirstOrThrowArgs} args - Arguments to find a OperationMode
     * @example
     * // Get one OperationMode
     * const operationMode = await prisma.operationMode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperationModeFindFirstOrThrowArgs>(args?: SelectSubset<T, OperationModeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperationModes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperationModes
     * const operationModes = await prisma.operationMode.findMany()
     * 
     * // Get first 10 OperationModes
     * const operationModes = await prisma.operationMode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operationModeWithIdOnly = await prisma.operationMode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperationModeFindManyArgs>(args?: SelectSubset<T, OperationModeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperationMode.
     * @param {OperationModeCreateArgs} args - Arguments to create a OperationMode.
     * @example
     * // Create one OperationMode
     * const OperationMode = await prisma.operationMode.create({
     *   data: {
     *     // ... data to create a OperationMode
     *   }
     * })
     * 
     */
    create<T extends OperationModeCreateArgs>(args: SelectSubset<T, OperationModeCreateArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperationModes.
     * @param {OperationModeCreateManyArgs} args - Arguments to create many OperationModes.
     * @example
     * // Create many OperationModes
     * const operationMode = await prisma.operationMode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperationModeCreateManyArgs>(args?: SelectSubset<T, OperationModeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperationModes and returns the data saved in the database.
     * @param {OperationModeCreateManyAndReturnArgs} args - Arguments to create many OperationModes.
     * @example
     * // Create many OperationModes
     * const operationMode = await prisma.operationMode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperationModes and only return the `id`
     * const operationModeWithIdOnly = await prisma.operationMode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperationModeCreateManyAndReturnArgs>(args?: SelectSubset<T, OperationModeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperationMode.
     * @param {OperationModeDeleteArgs} args - Arguments to delete one OperationMode.
     * @example
     * // Delete one OperationMode
     * const OperationMode = await prisma.operationMode.delete({
     *   where: {
     *     // ... filter to delete one OperationMode
     *   }
     * })
     * 
     */
    delete<T extends OperationModeDeleteArgs>(args: SelectSubset<T, OperationModeDeleteArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperationMode.
     * @param {OperationModeUpdateArgs} args - Arguments to update one OperationMode.
     * @example
     * // Update one OperationMode
     * const operationMode = await prisma.operationMode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperationModeUpdateArgs>(args: SelectSubset<T, OperationModeUpdateArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperationModes.
     * @param {OperationModeDeleteManyArgs} args - Arguments to filter OperationModes to delete.
     * @example
     * // Delete a few OperationModes
     * const { count } = await prisma.operationMode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperationModeDeleteManyArgs>(args?: SelectSubset<T, OperationModeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperationModes
     * const operationMode = await prisma.operationMode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperationModeUpdateManyArgs>(args: SelectSubset<T, OperationModeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperationModes and returns the data updated in the database.
     * @param {OperationModeUpdateManyAndReturnArgs} args - Arguments to update many OperationModes.
     * @example
     * // Update many OperationModes
     * const operationMode = await prisma.operationMode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperationModes and only return the `id`
     * const operationModeWithIdOnly = await prisma.operationMode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperationModeUpdateManyAndReturnArgs>(args: SelectSubset<T, OperationModeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperationMode.
     * @param {OperationModeUpsertArgs} args - Arguments to update or create a OperationMode.
     * @example
     * // Update or create a OperationMode
     * const operationMode = await prisma.operationMode.upsert({
     *   create: {
     *     // ... data to create a OperationMode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperationMode we want to update
     *   }
     * })
     */
    upsert<T extends OperationModeUpsertArgs>(args: SelectSubset<T, OperationModeUpsertArgs<ExtArgs>>): Prisma__OperationModeClient<$Result.GetResult<Prisma.$OperationModePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperationModes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeCountArgs} args - Arguments to filter OperationModes to count.
     * @example
     * // Count the number of OperationModes
     * const count = await prisma.operationMode.count({
     *   where: {
     *     // ... the filter for the OperationModes we want to count
     *   }
     * })
    **/
    count<T extends OperationModeCountArgs>(
      args?: Subset<T, OperationModeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperationModeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperationMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperationModeAggregateArgs>(args: Subset<T, OperationModeAggregateArgs>): Prisma.PrismaPromise<GetOperationModeAggregateType<T>>

    /**
     * Group by OperationMode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperationModeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperationModeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperationModeGroupByArgs['orderBy'] }
        : { orderBy?: OperationModeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperationModeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperationModeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperationMode model
   */
  readonly fields: OperationModeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperationMode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperationModeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperationMode model
   */
  interface OperationModeFieldRefs {
    readonly id: FieldRef<"OperationMode", 'String'>
    readonly terminalId: FieldRef<"OperationMode", 'String'>
    readonly currentMode: FieldRef<"OperationMode", 'OperationModeType'>
    readonly lastModeChange: FieldRef<"OperationMode", 'DateTime'>
    readonly lastOnlineCheck: FieldRef<"OperationMode", 'DateTime'>
    readonly centralBaseURL: FieldRef<"OperationMode", 'String'>
    readonly syncEndpoint: FieldRef<"OperationMode", 'String'>
    readonly heartbeatInterval: FieldRef<"OperationMode", 'Int'>
    readonly maxOfflineHours: FieldRef<"OperationMode", 'Int'>
    readonly offlineSince: FieldRef<"OperationMode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperationMode findUnique
   */
  export type OperationModeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter, which OperationMode to fetch.
     */
    where: OperationModeWhereUniqueInput
  }

  /**
   * OperationMode findUniqueOrThrow
   */
  export type OperationModeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter, which OperationMode to fetch.
     */
    where: OperationModeWhereUniqueInput
  }

  /**
   * OperationMode findFirst
   */
  export type OperationModeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter, which OperationMode to fetch.
     */
    where?: OperationModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationModes to fetch.
     */
    orderBy?: OperationModeOrderByWithRelationInput | OperationModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationModes.
     */
    cursor?: OperationModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationModes.
     */
    distinct?: OperationModeScalarFieldEnum | OperationModeScalarFieldEnum[]
  }

  /**
   * OperationMode findFirstOrThrow
   */
  export type OperationModeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter, which OperationMode to fetch.
     */
    where?: OperationModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationModes to fetch.
     */
    orderBy?: OperationModeOrderByWithRelationInput | OperationModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperationModes.
     */
    cursor?: OperationModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationModes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperationModes.
     */
    distinct?: OperationModeScalarFieldEnum | OperationModeScalarFieldEnum[]
  }

  /**
   * OperationMode findMany
   */
  export type OperationModeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter, which OperationModes to fetch.
     */
    where?: OperationModeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperationModes to fetch.
     */
    orderBy?: OperationModeOrderByWithRelationInput | OperationModeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperationModes.
     */
    cursor?: OperationModeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OperationModes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperationModes.
     */
    skip?: number
    distinct?: OperationModeScalarFieldEnum | OperationModeScalarFieldEnum[]
  }

  /**
   * OperationMode create
   */
  export type OperationModeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * The data needed to create a OperationMode.
     */
    data: XOR<OperationModeCreateInput, OperationModeUncheckedCreateInput>
  }

  /**
   * OperationMode createMany
   */
  export type OperationModeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperationModes.
     */
    data: OperationModeCreateManyInput | OperationModeCreateManyInput[]
  }

  /**
   * OperationMode createManyAndReturn
   */
  export type OperationModeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * The data used to create many OperationModes.
     */
    data: OperationModeCreateManyInput | OperationModeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationMode update
   */
  export type OperationModeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * The data needed to update a OperationMode.
     */
    data: XOR<OperationModeUpdateInput, OperationModeUncheckedUpdateInput>
    /**
     * Choose, which OperationMode to update.
     */
    where: OperationModeWhereUniqueInput
  }

  /**
   * OperationMode updateMany
   */
  export type OperationModeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperationModes.
     */
    data: XOR<OperationModeUpdateManyMutationInput, OperationModeUncheckedUpdateManyInput>
    /**
     * Filter which OperationModes to update
     */
    where?: OperationModeWhereInput
    /**
     * Limit how many OperationModes to update.
     */
    limit?: number
  }

  /**
   * OperationMode updateManyAndReturn
   */
  export type OperationModeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * The data used to update OperationModes.
     */
    data: XOR<OperationModeUpdateManyMutationInput, OperationModeUncheckedUpdateManyInput>
    /**
     * Filter which OperationModes to update
     */
    where?: OperationModeWhereInput
    /**
     * Limit how many OperationModes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperationMode upsert
   */
  export type OperationModeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * The filter to search for the OperationMode to update in case it exists.
     */
    where: OperationModeWhereUniqueInput
    /**
     * In case the OperationMode found by the `where` argument doesn't exist, create a new OperationMode with this data.
     */
    create: XOR<OperationModeCreateInput, OperationModeUncheckedCreateInput>
    /**
     * In case the OperationMode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperationModeUpdateInput, OperationModeUncheckedUpdateInput>
  }

  /**
   * OperationMode delete
   */
  export type OperationModeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
    /**
     * Filter which OperationMode to delete.
     */
    where: OperationModeWhereUniqueInput
  }

  /**
   * OperationMode deleteMany
   */
  export type OperationModeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperationModes to delete
     */
    where?: OperationModeWhereInput
    /**
     * Limit how many OperationModes to delete.
     */
    limit?: number
  }

  /**
   * OperationMode without action
   */
  export type OperationModeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperationMode
     */
    select?: OperationModeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperationMode
     */
    omit?: OperationModeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperationModeInclude<ExtArgs> | null
  }


  /**
   * Model ConnectionLog
   */

  export type AggregateConnectionLog = {
    _count: ConnectionLogCountAggregateOutputType | null
    _avg: ConnectionLogAvgAggregateOutputType | null
    _sum: ConnectionLogSumAggregateOutputType | null
    _min: ConnectionLogMinAggregateOutputType | null
    _max: ConnectionLogMaxAggregateOutputType | null
  }

  export type ConnectionLogAvgAggregateOutputType = {
    durationMs: number | null
  }

  export type ConnectionLogSumAggregateOutputType = {
    durationMs: number | null
  }

  export type ConnectionLogMinAggregateOutputType = {
    id: string | null
    terminalId: string | null
    mode: $Enums.OperationModeType | null
    timestamp: Date | null
    durationMs: number | null
    errorMessage: string | null
    success: boolean | null
  }

  export type ConnectionLogMaxAggregateOutputType = {
    id: string | null
    terminalId: string | null
    mode: $Enums.OperationModeType | null
    timestamp: Date | null
    durationMs: number | null
    errorMessage: string | null
    success: boolean | null
  }

  export type ConnectionLogCountAggregateOutputType = {
    id: number
    terminalId: number
    mode: number
    timestamp: number
    durationMs: number
    errorMessage: number
    success: number
    _all: number
  }


  export type ConnectionLogAvgAggregateInputType = {
    durationMs?: true
  }

  export type ConnectionLogSumAggregateInputType = {
    durationMs?: true
  }

  export type ConnectionLogMinAggregateInputType = {
    id?: true
    terminalId?: true
    mode?: true
    timestamp?: true
    durationMs?: true
    errorMessage?: true
    success?: true
  }

  export type ConnectionLogMaxAggregateInputType = {
    id?: true
    terminalId?: true
    mode?: true
    timestamp?: true
    durationMs?: true
    errorMessage?: true
    success?: true
  }

  export type ConnectionLogCountAggregateInputType = {
    id?: true
    terminalId?: true
    mode?: true
    timestamp?: true
    durationMs?: true
    errorMessage?: true
    success?: true
    _all?: true
  }

  export type ConnectionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionLog to aggregate.
     */
    where?: ConnectionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionLogs to fetch.
     */
    orderBy?: ConnectionLogOrderByWithRelationInput | ConnectionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConnectionLogs
    **/
    _count?: true | ConnectionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConnectionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConnectionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionLogMaxAggregateInputType
  }

  export type GetConnectionLogAggregateType<T extends ConnectionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateConnectionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnectionLog[P]>
      : GetScalarType<T[P], AggregateConnectionLog[P]>
  }




  export type ConnectionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionLogWhereInput
    orderBy?: ConnectionLogOrderByWithAggregationInput | ConnectionLogOrderByWithAggregationInput[]
    by: ConnectionLogScalarFieldEnum[] | ConnectionLogScalarFieldEnum
    having?: ConnectionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionLogCountAggregateInputType | true
    _avg?: ConnectionLogAvgAggregateInputType
    _sum?: ConnectionLogSumAggregateInputType
    _min?: ConnectionLogMinAggregateInputType
    _max?: ConnectionLogMaxAggregateInputType
  }

  export type ConnectionLogGroupByOutputType = {
    id: string
    terminalId: string
    mode: $Enums.OperationModeType
    timestamp: Date
    durationMs: number | null
    errorMessage: string | null
    success: boolean
    _count: ConnectionLogCountAggregateOutputType | null
    _avg: ConnectionLogAvgAggregateOutputType | null
    _sum: ConnectionLogSumAggregateOutputType | null
    _min: ConnectionLogMinAggregateOutputType | null
    _max: ConnectionLogMaxAggregateOutputType | null
  }

  type GetConnectionLogGroupByPayload<T extends ConnectionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionLogGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionLogGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    mode?: boolean
    timestamp?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    success?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionLog"]>

  export type ConnectionLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    mode?: boolean
    timestamp?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    success?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionLog"]>

  export type ConnectionLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    mode?: boolean
    timestamp?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    success?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connectionLog"]>

  export type ConnectionLogSelectScalar = {
    id?: boolean
    terminalId?: boolean
    mode?: boolean
    timestamp?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    success?: boolean
  }

  export type ConnectionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalId" | "mode" | "timestamp" | "durationMs" | "errorMessage" | "success", ExtArgs["result"]["connectionLog"]>
  export type ConnectionLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type ConnectionLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type ConnectionLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $ConnectionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConnectionLog"
    objects: {
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalId: string
      mode: $Enums.OperationModeType
      timestamp: Date
      durationMs: number | null
      errorMessage: string | null
      success: boolean
    }, ExtArgs["result"]["connectionLog"]>
    composites: {}
  }

  type ConnectionLogGetPayload<S extends boolean | null | undefined | ConnectionLogDefaultArgs> = $Result.GetResult<Prisma.$ConnectionLogPayload, S>

  type ConnectionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConnectionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConnectionLogCountAggregateInputType | true
    }

  export interface ConnectionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConnectionLog'], meta: { name: 'ConnectionLog' } }
    /**
     * Find zero or one ConnectionLog that matches the filter.
     * @param {ConnectionLogFindUniqueArgs} args - Arguments to find a ConnectionLog
     * @example
     * // Get one ConnectionLog
     * const connectionLog = await prisma.connectionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConnectionLogFindUniqueArgs>(args: SelectSubset<T, ConnectionLogFindUniqueArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConnectionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConnectionLogFindUniqueOrThrowArgs} args - Arguments to find a ConnectionLog
     * @example
     * // Get one ConnectionLog
     * const connectionLog = await prisma.connectionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConnectionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ConnectionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogFindFirstArgs} args - Arguments to find a ConnectionLog
     * @example
     * // Get one ConnectionLog
     * const connectionLog = await prisma.connectionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConnectionLogFindFirstArgs>(args?: SelectSubset<T, ConnectionLogFindFirstArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConnectionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogFindFirstOrThrowArgs} args - Arguments to find a ConnectionLog
     * @example
     * // Get one ConnectionLog
     * const connectionLog = await prisma.connectionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConnectionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ConnectionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConnectionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConnectionLogs
     * const connectionLogs = await prisma.connectionLog.findMany()
     * 
     * // Get first 10 ConnectionLogs
     * const connectionLogs = await prisma.connectionLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const connectionLogWithIdOnly = await prisma.connectionLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConnectionLogFindManyArgs>(args?: SelectSubset<T, ConnectionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConnectionLog.
     * @param {ConnectionLogCreateArgs} args - Arguments to create a ConnectionLog.
     * @example
     * // Create one ConnectionLog
     * const ConnectionLog = await prisma.connectionLog.create({
     *   data: {
     *     // ... data to create a ConnectionLog
     *   }
     * })
     * 
     */
    create<T extends ConnectionLogCreateArgs>(args: SelectSubset<T, ConnectionLogCreateArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConnectionLogs.
     * @param {ConnectionLogCreateManyArgs} args - Arguments to create many ConnectionLogs.
     * @example
     * // Create many ConnectionLogs
     * const connectionLog = await prisma.connectionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConnectionLogCreateManyArgs>(args?: SelectSubset<T, ConnectionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConnectionLogs and returns the data saved in the database.
     * @param {ConnectionLogCreateManyAndReturnArgs} args - Arguments to create many ConnectionLogs.
     * @example
     * // Create many ConnectionLogs
     * const connectionLog = await prisma.connectionLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConnectionLogs and only return the `id`
     * const connectionLogWithIdOnly = await prisma.connectionLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConnectionLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ConnectionLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConnectionLog.
     * @param {ConnectionLogDeleteArgs} args - Arguments to delete one ConnectionLog.
     * @example
     * // Delete one ConnectionLog
     * const ConnectionLog = await prisma.connectionLog.delete({
     *   where: {
     *     // ... filter to delete one ConnectionLog
     *   }
     * })
     * 
     */
    delete<T extends ConnectionLogDeleteArgs>(args: SelectSubset<T, ConnectionLogDeleteArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConnectionLog.
     * @param {ConnectionLogUpdateArgs} args - Arguments to update one ConnectionLog.
     * @example
     * // Update one ConnectionLog
     * const connectionLog = await prisma.connectionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConnectionLogUpdateArgs>(args: SelectSubset<T, ConnectionLogUpdateArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConnectionLogs.
     * @param {ConnectionLogDeleteManyArgs} args - Arguments to filter ConnectionLogs to delete.
     * @example
     * // Delete a few ConnectionLogs
     * const { count } = await prisma.connectionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConnectionLogDeleteManyArgs>(args?: SelectSubset<T, ConnectionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConnectionLogs
     * const connectionLog = await prisma.connectionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConnectionLogUpdateManyArgs>(args: SelectSubset<T, ConnectionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConnectionLogs and returns the data updated in the database.
     * @param {ConnectionLogUpdateManyAndReturnArgs} args - Arguments to update many ConnectionLogs.
     * @example
     * // Update many ConnectionLogs
     * const connectionLog = await prisma.connectionLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConnectionLogs and only return the `id`
     * const connectionLogWithIdOnly = await prisma.connectionLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConnectionLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ConnectionLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConnectionLog.
     * @param {ConnectionLogUpsertArgs} args - Arguments to update or create a ConnectionLog.
     * @example
     * // Update or create a ConnectionLog
     * const connectionLog = await prisma.connectionLog.upsert({
     *   create: {
     *     // ... data to create a ConnectionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConnectionLog we want to update
     *   }
     * })
     */
    upsert<T extends ConnectionLogUpsertArgs>(args: SelectSubset<T, ConnectionLogUpsertArgs<ExtArgs>>): Prisma__ConnectionLogClient<$Result.GetResult<Prisma.$ConnectionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConnectionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogCountArgs} args - Arguments to filter ConnectionLogs to count.
     * @example
     * // Count the number of ConnectionLogs
     * const count = await prisma.connectionLog.count({
     *   where: {
     *     // ... the filter for the ConnectionLogs we want to count
     *   }
     * })
    **/
    count<T extends ConnectionLogCountArgs>(
      args?: Subset<T, ConnectionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConnectionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionLogAggregateArgs>(args: Subset<T, ConnectionLogAggregateArgs>): Prisma.PrismaPromise<GetConnectionLogAggregateType<T>>

    /**
     * Group by ConnectionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionLogGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConnectionLog model
   */
  readonly fields: ConnectionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConnectionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConnectionLog model
   */
  interface ConnectionLogFieldRefs {
    readonly id: FieldRef<"ConnectionLog", 'String'>
    readonly terminalId: FieldRef<"ConnectionLog", 'String'>
    readonly mode: FieldRef<"ConnectionLog", 'OperationModeType'>
    readonly timestamp: FieldRef<"ConnectionLog", 'DateTime'>
    readonly durationMs: FieldRef<"ConnectionLog", 'Int'>
    readonly errorMessage: FieldRef<"ConnectionLog", 'String'>
    readonly success: FieldRef<"ConnectionLog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ConnectionLog findUnique
   */
  export type ConnectionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionLog to fetch.
     */
    where: ConnectionLogWhereUniqueInput
  }

  /**
   * ConnectionLog findUniqueOrThrow
   */
  export type ConnectionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionLog to fetch.
     */
    where: ConnectionLogWhereUniqueInput
  }

  /**
   * ConnectionLog findFirst
   */
  export type ConnectionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionLog to fetch.
     */
    where?: ConnectionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionLogs to fetch.
     */
    orderBy?: ConnectionLogOrderByWithRelationInput | ConnectionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionLogs.
     */
    cursor?: ConnectionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionLogs.
     */
    distinct?: ConnectionLogScalarFieldEnum | ConnectionLogScalarFieldEnum[]
  }

  /**
   * ConnectionLog findFirstOrThrow
   */
  export type ConnectionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionLog to fetch.
     */
    where?: ConnectionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionLogs to fetch.
     */
    orderBy?: ConnectionLogOrderByWithRelationInput | ConnectionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConnectionLogs.
     */
    cursor?: ConnectionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConnectionLogs.
     */
    distinct?: ConnectionLogScalarFieldEnum | ConnectionLogScalarFieldEnum[]
  }

  /**
   * ConnectionLog findMany
   */
  export type ConnectionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter, which ConnectionLogs to fetch.
     */
    where?: ConnectionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConnectionLogs to fetch.
     */
    orderBy?: ConnectionLogOrderByWithRelationInput | ConnectionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConnectionLogs.
     */
    cursor?: ConnectionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConnectionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConnectionLogs.
     */
    skip?: number
    distinct?: ConnectionLogScalarFieldEnum | ConnectionLogScalarFieldEnum[]
  }

  /**
   * ConnectionLog create
   */
  export type ConnectionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ConnectionLog.
     */
    data: XOR<ConnectionLogCreateInput, ConnectionLogUncheckedCreateInput>
  }

  /**
   * ConnectionLog createMany
   */
  export type ConnectionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConnectionLogs.
     */
    data: ConnectionLogCreateManyInput | ConnectionLogCreateManyInput[]
  }

  /**
   * ConnectionLog createManyAndReturn
   */
  export type ConnectionLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * The data used to create many ConnectionLogs.
     */
    data: ConnectionLogCreateManyInput | ConnectionLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectionLog update
   */
  export type ConnectionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ConnectionLog.
     */
    data: XOR<ConnectionLogUpdateInput, ConnectionLogUncheckedUpdateInput>
    /**
     * Choose, which ConnectionLog to update.
     */
    where: ConnectionLogWhereUniqueInput
  }

  /**
   * ConnectionLog updateMany
   */
  export type ConnectionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConnectionLogs.
     */
    data: XOR<ConnectionLogUpdateManyMutationInput, ConnectionLogUncheckedUpdateManyInput>
    /**
     * Filter which ConnectionLogs to update
     */
    where?: ConnectionLogWhereInput
    /**
     * Limit how many ConnectionLogs to update.
     */
    limit?: number
  }

  /**
   * ConnectionLog updateManyAndReturn
   */
  export type ConnectionLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * The data used to update ConnectionLogs.
     */
    data: XOR<ConnectionLogUpdateManyMutationInput, ConnectionLogUncheckedUpdateManyInput>
    /**
     * Filter which ConnectionLogs to update
     */
    where?: ConnectionLogWhereInput
    /**
     * Limit how many ConnectionLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConnectionLog upsert
   */
  export type ConnectionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ConnectionLog to update in case it exists.
     */
    where: ConnectionLogWhereUniqueInput
    /**
     * In case the ConnectionLog found by the `where` argument doesn't exist, create a new ConnectionLog with this data.
     */
    create: XOR<ConnectionLogCreateInput, ConnectionLogUncheckedCreateInput>
    /**
     * In case the ConnectionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionLogUpdateInput, ConnectionLogUncheckedUpdateInput>
  }

  /**
   * ConnectionLog delete
   */
  export type ConnectionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
    /**
     * Filter which ConnectionLog to delete.
     */
    where: ConnectionLogWhereUniqueInput
  }

  /**
   * ConnectionLog deleteMany
   */
  export type ConnectionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConnectionLogs to delete
     */
    where?: ConnectionLogWhereInput
    /**
     * Limit how many ConnectionLogs to delete.
     */
    limit?: number
  }

  /**
   * ConnectionLog without action
   */
  export type ConnectionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConnectionLog
     */
    select?: ConnectionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConnectionLog
     */
    omit?: ConnectionLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConnectionLogInclude<ExtArgs> | null
  }


  /**
   * Model LocalUser
   */

  export type AggregateLocalUser = {
    _count: LocalUserCountAggregateOutputType | null
    _avg: LocalUserAvgAggregateOutputType | null
    _sum: LocalUserSumAggregateOutputType | null
    _min: LocalUserMinAggregateOutputType | null
    _max: LocalUserMaxAggregateOutputType | null
  }

  export type LocalUserAvgAggregateOutputType = {
    loginAttempts: number | null
  }

  export type LocalUserSumAggregateOutputType = {
    loginAttempts: number | null
  }

  export type LocalUserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    pinCode: string | null
    role: $Enums.UserRole | null
    centralUserId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalUserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    pinCode: string | null
    role: $Enums.UserRole | null
    centralUserId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    lockedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalUserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    passwordHash: number
    firstName: number
    lastName: number
    pinCode: number
    role: number
    permissions: number
    centralUserId: number
    isActive: number
    lastLoginAt: number
    loginAttempts: number
    lockedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalUserAvgAggregateInputType = {
    loginAttempts?: true
  }

  export type LocalUserSumAggregateInputType = {
    loginAttempts?: true
  }

  export type LocalUserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    pinCode?: true
    role?: true
    centralUserId?: true
    isActive?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalUserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    pinCode?: true
    role?: true
    centralUserId?: true
    isActive?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalUserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    pinCode?: true
    role?: true
    permissions?: true
    centralUserId?: true
    isActive?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalUser to aggregate.
     */
    where?: LocalUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalUsers to fetch.
     */
    orderBy?: LocalUserOrderByWithRelationInput | LocalUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalUsers
    **/
    _count?: true | LocalUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocalUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocalUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalUserMaxAggregateInputType
  }

  export type GetLocalUserAggregateType<T extends LocalUserAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalUser[P]>
      : GetScalarType<T[P], AggregateLocalUser[P]>
  }




  export type LocalUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalUserWhereInput
    orderBy?: LocalUserOrderByWithAggregationInput | LocalUserOrderByWithAggregationInput[]
    by: LocalUserScalarFieldEnum[] | LocalUserScalarFieldEnum
    having?: LocalUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalUserCountAggregateInputType | true
    _avg?: LocalUserAvgAggregateInputType
    _sum?: LocalUserSumAggregateInputType
    _min?: LocalUserMinAggregateInputType
    _max?: LocalUserMaxAggregateInputType
  }

  export type LocalUserGroupByOutputType = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode: string | null
    role: $Enums.UserRole
    permissions: JsonValue
    centralUserId: string | null
    isActive: boolean
    lastLoginAt: Date | null
    loginAttempts: number
    lockedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LocalUserCountAggregateOutputType | null
    _avg: LocalUserAvgAggregateOutputType | null
    _sum: LocalUserSumAggregateOutputType | null
    _min: LocalUserMinAggregateOutputType | null
    _max: LocalUserMaxAggregateOutputType | null
  }

  type GetLocalUserGroupByPayload<T extends LocalUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalUserGroupByOutputType[P]>
            : GetScalarType<T[P], LocalUserGroupByOutputType[P]>
        }
      >
    >


  export type LocalUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    pinCode?: boolean
    role?: boolean
    permissions?: boolean
    centralUserId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shifts?: boolean | LocalUser$shiftsArgs<ExtArgs>
    saleOrders?: boolean | LocalUser$saleOrdersArgs<ExtArgs>
    sessions?: boolean | LocalUser$sessionsArgs<ExtArgs>
    _count?: boolean | LocalUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["localUser"]>

  export type LocalUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    pinCode?: boolean
    role?: boolean
    permissions?: boolean
    centralUserId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localUser"]>

  export type LocalUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    pinCode?: boolean
    role?: boolean
    permissions?: boolean
    centralUserId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localUser"]>

  export type LocalUserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    pinCode?: boolean
    role?: boolean
    permissions?: boolean
    centralUserId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocalUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "passwordHash" | "firstName" | "lastName" | "pinCode" | "role" | "permissions" | "centralUserId" | "isActive" | "lastLoginAt" | "loginAttempts" | "lockedUntil" | "createdAt" | "updatedAt", ExtArgs["result"]["localUser"]>
  export type LocalUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | LocalUser$shiftsArgs<ExtArgs>
    saleOrders?: boolean | LocalUser$saleOrdersArgs<ExtArgs>
    sessions?: boolean | LocalUser$sessionsArgs<ExtArgs>
    _count?: boolean | LocalUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocalUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocalUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocalUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalUser"
    objects: {
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      saleOrders: Prisma.$SaleOrderPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      passwordHash: string
      firstName: string
      lastName: string
      pinCode: string | null
      role: $Enums.UserRole
      permissions: Prisma.JsonValue
      centralUserId: string | null
      isActive: boolean
      lastLoginAt: Date | null
      loginAttempts: number
      lockedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["localUser"]>
    composites: {}
  }

  type LocalUserGetPayload<S extends boolean | null | undefined | LocalUserDefaultArgs> = $Result.GetResult<Prisma.$LocalUserPayload, S>

  type LocalUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalUserCountAggregateInputType | true
    }

  export interface LocalUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalUser'], meta: { name: 'LocalUser' } }
    /**
     * Find zero or one LocalUser that matches the filter.
     * @param {LocalUserFindUniqueArgs} args - Arguments to find a LocalUser
     * @example
     * // Get one LocalUser
     * const localUser = await prisma.localUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalUserFindUniqueArgs>(args: SelectSubset<T, LocalUserFindUniqueArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalUserFindUniqueOrThrowArgs} args - Arguments to find a LocalUser
     * @example
     * // Get one LocalUser
     * const localUser = await prisma.localUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalUserFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserFindFirstArgs} args - Arguments to find a LocalUser
     * @example
     * // Get one LocalUser
     * const localUser = await prisma.localUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalUserFindFirstArgs>(args?: SelectSubset<T, LocalUserFindFirstArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserFindFirstOrThrowArgs} args - Arguments to find a LocalUser
     * @example
     * // Get one LocalUser
     * const localUser = await prisma.localUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalUserFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalUsers
     * const localUsers = await prisma.localUser.findMany()
     * 
     * // Get first 10 LocalUsers
     * const localUsers = await prisma.localUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localUserWithIdOnly = await prisma.localUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalUserFindManyArgs>(args?: SelectSubset<T, LocalUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalUser.
     * @param {LocalUserCreateArgs} args - Arguments to create a LocalUser.
     * @example
     * // Create one LocalUser
     * const LocalUser = await prisma.localUser.create({
     *   data: {
     *     // ... data to create a LocalUser
     *   }
     * })
     * 
     */
    create<T extends LocalUserCreateArgs>(args: SelectSubset<T, LocalUserCreateArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalUsers.
     * @param {LocalUserCreateManyArgs} args - Arguments to create many LocalUsers.
     * @example
     * // Create many LocalUsers
     * const localUser = await prisma.localUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalUserCreateManyArgs>(args?: SelectSubset<T, LocalUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalUsers and returns the data saved in the database.
     * @param {LocalUserCreateManyAndReturnArgs} args - Arguments to create many LocalUsers.
     * @example
     * // Create many LocalUsers
     * const localUser = await prisma.localUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalUsers and only return the `id`
     * const localUserWithIdOnly = await prisma.localUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalUserCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocalUser.
     * @param {LocalUserDeleteArgs} args - Arguments to delete one LocalUser.
     * @example
     * // Delete one LocalUser
     * const LocalUser = await prisma.localUser.delete({
     *   where: {
     *     // ... filter to delete one LocalUser
     *   }
     * })
     * 
     */
    delete<T extends LocalUserDeleteArgs>(args: SelectSubset<T, LocalUserDeleteArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalUser.
     * @param {LocalUserUpdateArgs} args - Arguments to update one LocalUser.
     * @example
     * // Update one LocalUser
     * const localUser = await prisma.localUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalUserUpdateArgs>(args: SelectSubset<T, LocalUserUpdateArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalUsers.
     * @param {LocalUserDeleteManyArgs} args - Arguments to filter LocalUsers to delete.
     * @example
     * // Delete a few LocalUsers
     * const { count } = await prisma.localUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalUserDeleteManyArgs>(args?: SelectSubset<T, LocalUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalUsers
     * const localUser = await prisma.localUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalUserUpdateManyArgs>(args: SelectSubset<T, LocalUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalUsers and returns the data updated in the database.
     * @param {LocalUserUpdateManyAndReturnArgs} args - Arguments to update many LocalUsers.
     * @example
     * // Update many LocalUsers
     * const localUser = await prisma.localUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocalUsers and only return the `id`
     * const localUserWithIdOnly = await prisma.localUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocalUserUpdateManyAndReturnArgs>(args: SelectSubset<T, LocalUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocalUser.
     * @param {LocalUserUpsertArgs} args - Arguments to update or create a LocalUser.
     * @example
     * // Update or create a LocalUser
     * const localUser = await prisma.localUser.upsert({
     *   create: {
     *     // ... data to create a LocalUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalUser we want to update
     *   }
     * })
     */
    upsert<T extends LocalUserUpsertArgs>(args: SelectSubset<T, LocalUserUpsertArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocalUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserCountArgs} args - Arguments to filter LocalUsers to count.
     * @example
     * // Count the number of LocalUsers
     * const count = await prisma.localUser.count({
     *   where: {
     *     // ... the filter for the LocalUsers we want to count
     *   }
     * })
    **/
    count<T extends LocalUserCountArgs>(
      args?: Subset<T, LocalUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalUserAggregateArgs>(args: Subset<T, LocalUserAggregateArgs>): Prisma.PrismaPromise<GetLocalUserAggregateType<T>>

    /**
     * Group by LocalUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalUserGroupByArgs['orderBy'] }
        : { orderBy?: LocalUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalUser model
   */
  readonly fields: LocalUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shifts<T extends LocalUser$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, LocalUser$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleOrders<T extends LocalUser$saleOrdersArgs<ExtArgs> = {}>(args?: Subset<T, LocalUser$saleOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends LocalUser$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, LocalUser$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalUser model
   */
  interface LocalUserFieldRefs {
    readonly id: FieldRef<"LocalUser", 'String'>
    readonly username: FieldRef<"LocalUser", 'String'>
    readonly email: FieldRef<"LocalUser", 'String'>
    readonly passwordHash: FieldRef<"LocalUser", 'String'>
    readonly firstName: FieldRef<"LocalUser", 'String'>
    readonly lastName: FieldRef<"LocalUser", 'String'>
    readonly pinCode: FieldRef<"LocalUser", 'String'>
    readonly role: FieldRef<"LocalUser", 'UserRole'>
    readonly permissions: FieldRef<"LocalUser", 'Json'>
    readonly centralUserId: FieldRef<"LocalUser", 'String'>
    readonly isActive: FieldRef<"LocalUser", 'Boolean'>
    readonly lastLoginAt: FieldRef<"LocalUser", 'DateTime'>
    readonly loginAttempts: FieldRef<"LocalUser", 'Int'>
    readonly lockedUntil: FieldRef<"LocalUser", 'DateTime'>
    readonly createdAt: FieldRef<"LocalUser", 'DateTime'>
    readonly updatedAt: FieldRef<"LocalUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalUser findUnique
   */
  export type LocalUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter, which LocalUser to fetch.
     */
    where: LocalUserWhereUniqueInput
  }

  /**
   * LocalUser findUniqueOrThrow
   */
  export type LocalUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter, which LocalUser to fetch.
     */
    where: LocalUserWhereUniqueInput
  }

  /**
   * LocalUser findFirst
   */
  export type LocalUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter, which LocalUser to fetch.
     */
    where?: LocalUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalUsers to fetch.
     */
    orderBy?: LocalUserOrderByWithRelationInput | LocalUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalUsers.
     */
    cursor?: LocalUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalUsers.
     */
    distinct?: LocalUserScalarFieldEnum | LocalUserScalarFieldEnum[]
  }

  /**
   * LocalUser findFirstOrThrow
   */
  export type LocalUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter, which LocalUser to fetch.
     */
    where?: LocalUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalUsers to fetch.
     */
    orderBy?: LocalUserOrderByWithRelationInput | LocalUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalUsers.
     */
    cursor?: LocalUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalUsers.
     */
    distinct?: LocalUserScalarFieldEnum | LocalUserScalarFieldEnum[]
  }

  /**
   * LocalUser findMany
   */
  export type LocalUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter, which LocalUsers to fetch.
     */
    where?: LocalUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalUsers to fetch.
     */
    orderBy?: LocalUserOrderByWithRelationInput | LocalUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalUsers.
     */
    cursor?: LocalUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalUsers.
     */
    skip?: number
    distinct?: LocalUserScalarFieldEnum | LocalUserScalarFieldEnum[]
  }

  /**
   * LocalUser create
   */
  export type LocalUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * The data needed to create a LocalUser.
     */
    data: XOR<LocalUserCreateInput, LocalUserUncheckedCreateInput>
  }

  /**
   * LocalUser createMany
   */
  export type LocalUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalUsers.
     */
    data: LocalUserCreateManyInput | LocalUserCreateManyInput[]
  }

  /**
   * LocalUser createManyAndReturn
   */
  export type LocalUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * The data used to create many LocalUsers.
     */
    data: LocalUserCreateManyInput | LocalUserCreateManyInput[]
  }

  /**
   * LocalUser update
   */
  export type LocalUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * The data needed to update a LocalUser.
     */
    data: XOR<LocalUserUpdateInput, LocalUserUncheckedUpdateInput>
    /**
     * Choose, which LocalUser to update.
     */
    where: LocalUserWhereUniqueInput
  }

  /**
   * LocalUser updateMany
   */
  export type LocalUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalUsers.
     */
    data: XOR<LocalUserUpdateManyMutationInput, LocalUserUncheckedUpdateManyInput>
    /**
     * Filter which LocalUsers to update
     */
    where?: LocalUserWhereInput
    /**
     * Limit how many LocalUsers to update.
     */
    limit?: number
  }

  /**
   * LocalUser updateManyAndReturn
   */
  export type LocalUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * The data used to update LocalUsers.
     */
    data: XOR<LocalUserUpdateManyMutationInput, LocalUserUncheckedUpdateManyInput>
    /**
     * Filter which LocalUsers to update
     */
    where?: LocalUserWhereInput
    /**
     * Limit how many LocalUsers to update.
     */
    limit?: number
  }

  /**
   * LocalUser upsert
   */
  export type LocalUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * The filter to search for the LocalUser to update in case it exists.
     */
    where: LocalUserWhereUniqueInput
    /**
     * In case the LocalUser found by the `where` argument doesn't exist, create a new LocalUser with this data.
     */
    create: XOR<LocalUserCreateInput, LocalUserUncheckedCreateInput>
    /**
     * In case the LocalUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalUserUpdateInput, LocalUserUncheckedUpdateInput>
  }

  /**
   * LocalUser delete
   */
  export type LocalUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    /**
     * Filter which LocalUser to delete.
     */
    where: LocalUserWhereUniqueInput
  }

  /**
   * LocalUser deleteMany
   */
  export type LocalUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalUsers to delete
     */
    where?: LocalUserWhereInput
    /**
     * Limit how many LocalUsers to delete.
     */
    limit?: number
  }

  /**
   * LocalUser.shifts
   */
  export type LocalUser$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * LocalUser.saleOrders
   */
  export type LocalUser$saleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    cursor?: SaleOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * LocalUser.sessions
   */
  export type LocalUser$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * LocalUser without action
   */
  export type LocalUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    terminalId: string | null
    sessionToken: string | null
    startedAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    isActive: boolean | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    terminalId: string | null
    sessionToken: string | null
    startedAt: Date | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    isActive: boolean | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    terminalId: number
    sessionToken: number
    startedAt: number
    expiresAt: number
    lastActivityAt: number
    isActive: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    terminalId?: true
    sessionToken?: true
    startedAt?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    terminalId: string
    sessionToken: string
    startedAt: Date
    expiresAt: Date
    lastActivityAt: Date
    isActive: boolean
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    terminalId?: boolean
    sessionToken?: boolean
    startedAt?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "terminalId" | "sessionToken" | "startedAt" | "expiresAt" | "lastActivityAt" | "isActive", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$LocalUserPayload<ExtArgs>
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      terminalId: string
      sessionToken: string
      startedAt: Date
      expiresAt: Date
      lastActivityAt: Date
      isActive: boolean
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LocalUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalUserDefaultArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly terminalId: FieldRef<"UserSession", 'String'>
    readonly sessionToken: FieldRef<"UserSession", 'String'>
    readonly startedAt: FieldRef<"UserSession", 'DateTime'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly lastActivityAt: FieldRef<"UserSession", 'DateTime'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model Outbox
   */

  export type AggregateOutbox = {
    _count: OutboxCountAggregateOutputType | null
    _avg: OutboxAvgAggregateOutputType | null
    _sum: OutboxSumAggregateOutputType | null
    _min: OutboxMinAggregateOutputType | null
    _max: OutboxMaxAggregateOutputType | null
  }

  export type OutboxAvgAggregateOutputType = {
    syncPriority: number | null
    attemptCount: number | null
    maxAttempts: number | null
    syncVersion: number | null
  }

  export type OutboxSumAggregateOutputType = {
    syncPriority: number | null
    attemptCount: number | null
    maxAttempts: number | null
    syncVersion: number | null
  }

  export type OutboxMinAggregateOutputType = {
    id: string | null
    terminalId: string | null
    entityType: string | null
    entityId: string | null
    operation: $Enums.SyncOperation | null
    createdInMode: $Enums.OperationModeType | null
    shiftId: string | null
    userId: string | null
    syncPriority: number | null
    attemptCount: number | null
    maxAttempts: number | null
    lastAttemptAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    localTimestamp: Date | null
    syncVersion: number | null
  }

  export type OutboxMaxAggregateOutputType = {
    id: string | null
    terminalId: string | null
    entityType: string | null
    entityId: string | null
    operation: $Enums.SyncOperation | null
    createdInMode: $Enums.OperationModeType | null
    shiftId: string | null
    userId: string | null
    syncPriority: number | null
    attemptCount: number | null
    maxAttempts: number | null
    lastAttemptAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    localTimestamp: Date | null
    syncVersion: number | null
  }

  export type OutboxCountAggregateOutputType = {
    id: number
    terminalId: number
    entityType: number
    entityId: number
    operation: number
    data: number
    createdInMode: number
    shiftId: number
    userId: number
    syncPriority: number
    attemptCount: number
    maxAttempts: number
    lastAttemptAt: number
    errorMessage: number
    createdAt: number
    localTimestamp: number
    syncVersion: number
    _all: number
  }


  export type OutboxAvgAggregateInputType = {
    syncPriority?: true
    attemptCount?: true
    maxAttempts?: true
    syncVersion?: true
  }

  export type OutboxSumAggregateInputType = {
    syncPriority?: true
    attemptCount?: true
    maxAttempts?: true
    syncVersion?: true
  }

  export type OutboxMinAggregateInputType = {
    id?: true
    terminalId?: true
    entityType?: true
    entityId?: true
    operation?: true
    createdInMode?: true
    shiftId?: true
    userId?: true
    syncPriority?: true
    attemptCount?: true
    maxAttempts?: true
    lastAttemptAt?: true
    errorMessage?: true
    createdAt?: true
    localTimestamp?: true
    syncVersion?: true
  }

  export type OutboxMaxAggregateInputType = {
    id?: true
    terminalId?: true
    entityType?: true
    entityId?: true
    operation?: true
    createdInMode?: true
    shiftId?: true
    userId?: true
    syncPriority?: true
    attemptCount?: true
    maxAttempts?: true
    lastAttemptAt?: true
    errorMessage?: true
    createdAt?: true
    localTimestamp?: true
    syncVersion?: true
  }

  export type OutboxCountAggregateInputType = {
    id?: true
    terminalId?: true
    entityType?: true
    entityId?: true
    operation?: true
    data?: true
    createdInMode?: true
    shiftId?: true
    userId?: true
    syncPriority?: true
    attemptCount?: true
    maxAttempts?: true
    lastAttemptAt?: true
    errorMessage?: true
    createdAt?: true
    localTimestamp?: true
    syncVersion?: true
    _all?: true
  }

  export type OutboxAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outbox to aggregate.
     */
    where?: OutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outboxes to fetch.
     */
    orderBy?: OutboxOrderByWithRelationInput | OutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Outboxes
    **/
    _count?: true | OutboxCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OutboxAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OutboxSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutboxMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutboxMaxAggregateInputType
  }

  export type GetOutboxAggregateType<T extends OutboxAggregateArgs> = {
        [P in keyof T & keyof AggregateOutbox]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutbox[P]>
      : GetScalarType<T[P], AggregateOutbox[P]>
  }




  export type OutboxGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OutboxWhereInput
    orderBy?: OutboxOrderByWithAggregationInput | OutboxOrderByWithAggregationInput[]
    by: OutboxScalarFieldEnum[] | OutboxScalarFieldEnum
    having?: OutboxScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutboxCountAggregateInputType | true
    _avg?: OutboxAvgAggregateInputType
    _sum?: OutboxSumAggregateInputType
    _min?: OutboxMinAggregateInputType
    _max?: OutboxMaxAggregateInputType
  }

  export type OutboxGroupByOutputType = {
    id: string
    terminalId: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonValue
    createdInMode: $Enums.OperationModeType
    shiftId: string | null
    userId: string | null
    syncPriority: number
    attemptCount: number
    maxAttempts: number
    lastAttemptAt: Date | null
    errorMessage: string | null
    createdAt: Date
    localTimestamp: Date
    syncVersion: number
    _count: OutboxCountAggregateOutputType | null
    _avg: OutboxAvgAggregateOutputType | null
    _sum: OutboxSumAggregateOutputType | null
    _min: OutboxMinAggregateOutputType | null
    _max: OutboxMaxAggregateOutputType | null
  }

  type GetOutboxGroupByPayload<T extends OutboxGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OutboxGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutboxGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutboxGroupByOutputType[P]>
            : GetScalarType<T[P], OutboxGroupByOutputType[P]>
        }
      >
    >


  export type OutboxSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    data?: boolean
    createdInMode?: boolean
    shiftId?: boolean
    userId?: boolean
    syncPriority?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    lastAttemptAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    localTimestamp?: boolean
    syncVersion?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outbox"]>

  export type OutboxSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    data?: boolean
    createdInMode?: boolean
    shiftId?: boolean
    userId?: boolean
    syncPriority?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    lastAttemptAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    localTimestamp?: boolean
    syncVersion?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outbox"]>

  export type OutboxSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    data?: boolean
    createdInMode?: boolean
    shiftId?: boolean
    userId?: boolean
    syncPriority?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    lastAttemptAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    localTimestamp?: boolean
    syncVersion?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["outbox"]>

  export type OutboxSelectScalar = {
    id?: boolean
    terminalId?: boolean
    entityType?: boolean
    entityId?: boolean
    operation?: boolean
    data?: boolean
    createdInMode?: boolean
    shiftId?: boolean
    userId?: boolean
    syncPriority?: boolean
    attemptCount?: boolean
    maxAttempts?: boolean
    lastAttemptAt?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    localTimestamp?: boolean
    syncVersion?: boolean
  }

  export type OutboxOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalId" | "entityType" | "entityId" | "operation" | "data" | "createdInMode" | "shiftId" | "userId" | "syncPriority" | "attemptCount" | "maxAttempts" | "lastAttemptAt" | "errorMessage" | "createdAt" | "localTimestamp" | "syncVersion", ExtArgs["result"]["outbox"]>
  export type OutboxInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type OutboxIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type OutboxIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $OutboxPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Outbox"
    objects: {
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalId: string
      entityType: string
      entityId: string
      operation: $Enums.SyncOperation
      data: Prisma.JsonValue
      createdInMode: $Enums.OperationModeType
      shiftId: string | null
      userId: string | null
      syncPriority: number
      attemptCount: number
      maxAttempts: number
      lastAttemptAt: Date | null
      errorMessage: string | null
      createdAt: Date
      localTimestamp: Date
      syncVersion: number
    }, ExtArgs["result"]["outbox"]>
    composites: {}
  }

  type OutboxGetPayload<S extends boolean | null | undefined | OutboxDefaultArgs> = $Result.GetResult<Prisma.$OutboxPayload, S>

  type OutboxCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OutboxFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OutboxCountAggregateInputType | true
    }

  export interface OutboxDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Outbox'], meta: { name: 'Outbox' } }
    /**
     * Find zero or one Outbox that matches the filter.
     * @param {OutboxFindUniqueArgs} args - Arguments to find a Outbox
     * @example
     * // Get one Outbox
     * const outbox = await prisma.outbox.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OutboxFindUniqueArgs>(args: SelectSubset<T, OutboxFindUniqueArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Outbox that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OutboxFindUniqueOrThrowArgs} args - Arguments to find a Outbox
     * @example
     * // Get one Outbox
     * const outbox = await prisma.outbox.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OutboxFindUniqueOrThrowArgs>(args: SelectSubset<T, OutboxFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outbox that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxFindFirstArgs} args - Arguments to find a Outbox
     * @example
     * // Get one Outbox
     * const outbox = await prisma.outbox.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OutboxFindFirstArgs>(args?: SelectSubset<T, OutboxFindFirstArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Outbox that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxFindFirstOrThrowArgs} args - Arguments to find a Outbox
     * @example
     * // Get one Outbox
     * const outbox = await prisma.outbox.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OutboxFindFirstOrThrowArgs>(args?: SelectSubset<T, OutboxFindFirstOrThrowArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Outboxes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outboxes
     * const outboxes = await prisma.outbox.findMany()
     * 
     * // Get first 10 Outboxes
     * const outboxes = await prisma.outbox.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outboxWithIdOnly = await prisma.outbox.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OutboxFindManyArgs>(args?: SelectSubset<T, OutboxFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Outbox.
     * @param {OutboxCreateArgs} args - Arguments to create a Outbox.
     * @example
     * // Create one Outbox
     * const Outbox = await prisma.outbox.create({
     *   data: {
     *     // ... data to create a Outbox
     *   }
     * })
     * 
     */
    create<T extends OutboxCreateArgs>(args: SelectSubset<T, OutboxCreateArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Outboxes.
     * @param {OutboxCreateManyArgs} args - Arguments to create many Outboxes.
     * @example
     * // Create many Outboxes
     * const outbox = await prisma.outbox.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OutboxCreateManyArgs>(args?: SelectSubset<T, OutboxCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Outboxes and returns the data saved in the database.
     * @param {OutboxCreateManyAndReturnArgs} args - Arguments to create many Outboxes.
     * @example
     * // Create many Outboxes
     * const outbox = await prisma.outbox.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Outboxes and only return the `id`
     * const outboxWithIdOnly = await prisma.outbox.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OutboxCreateManyAndReturnArgs>(args?: SelectSubset<T, OutboxCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Outbox.
     * @param {OutboxDeleteArgs} args - Arguments to delete one Outbox.
     * @example
     * // Delete one Outbox
     * const Outbox = await prisma.outbox.delete({
     *   where: {
     *     // ... filter to delete one Outbox
     *   }
     * })
     * 
     */
    delete<T extends OutboxDeleteArgs>(args: SelectSubset<T, OutboxDeleteArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Outbox.
     * @param {OutboxUpdateArgs} args - Arguments to update one Outbox.
     * @example
     * // Update one Outbox
     * const outbox = await prisma.outbox.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OutboxUpdateArgs>(args: SelectSubset<T, OutboxUpdateArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Outboxes.
     * @param {OutboxDeleteManyArgs} args - Arguments to filter Outboxes to delete.
     * @example
     * // Delete a few Outboxes
     * const { count } = await prisma.outbox.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OutboxDeleteManyArgs>(args?: SelectSubset<T, OutboxDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outboxes
     * const outbox = await prisma.outbox.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OutboxUpdateManyArgs>(args: SelectSubset<T, OutboxUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outboxes and returns the data updated in the database.
     * @param {OutboxUpdateManyAndReturnArgs} args - Arguments to update many Outboxes.
     * @example
     * // Update many Outboxes
     * const outbox = await prisma.outbox.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Outboxes and only return the `id`
     * const outboxWithIdOnly = await prisma.outbox.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OutboxUpdateManyAndReturnArgs>(args: SelectSubset<T, OutboxUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Outbox.
     * @param {OutboxUpsertArgs} args - Arguments to update or create a Outbox.
     * @example
     * // Update or create a Outbox
     * const outbox = await prisma.outbox.upsert({
     *   create: {
     *     // ... data to create a Outbox
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Outbox we want to update
     *   }
     * })
     */
    upsert<T extends OutboxUpsertArgs>(args: SelectSubset<T, OutboxUpsertArgs<ExtArgs>>): Prisma__OutboxClient<$Result.GetResult<Prisma.$OutboxPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Outboxes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxCountArgs} args - Arguments to filter Outboxes to count.
     * @example
     * // Count the number of Outboxes
     * const count = await prisma.outbox.count({
     *   where: {
     *     // ... the filter for the Outboxes we want to count
     *   }
     * })
    **/
    count<T extends OutboxCountArgs>(
      args?: Subset<T, OutboxCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutboxCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Outbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutboxAggregateArgs>(args: Subset<T, OutboxAggregateArgs>): Prisma.PrismaPromise<GetOutboxAggregateType<T>>

    /**
     * Group by Outbox.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutboxGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutboxGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutboxGroupByArgs['orderBy'] }
        : { orderBy?: OutboxGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutboxGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutboxGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Outbox model
   */
  readonly fields: OutboxFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Outbox.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OutboxClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Outbox model
   */
  interface OutboxFieldRefs {
    readonly id: FieldRef<"Outbox", 'String'>
    readonly terminalId: FieldRef<"Outbox", 'String'>
    readonly entityType: FieldRef<"Outbox", 'String'>
    readonly entityId: FieldRef<"Outbox", 'String'>
    readonly operation: FieldRef<"Outbox", 'SyncOperation'>
    readonly data: FieldRef<"Outbox", 'Json'>
    readonly createdInMode: FieldRef<"Outbox", 'OperationModeType'>
    readonly shiftId: FieldRef<"Outbox", 'String'>
    readonly userId: FieldRef<"Outbox", 'String'>
    readonly syncPriority: FieldRef<"Outbox", 'Int'>
    readonly attemptCount: FieldRef<"Outbox", 'Int'>
    readonly maxAttempts: FieldRef<"Outbox", 'Int'>
    readonly lastAttemptAt: FieldRef<"Outbox", 'DateTime'>
    readonly errorMessage: FieldRef<"Outbox", 'String'>
    readonly createdAt: FieldRef<"Outbox", 'DateTime'>
    readonly localTimestamp: FieldRef<"Outbox", 'DateTime'>
    readonly syncVersion: FieldRef<"Outbox", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Outbox findUnique
   */
  export type OutboxFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter, which Outbox to fetch.
     */
    where: OutboxWhereUniqueInput
  }

  /**
   * Outbox findUniqueOrThrow
   */
  export type OutboxFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter, which Outbox to fetch.
     */
    where: OutboxWhereUniqueInput
  }

  /**
   * Outbox findFirst
   */
  export type OutboxFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter, which Outbox to fetch.
     */
    where?: OutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outboxes to fetch.
     */
    orderBy?: OutboxOrderByWithRelationInput | OutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outboxes.
     */
    cursor?: OutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outboxes.
     */
    distinct?: OutboxScalarFieldEnum | OutboxScalarFieldEnum[]
  }

  /**
   * Outbox findFirstOrThrow
   */
  export type OutboxFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter, which Outbox to fetch.
     */
    where?: OutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outboxes to fetch.
     */
    orderBy?: OutboxOrderByWithRelationInput | OutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Outboxes.
     */
    cursor?: OutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outboxes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Outboxes.
     */
    distinct?: OutboxScalarFieldEnum | OutboxScalarFieldEnum[]
  }

  /**
   * Outbox findMany
   */
  export type OutboxFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter, which Outboxes to fetch.
     */
    where?: OutboxWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Outboxes to fetch.
     */
    orderBy?: OutboxOrderByWithRelationInput | OutboxOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Outboxes.
     */
    cursor?: OutboxWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Outboxes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Outboxes.
     */
    skip?: number
    distinct?: OutboxScalarFieldEnum | OutboxScalarFieldEnum[]
  }

  /**
   * Outbox create
   */
  export type OutboxCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * The data needed to create a Outbox.
     */
    data: XOR<OutboxCreateInput, OutboxUncheckedCreateInput>
  }

  /**
   * Outbox createMany
   */
  export type OutboxCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Outboxes.
     */
    data: OutboxCreateManyInput | OutboxCreateManyInput[]
  }

  /**
   * Outbox createManyAndReturn
   */
  export type OutboxCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * The data used to create many Outboxes.
     */
    data: OutboxCreateManyInput | OutboxCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outbox update
   */
  export type OutboxUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * The data needed to update a Outbox.
     */
    data: XOR<OutboxUpdateInput, OutboxUncheckedUpdateInput>
    /**
     * Choose, which Outbox to update.
     */
    where: OutboxWhereUniqueInput
  }

  /**
   * Outbox updateMany
   */
  export type OutboxUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Outboxes.
     */
    data: XOR<OutboxUpdateManyMutationInput, OutboxUncheckedUpdateManyInput>
    /**
     * Filter which Outboxes to update
     */
    where?: OutboxWhereInput
    /**
     * Limit how many Outboxes to update.
     */
    limit?: number
  }

  /**
   * Outbox updateManyAndReturn
   */
  export type OutboxUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * The data used to update Outboxes.
     */
    data: XOR<OutboxUpdateManyMutationInput, OutboxUncheckedUpdateManyInput>
    /**
     * Filter which Outboxes to update
     */
    where?: OutboxWhereInput
    /**
     * Limit how many Outboxes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Outbox upsert
   */
  export type OutboxUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * The filter to search for the Outbox to update in case it exists.
     */
    where: OutboxWhereUniqueInput
    /**
     * In case the Outbox found by the `where` argument doesn't exist, create a new Outbox with this data.
     */
    create: XOR<OutboxCreateInput, OutboxUncheckedCreateInput>
    /**
     * In case the Outbox was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OutboxUpdateInput, OutboxUncheckedUpdateInput>
  }

  /**
   * Outbox delete
   */
  export type OutboxDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
    /**
     * Filter which Outbox to delete.
     */
    where: OutboxWhereUniqueInput
  }

  /**
   * Outbox deleteMany
   */
  export type OutboxDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Outboxes to delete
     */
    where?: OutboxWhereInput
    /**
     * Limit how many Outboxes to delete.
     */
    limit?: number
  }

  /**
   * Outbox without action
   */
  export type OutboxDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Outbox
     */
    select?: OutboxSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Outbox
     */
    omit?: OutboxOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OutboxInclude<ExtArgs> | null
  }


  /**
   * Model SyncHistory
   */

  export type AggregateSyncHistory = {
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  export type SyncHistoryAvgAggregateOutputType = {
    entitiesProcessed: number | null
    successCount: number | null
    failureCount: number | null
    conflictsFound: number | null
    durationMs: number | null
  }

  export type SyncHistorySumAggregateOutputType = {
    entitiesProcessed: number | null
    successCount: number | null
    failureCount: number | null
    conflictsFound: number | null
    durationMs: number | null
  }

  export type SyncHistoryMinAggregateOutputType = {
    id: string | null
    terminalId: string | null
    syncType: $Enums.SyncType | null
    direction: $Enums.SyncDirection | null
    entitiesProcessed: number | null
    successCount: number | null
    failureCount: number | null
    conflictsFound: number | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    success: boolean | null
    errorMessage: string | null
  }

  export type SyncHistoryMaxAggregateOutputType = {
    id: string | null
    terminalId: string | null
    syncType: $Enums.SyncType | null
    direction: $Enums.SyncDirection | null
    entitiesProcessed: number | null
    successCount: number | null
    failureCount: number | null
    conflictsFound: number | null
    startedAt: Date | null
    completedAt: Date | null
    durationMs: number | null
    success: boolean | null
    errorMessage: string | null
  }

  export type SyncHistoryCountAggregateOutputType = {
    id: number
    terminalId: number
    syncType: number
    direction: number
    entitiesProcessed: number
    successCount: number
    failureCount: number
    conflictsFound: number
    startedAt: number
    completedAt: number
    durationMs: number
    success: number
    errorMessage: number
    _all: number
  }


  export type SyncHistoryAvgAggregateInputType = {
    entitiesProcessed?: true
    successCount?: true
    failureCount?: true
    conflictsFound?: true
    durationMs?: true
  }

  export type SyncHistorySumAggregateInputType = {
    entitiesProcessed?: true
    successCount?: true
    failureCount?: true
    conflictsFound?: true
    durationMs?: true
  }

  export type SyncHistoryMinAggregateInputType = {
    id?: true
    terminalId?: true
    syncType?: true
    direction?: true
    entitiesProcessed?: true
    successCount?: true
    failureCount?: true
    conflictsFound?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    success?: true
    errorMessage?: true
  }

  export type SyncHistoryMaxAggregateInputType = {
    id?: true
    terminalId?: true
    syncType?: true
    direction?: true
    entitiesProcessed?: true
    successCount?: true
    failureCount?: true
    conflictsFound?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    success?: true
    errorMessage?: true
  }

  export type SyncHistoryCountAggregateInputType = {
    id?: true
    terminalId?: true
    syncType?: true
    direction?: true
    entitiesProcessed?: true
    successCount?: true
    failureCount?: true
    conflictsFound?: true
    startedAt?: true
    completedAt?: true
    durationMs?: true
    success?: true
    errorMessage?: true
    _all?: true
  }

  export type SyncHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistory to aggregate.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncHistories
    **/
    _count?: true | SyncHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type GetSyncHistoryAggregateType<T extends SyncHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncHistory[P]>
      : GetScalarType<T[P], AggregateSyncHistory[P]>
  }




  export type SyncHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncHistoryWhereInput
    orderBy?: SyncHistoryOrderByWithAggregationInput | SyncHistoryOrderByWithAggregationInput[]
    by: SyncHistoryScalarFieldEnum[] | SyncHistoryScalarFieldEnum
    having?: SyncHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncHistoryCountAggregateInputType | true
    _avg?: SyncHistoryAvgAggregateInputType
    _sum?: SyncHistorySumAggregateInputType
    _min?: SyncHistoryMinAggregateInputType
    _max?: SyncHistoryMaxAggregateInputType
  }

  export type SyncHistoryGroupByOutputType = {
    id: string
    terminalId: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed: number
    successCount: number
    failureCount: number
    conflictsFound: number
    startedAt: Date
    completedAt: Date | null
    durationMs: number | null
    success: boolean
    errorMessage: string | null
    _count: SyncHistoryCountAggregateOutputType | null
    _avg: SyncHistoryAvgAggregateOutputType | null
    _sum: SyncHistorySumAggregateOutputType | null
    _min: SyncHistoryMinAggregateOutputType | null
    _max: SyncHistoryMaxAggregateOutputType | null
  }

  type GetSyncHistoryGroupByPayload<T extends SyncHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SyncHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SyncHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    syncType?: boolean
    direction?: boolean
    entitiesProcessed?: boolean
    successCount?: boolean
    failureCount?: boolean
    conflictsFound?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    success?: boolean
    errorMessage?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    syncType?: boolean
    direction?: boolean
    entitiesProcessed?: boolean
    successCount?: boolean
    failureCount?: boolean
    conflictsFound?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    success?: boolean
    errorMessage?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    terminalId?: boolean
    syncType?: boolean
    direction?: boolean
    entitiesProcessed?: boolean
    successCount?: boolean
    failureCount?: boolean
    conflictsFound?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    success?: boolean
    errorMessage?: boolean
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["syncHistory"]>

  export type SyncHistorySelectScalar = {
    id?: boolean
    terminalId?: boolean
    syncType?: boolean
    direction?: boolean
    entitiesProcessed?: boolean
    successCount?: boolean
    failureCount?: boolean
    conflictsFound?: boolean
    startedAt?: boolean
    completedAt?: boolean
    durationMs?: boolean
    success?: boolean
    errorMessage?: boolean
  }

  export type SyncHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "terminalId" | "syncType" | "direction" | "entitiesProcessed" | "successCount" | "failureCount" | "conflictsFound" | "startedAt" | "completedAt" | "durationMs" | "success" | "errorMessage", ExtArgs["result"]["syncHistory"]>
  export type SyncHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type SyncHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }
  export type SyncHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    terminal?: boolean | TerminalDefaultArgs<ExtArgs>
  }

  export type $SyncHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncHistory"
    objects: {
      terminal: Prisma.$TerminalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      terminalId: string
      syncType: $Enums.SyncType
      direction: $Enums.SyncDirection
      entitiesProcessed: number
      successCount: number
      failureCount: number
      conflictsFound: number
      startedAt: Date
      completedAt: Date | null
      durationMs: number | null
      success: boolean
      errorMessage: string | null
    }, ExtArgs["result"]["syncHistory"]>
    composites: {}
  }

  type SyncHistoryGetPayload<S extends boolean | null | undefined | SyncHistoryDefaultArgs> = $Result.GetResult<Prisma.$SyncHistoryPayload, S>

  type SyncHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncHistoryCountAggregateInputType | true
    }

  export interface SyncHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncHistory'], meta: { name: 'SyncHistory' } }
    /**
     * Find zero or one SyncHistory that matches the filter.
     * @param {SyncHistoryFindUniqueArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncHistoryFindUniqueArgs>(args: SelectSubset<T, SyncHistoryFindUniqueArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncHistoryFindUniqueOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncHistoryFindFirstArgs>(args?: SelectSubset<T, SyncHistoryFindFirstArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindFirstOrThrowArgs} args - Arguments to find a SyncHistory
     * @example
     * // Get one SyncHistory
     * const syncHistory = await prisma.syncHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany()
     * 
     * // Get first 10 SyncHistories
     * const syncHistories = await prisma.syncHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncHistoryFindManyArgs>(args?: SelectSubset<T, SyncHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncHistory.
     * @param {SyncHistoryCreateArgs} args - Arguments to create a SyncHistory.
     * @example
     * // Create one SyncHistory
     * const SyncHistory = await prisma.syncHistory.create({
     *   data: {
     *     // ... data to create a SyncHistory
     *   }
     * })
     * 
     */
    create<T extends SyncHistoryCreateArgs>(args: SelectSubset<T, SyncHistoryCreateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncHistories.
     * @param {SyncHistoryCreateManyArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncHistoryCreateManyArgs>(args?: SelectSubset<T, SyncHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncHistories and returns the data saved in the database.
     * @param {SyncHistoryCreateManyAndReturnArgs} args - Arguments to create many SyncHistories.
     * @example
     * // Create many SyncHistories
     * const syncHistory = await prisma.syncHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncHistory.
     * @param {SyncHistoryDeleteArgs} args - Arguments to delete one SyncHistory.
     * @example
     * // Delete one SyncHistory
     * const SyncHistory = await prisma.syncHistory.delete({
     *   where: {
     *     // ... filter to delete one SyncHistory
     *   }
     * })
     * 
     */
    delete<T extends SyncHistoryDeleteArgs>(args: SelectSubset<T, SyncHistoryDeleteArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncHistory.
     * @param {SyncHistoryUpdateArgs} args - Arguments to update one SyncHistory.
     * @example
     * // Update one SyncHistory
     * const syncHistory = await prisma.syncHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncHistoryUpdateArgs>(args: SelectSubset<T, SyncHistoryUpdateArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncHistories.
     * @param {SyncHistoryDeleteManyArgs} args - Arguments to filter SyncHistories to delete.
     * @example
     * // Delete a few SyncHistories
     * const { count } = await prisma.syncHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncHistoryDeleteManyArgs>(args?: SelectSubset<T, SyncHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncHistoryUpdateManyArgs>(args: SelectSubset<T, SyncHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncHistories and returns the data updated in the database.
     * @param {SyncHistoryUpdateManyAndReturnArgs} args - Arguments to update many SyncHistories.
     * @example
     * // Update many SyncHistories
     * const syncHistory = await prisma.syncHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncHistories and only return the `id`
     * const syncHistoryWithIdOnly = await prisma.syncHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncHistory.
     * @param {SyncHistoryUpsertArgs} args - Arguments to update or create a SyncHistory.
     * @example
     * // Update or create a SyncHistory
     * const syncHistory = await prisma.syncHistory.upsert({
     *   create: {
     *     // ... data to create a SyncHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncHistory we want to update
     *   }
     * })
     */
    upsert<T extends SyncHistoryUpsertArgs>(args: SelectSubset<T, SyncHistoryUpsertArgs<ExtArgs>>): Prisma__SyncHistoryClient<$Result.GetResult<Prisma.$SyncHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryCountArgs} args - Arguments to filter SyncHistories to count.
     * @example
     * // Count the number of SyncHistories
     * const count = await prisma.syncHistory.count({
     *   where: {
     *     // ... the filter for the SyncHistories we want to count
     *   }
     * })
    **/
    count<T extends SyncHistoryCountArgs>(
      args?: Subset<T, SyncHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncHistoryAggregateArgs>(args: Subset<T, SyncHistoryAggregateArgs>): Prisma.PrismaPromise<GetSyncHistoryAggregateType<T>>

    /**
     * Group by SyncHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SyncHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncHistory model
   */
  readonly fields: SyncHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    terminal<T extends TerminalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TerminalDefaultArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncHistory model
   */
  interface SyncHistoryFieldRefs {
    readonly id: FieldRef<"SyncHistory", 'String'>
    readonly terminalId: FieldRef<"SyncHistory", 'String'>
    readonly syncType: FieldRef<"SyncHistory", 'SyncType'>
    readonly direction: FieldRef<"SyncHistory", 'SyncDirection'>
    readonly entitiesProcessed: FieldRef<"SyncHistory", 'Int'>
    readonly successCount: FieldRef<"SyncHistory", 'Int'>
    readonly failureCount: FieldRef<"SyncHistory", 'Int'>
    readonly conflictsFound: FieldRef<"SyncHistory", 'Int'>
    readonly startedAt: FieldRef<"SyncHistory", 'DateTime'>
    readonly completedAt: FieldRef<"SyncHistory", 'DateTime'>
    readonly durationMs: FieldRef<"SyncHistory", 'Int'>
    readonly success: FieldRef<"SyncHistory", 'Boolean'>
    readonly errorMessage: FieldRef<"SyncHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncHistory findUnique
   */
  export type SyncHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findUniqueOrThrow
   */
  export type SyncHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory findFirst
   */
  export type SyncHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findFirstOrThrow
   */
  export type SyncHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SyncHistory to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncHistories.
     */
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory findMany
   */
  export type SyncHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SyncHistories to fetch.
     */
    where?: SyncHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncHistories to fetch.
     */
    orderBy?: SyncHistoryOrderByWithRelationInput | SyncHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncHistories.
     */
    cursor?: SyncHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncHistories.
     */
    skip?: number
    distinct?: SyncHistoryScalarFieldEnum | SyncHistoryScalarFieldEnum[]
  }

  /**
   * SyncHistory create
   */
  export type SyncHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SyncHistory.
     */
    data: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
  }

  /**
   * SyncHistory createMany
   */
  export type SyncHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
  }

  /**
   * SyncHistory createManyAndReturn
   */
  export type SyncHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many SyncHistories.
     */
    data: SyncHistoryCreateManyInput | SyncHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncHistory update
   */
  export type SyncHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SyncHistory.
     */
    data: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
    /**
     * Choose, which SyncHistory to update.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory updateMany
   */
  export type SyncHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
  }

  /**
   * SyncHistory updateManyAndReturn
   */
  export type SyncHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * The data used to update SyncHistories.
     */
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SyncHistories to update
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SyncHistory upsert
   */
  export type SyncHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SyncHistory to update in case it exists.
     */
    where: SyncHistoryWhereUniqueInput
    /**
     * In case the SyncHistory found by the `where` argument doesn't exist, create a new SyncHistory with this data.
     */
    create: XOR<SyncHistoryCreateInput, SyncHistoryUncheckedCreateInput>
    /**
     * In case the SyncHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncHistoryUpdateInput, SyncHistoryUncheckedUpdateInput>
  }

  /**
   * SyncHistory delete
   */
  export type SyncHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
    /**
     * Filter which SyncHistory to delete.
     */
    where: SyncHistoryWhereUniqueInput
  }

  /**
   * SyncHistory deleteMany
   */
  export type SyncHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncHistories to delete
     */
    where?: SyncHistoryWhereInput
    /**
     * Limit how many SyncHistories to delete.
     */
    limit?: number
  }

  /**
   * SyncHistory without action
   */
  export type SyncHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncHistory
     */
    select?: SyncHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncHistory
     */
    omit?: SyncHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SyncHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Store
   */

  export type AggregateStore = {
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  export type StoreAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type StoreSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type StoreMinAggregateOutputType = {
    id: string | null
    storeCode: string | null
    storeName: string | null
    legalName: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    timezone: string | null
    defaultCurrency: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreMaxAggregateOutputType = {
    id: string | null
    storeCode: string | null
    storeName: string | null
    legalName: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    timezone: string | null
    defaultCurrency: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StoreCountAggregateOutputType = {
    id: number
    storeCode: number
    storeName: number
    legalName: number
    email: number
    phone: number
    addressLine1: number
    city: number
    state: number
    zipCode: number
    timezone: number
    defaultCurrency: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StoreAvgAggregateInputType = {
    syncVersion?: true
  }

  export type StoreSumAggregateInputType = {
    syncVersion?: true
  }

  export type StoreMinAggregateInputType = {
    id?: true
    storeCode?: true
    storeName?: true
    legalName?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    state?: true
    zipCode?: true
    timezone?: true
    defaultCurrency?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreMaxAggregateInputType = {
    id?: true
    storeCode?: true
    storeName?: true
    legalName?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    state?: true
    zipCode?: true
    timezone?: true
    defaultCurrency?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StoreCountAggregateInputType = {
    id?: true
    storeCode?: true
    storeName?: true
    legalName?: true
    email?: true
    phone?: true
    addressLine1?: true
    city?: true
    state?: true
    zipCode?: true
    timezone?: true
    defaultCurrency?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Store to aggregate.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreMaxAggregateInputType
  }

  export type GetStoreAggregateType<T extends StoreAggregateArgs> = {
        [P in keyof T & keyof AggregateStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStore[P]>
      : GetScalarType<T[P], AggregateStore[P]>
  }




  export type StoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreWhereInput
    orderBy?: StoreOrderByWithAggregationInput | StoreOrderByWithAggregationInput[]
    by: StoreScalarFieldEnum[] | StoreScalarFieldEnum
    having?: StoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreCountAggregateInputType | true
    _avg?: StoreAvgAggregateInputType
    _sum?: StoreSumAggregateInputType
    _min?: StoreMinAggregateInputType
    _max?: StoreMaxAggregateInputType
  }

  export type StoreGroupByOutputType = {
    id: string
    storeCode: string
    storeName: string
    legalName: string | null
    email: string | null
    phone: string | null
    addressLine1: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    timezone: string
    defaultCurrency: string
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StoreCountAggregateOutputType | null
    _avg: StoreAvgAggregateOutputType | null
    _sum: StoreSumAggregateOutputType | null
    _min: StoreMinAggregateOutputType | null
    _max: StoreMaxAggregateOutputType | null
  }

  type GetStoreGroupByPayload<T extends StoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreGroupByOutputType[P]>
            : GetScalarType<T[P], StoreGroupByOutputType[P]>
        }
      >
    >


  export type StoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeCode?: boolean
    storeName?: boolean
    legalName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    timezone?: boolean
    defaultCurrency?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeCode?: boolean
    storeName?: boolean
    legalName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    timezone?: boolean
    defaultCurrency?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeCode?: boolean
    storeName?: boolean
    legalName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    timezone?: boolean
    defaultCurrency?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["store"]>

  export type StoreSelectScalar = {
    id?: boolean
    storeCode?: boolean
    storeName?: boolean
    legalName?: boolean
    email?: boolean
    phone?: boolean
    addressLine1?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    timezone?: boolean
    defaultCurrency?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeCode" | "storeName" | "legalName" | "email" | "phone" | "addressLine1" | "city" | "state" | "zipCode" | "timezone" | "defaultCurrency" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["store"]>

  export type $StorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Store"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeCode: string
      storeName: string
      legalName: string | null
      email: string | null
      phone: string | null
      addressLine1: string | null
      city: string | null
      state: string | null
      zipCode: string | null
      timezone: string
      defaultCurrency: string
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["store"]>
    composites: {}
  }

  type StoreGetPayload<S extends boolean | null | undefined | StoreDefaultArgs> = $Result.GetResult<Prisma.$StorePayload, S>

  type StoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoreCountAggregateInputType | true
    }

  export interface StoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Store'], meta: { name: 'Store' } }
    /**
     * Find zero or one Store that matches the filter.
     * @param {StoreFindUniqueArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreFindUniqueArgs>(args: SelectSubset<T, StoreFindUniqueArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Store that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StoreFindUniqueOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreFindFirstArgs>(args?: SelectSubset<T, StoreFindFirstArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Store that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindFirstOrThrowArgs} args - Arguments to find a Store
     * @example
     * // Get one Store
     * const store = await prisma.store.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.store.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.store.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeWithIdOnly = await prisma.store.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreFindManyArgs>(args?: SelectSubset<T, StoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Store.
     * @param {StoreCreateArgs} args - Arguments to create a Store.
     * @example
     * // Create one Store
     * const Store = await prisma.store.create({
     *   data: {
     *     // ... data to create a Store
     *   }
     * })
     * 
     */
    create<T extends StoreCreateArgs>(args: SelectSubset<T, StoreCreateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {StoreCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreCreateManyArgs>(args?: SelectSubset<T, StoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoreCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const store = await prisma.store.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoreCreateManyAndReturnArgs>(args?: SelectSubset<T, StoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Store.
     * @param {StoreDeleteArgs} args - Arguments to delete one Store.
     * @example
     * // Delete one Store
     * const Store = await prisma.store.delete({
     *   where: {
     *     // ... filter to delete one Store
     *   }
     * })
     * 
     */
    delete<T extends StoreDeleteArgs>(args: SelectSubset<T, StoreDeleteArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Store.
     * @param {StoreUpdateArgs} args - Arguments to update one Store.
     * @example
     * // Update one Store
     * const store = await prisma.store.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreUpdateArgs>(args: SelectSubset<T, StoreUpdateArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {StoreDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.store.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreDeleteManyArgs>(args?: SelectSubset<T, StoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreUpdateManyArgs>(args: SelectSubset<T, StoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores and returns the data updated in the database.
     * @param {StoreUpdateManyAndReturnArgs} args - Arguments to update many Stores.
     * @example
     * // Update many Stores
     * const store = await prisma.store.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stores and only return the `id`
     * const storeWithIdOnly = await prisma.store.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StoreUpdateManyAndReturnArgs>(args: SelectSubset<T, StoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Store.
     * @param {StoreUpsertArgs} args - Arguments to update or create a Store.
     * @example
     * // Update or create a Store
     * const store = await prisma.store.upsert({
     *   create: {
     *     // ... data to create a Store
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Store we want to update
     *   }
     * })
     */
    upsert<T extends StoreUpsertArgs>(args: SelectSubset<T, StoreUpsertArgs<ExtArgs>>): Prisma__StoreClient<$Result.GetResult<Prisma.$StorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.store.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoreCountArgs>(
      args?: Subset<T, StoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreAggregateArgs>(args: Subset<T, StoreAggregateArgs>): Prisma.PrismaPromise<GetStoreAggregateType<T>>

    /**
     * Group by Store.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreGroupByArgs['orderBy'] }
        : { orderBy?: StoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Store model
   */
  readonly fields: StoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Store.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Store model
   */
  interface StoreFieldRefs {
    readonly id: FieldRef<"Store", 'String'>
    readonly storeCode: FieldRef<"Store", 'String'>
    readonly storeName: FieldRef<"Store", 'String'>
    readonly legalName: FieldRef<"Store", 'String'>
    readonly email: FieldRef<"Store", 'String'>
    readonly phone: FieldRef<"Store", 'String'>
    readonly addressLine1: FieldRef<"Store", 'String'>
    readonly city: FieldRef<"Store", 'String'>
    readonly state: FieldRef<"Store", 'String'>
    readonly zipCode: FieldRef<"Store", 'String'>
    readonly timezone: FieldRef<"Store", 'String'>
    readonly defaultCurrency: FieldRef<"Store", 'String'>
    readonly syncVersion: FieldRef<"Store", 'Int'>
    readonly lastSyncedAt: FieldRef<"Store", 'DateTime'>
    readonly isDirty: FieldRef<"Store", 'Boolean'>
    readonly isActive: FieldRef<"Store", 'Boolean'>
    readonly createdAt: FieldRef<"Store", 'DateTime'>
    readonly updatedAt: FieldRef<"Store", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Store findUnique
   */
  export type StoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findUniqueOrThrow
   */
  export type StoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store findFirst
   */
  export type StoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findFirstOrThrow
   */
  export type StoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Store to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store findMany
   */
  export type StoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoreOrderByWithRelationInput | StoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoreScalarFieldEnum | StoreScalarFieldEnum[]
  }

  /**
   * Store create
   */
  export type StoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data needed to create a Store.
     */
    data: XOR<StoreCreateInput, StoreUncheckedCreateInput>
  }

  /**
   * Store createMany
   */
  export type StoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
  }

  /**
   * Store createManyAndReturn
   */
  export type StoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoreCreateManyInput | StoreCreateManyInput[]
  }

  /**
   * Store update
   */
  export type StoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data needed to update a Store.
     */
    data: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
    /**
     * Choose, which Store to update.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store updateMany
   */
  export type StoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store updateManyAndReturn
   */
  export type StoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The data used to update Stores.
     */
    data: XOR<StoreUpdateManyMutationInput, StoreUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to update.
     */
    limit?: number
  }

  /**
   * Store upsert
   */
  export type StoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * The filter to search for the Store to update in case it exists.
     */
    where: StoreWhereUniqueInput
    /**
     * In case the Store found by the `where` argument doesn't exist, create a new Store with this data.
     */
    create: XOR<StoreCreateInput, StoreUncheckedCreateInput>
    /**
     * In case the Store was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreUpdateInput, StoreUncheckedUpdateInput>
  }

  /**
   * Store delete
   */
  export type StoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
    /**
     * Filter which Store to delete.
     */
    where: StoreWhereUniqueInput
  }

  /**
   * Store deleteMany
   */
  export type StoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoreWhereInput
    /**
     * Limit how many Stores to delete.
     */
    limit?: number
  }

  /**
   * Store without action
   */
  export type StoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Store
     */
    select?: StoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Store
     */
    omit?: StoreOmit<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationAvgAggregateOutputType = {
    taxRate: number | null
    syncVersion: number | null
  }

  export type LocationSumAggregateOutputType = {
    taxRate: number | null
    syncVersion: number | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: $Enums.LocationType | null
    address: string | null
    phone: string | null
    centralLocationId: string | null
    centralBranchId: string | null
    timezone: string | null
    taxRate: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    type: $Enums.LocationType | null
    address: string | null
    phone: string | null
    centralLocationId: string | null
    centralBranchId: string | null
    timezone: string | null
    taxRate: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    type: number
    address: number
    phone: number
    centralLocationId: number
    centralBranchId: number
    timezone: number
    taxRate: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationAvgAggregateInputType = {
    taxRate?: true
    syncVersion?: true
  }

  export type LocationSumAggregateInputType = {
    taxRate?: true
    syncVersion?: true
  }

  export type LocationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    centralLocationId?: true
    centralBranchId?: true
    timezone?: true
    taxRate?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    centralLocationId?: true
    centralBranchId?: true
    timezone?: true
    taxRate?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    type?: true
    address?: true
    phone?: true
    centralLocationId?: true
    centralBranchId?: true
    timezone?: true
    taxRate?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _avg?: LocationAvgAggregateInputType
    _sum?: LocationSumAggregateInputType
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    code: string
    name: string
    type: $Enums.LocationType
    address: string | null
    phone: string | null
    centralLocationId: string | null
    centralBranchId: string | null
    timezone: string
    taxRate: number
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _avg: LocationAvgAggregateOutputType | null
    _sum: LocationSumAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    centralLocationId?: boolean
    centralBranchId?: boolean
    timezone?: boolean
    taxRate?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    saleOrders?: boolean | Location$saleOrdersArgs<ExtArgs>
    inventoryItems?: boolean | Location$inventoryItemsArgs<ExtArgs>
    shifts?: boolean | Location$shiftsArgs<ExtArgs>
    stockAdjustments?: boolean | Location$stockAdjustmentsArgs<ExtArgs>
    stockTransfersFrom?: boolean | Location$stockTransfersFromArgs<ExtArgs>
    stockTransfersTo?: boolean | Location$stockTransfersToArgs<ExtArgs>
    returnOrders?: boolean | Location$returnOrdersArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>

  export type LocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    centralLocationId?: boolean
    centralBranchId?: boolean
    timezone?: boolean
    taxRate?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    centralLocationId?: boolean
    centralBranchId?: boolean
    timezone?: boolean
    taxRate?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["location"]>

  export type LocationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    type?: boolean
    address?: boolean
    phone?: boolean
    centralLocationId?: boolean
    centralBranchId?: boolean
    timezone?: boolean
    taxRate?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "type" | "address" | "phone" | "centralLocationId" | "centralBranchId" | "timezone" | "taxRate" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    saleOrders?: boolean | Location$saleOrdersArgs<ExtArgs>
    inventoryItems?: boolean | Location$inventoryItemsArgs<ExtArgs>
    shifts?: boolean | Location$shiftsArgs<ExtArgs>
    stockAdjustments?: boolean | Location$stockAdjustmentsArgs<ExtArgs>
    stockTransfersFrom?: boolean | Location$stockTransfersFromArgs<ExtArgs>
    stockTransfersTo?: boolean | Location$stockTransfersToArgs<ExtArgs>
    returnOrders?: boolean | Location$returnOrdersArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      saleOrders: Prisma.$SaleOrderPayload<ExtArgs>[]
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      stockAdjustments: Prisma.$StockAdjustmentPayload<ExtArgs>[]
      stockTransfersFrom: Prisma.$StockTransferPayload<ExtArgs>[]
      stockTransfersTo: Prisma.$StockTransferPayload<ExtArgs>[]
      returnOrders: Prisma.$ReturnOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      type: $Enums.LocationType
      address: string | null
      phone: string | null
      centralLocationId: string | null
      centralBranchId: string | null
      timezone: string
      taxRate: number
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Locations and returns the data saved in the database.
     * @param {LocationCreateManyAndReturnArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations and returns the data updated in the database.
     * @param {LocationUpdateManyAndReturnArgs} args - Arguments to update many Locations.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Locations and only return the `id`
     * const locationWithIdOnly = await prisma.location.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    saleOrders<T extends Location$saleOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Location$saleOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventoryItems<T extends Location$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Location$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shifts<T extends Location$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Location$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockAdjustments<T extends Location$stockAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransfersFrom<T extends Location$stockTransfersFromArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockTransfersFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransfersTo<T extends Location$stockTransfersToArgs<ExtArgs> = {}>(args?: Subset<T, Location$stockTransfersToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnOrders<T extends Location$returnOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Location$returnOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly code: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly type: FieldRef<"Location", 'LocationType'>
    readonly address: FieldRef<"Location", 'String'>
    readonly phone: FieldRef<"Location", 'String'>
    readonly centralLocationId: FieldRef<"Location", 'String'>
    readonly centralBranchId: FieldRef<"Location", 'String'>
    readonly timezone: FieldRef<"Location", 'String'>
    readonly taxRate: FieldRef<"Location", 'Float'>
    readonly syncVersion: FieldRef<"Location", 'Int'>
    readonly lastSyncedAt: FieldRef<"Location", 'DateTime'>
    readonly isDirty: FieldRef<"Location", 'Boolean'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location createManyAndReturn
   */
  export type LocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location updateManyAndReturn
   */
  export type LocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.saleOrders
   */
  export type Location$saleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    cursor?: SaleOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * Location.inventoryItems
   */
  export type Location$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * Location.shifts
   */
  export type Location$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Location.stockAdjustments
   */
  export type Location$stockAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    where?: StockAdjustmentWhereInput
    orderBy?: StockAdjustmentOrderByWithRelationInput | StockAdjustmentOrderByWithRelationInput[]
    cursor?: StockAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAdjustmentScalarFieldEnum | StockAdjustmentScalarFieldEnum[]
  }

  /**
   * Location.stockTransfersFrom
   */
  export type Location$stockTransfersFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * Location.stockTransfersTo
   */
  export type Location$stockTransfersToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    cursor?: StockTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * Location.returnOrders
   */
  export type Location$returnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    where?: ReturnOrderWhereInput
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    cursor?: ReturnOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type ProductSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    categoryId: string | null
    brandId: string | null
    taxCategoryId: string | null
    imageUrl: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    type: $Enums.ProductType | null
    categoryId: string | null
    brandId: string | null
    taxCategoryId: string | null
    imageUrl: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    type: number
    categoryId: number
    brandId: number
    taxCategoryId: number
    imageUrl: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    syncVersion?: true
  }

  export type ProductSumAggregateInputType = {
    syncVersion?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    categoryId?: true
    brandId?: true
    taxCategoryId?: true
    imageUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    categoryId?: true
    brandId?: true
    taxCategoryId?: true
    imageUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    type?: true
    categoryId?: true
    brandId?: true
    taxCategoryId?: true
    imageUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    type: $Enums.ProductType
    categoryId: string | null
    brandId: string | null
    taxCategoryId: string | null
    imageUrl: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    brandId?: boolean
    taxCategoryId?: boolean
    imageUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    brandId?: boolean
    taxCategoryId?: boolean
    imageUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    brandId?: boolean
    taxCategoryId?: boolean
    imageUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    categoryId?: boolean
    brandId?: boolean
    taxCategoryId?: boolean
    imageUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "type" | "categoryId" | "brandId" | "taxCategoryId" | "imageUrl" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Product$categoryArgs<ExtArgs>
    brand?: boolean | Product$brandArgs<ExtArgs>
    taxCategory?: boolean | Product$taxCategoryArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      taxCategory: Prisma.$TaxCategoryPayload<ExtArgs> | null
      variants: Prisma.$ProductVariantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      type: $Enums.ProductType
      categoryId: string | null
      brandId: string | null
      taxCategoryId: string | null
      imageUrl: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends Product$brandArgs<ExtArgs> = {}>(args?: Subset<T, Product$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    taxCategory<T extends Product$taxCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$taxCategoryArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly type: FieldRef<"Product", 'ProductType'>
    readonly categoryId: FieldRef<"Product", 'String'>
    readonly brandId: FieldRef<"Product", 'String'>
    readonly taxCategoryId: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly syncVersion: FieldRef<"Product", 'Int'>
    readonly lastSyncedAt: FieldRef<"Product", 'DateTime'>
    readonly isDirty: FieldRef<"Product", 'Boolean'>
    readonly isActive: FieldRef<"Product", 'Boolean'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Product.brand
   */
  export type Product$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * Product.taxCategory
   */
  export type Product$taxCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    where?: TaxCategoryWhereInput
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    cursor?: ProductVariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductVariant
   */

  export type AggregateProductVariant = {
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  export type ProductVariantAvgAggregateOutputType = {
    cost: number | null
    price: number | null
    compareAtPrice: number | null
    weight: number | null
    syncVersion: number | null
  }

  export type ProductVariantSumAggregateOutputType = {
    cost: number | null
    price: number | null
    compareAtPrice: number | null
    weight: number | null
    syncVersion: number | null
  }

  export type ProductVariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    cost: number | null
    price: number | null
    compareAtPrice: number | null
    trackInventory: boolean | null
    barcode: string | null
    upc: string | null
    ean: string | null
    color: string | null
    size: string | null
    material: string | null
    style: string | null
    weight: number | null
    weightUnit: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    name: string | null
    cost: number | null
    price: number | null
    compareAtPrice: number | null
    trackInventory: boolean | null
    barcode: string | null
    upc: string | null
    ean: string | null
    color: string | null
    size: string | null
    material: string | null
    style: string | null
    weight: number | null
    weightUnit: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductVariantCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    name: number
    cost: number
    price: number
    compareAtPrice: number
    trackInventory: number
    barcode: number
    upc: number
    ean: number
    color: number
    size: number
    material: number
    style: number
    weight: number
    weightUnit: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductVariantAvgAggregateInputType = {
    cost?: true
    price?: true
    compareAtPrice?: true
    weight?: true
    syncVersion?: true
  }

  export type ProductVariantSumAggregateInputType = {
    cost?: true
    price?: true
    compareAtPrice?: true
    weight?: true
    syncVersion?: true
  }

  export type ProductVariantMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    cost?: true
    price?: true
    compareAtPrice?: true
    trackInventory?: true
    barcode?: true
    upc?: true
    ean?: true
    color?: true
    size?: true
    material?: true
    style?: true
    weight?: true
    weightUnit?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    cost?: true
    price?: true
    compareAtPrice?: true
    trackInventory?: true
    barcode?: true
    upc?: true
    ean?: true
    color?: true
    size?: true
    material?: true
    style?: true
    weight?: true
    weightUnit?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductVariantCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    name?: true
    cost?: true
    price?: true
    compareAtPrice?: true
    trackInventory?: true
    barcode?: true
    upc?: true
    ean?: true
    color?: true
    size?: true
    material?: true
    style?: true
    weight?: true
    weightUnit?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductVariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariant to aggregate.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductVariants
    **/
    _count?: true | ProductVariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductVariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductVariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductVariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductVariantMaxAggregateInputType
  }

  export type GetProductVariantAggregateType<T extends ProductVariantAggregateArgs> = {
        [P in keyof T & keyof AggregateProductVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductVariant[P]>
      : GetScalarType<T[P], AggregateProductVariant[P]>
  }




  export type ProductVariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductVariantWhereInput
    orderBy?: ProductVariantOrderByWithAggregationInput | ProductVariantOrderByWithAggregationInput[]
    by: ProductVariantScalarFieldEnum[] | ProductVariantScalarFieldEnum
    having?: ProductVariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductVariantCountAggregateInputType | true
    _avg?: ProductVariantAvgAggregateInputType
    _sum?: ProductVariantSumAggregateInputType
    _min?: ProductVariantMinAggregateInputType
    _max?: ProductVariantMaxAggregateInputType
  }

  export type ProductVariantGroupByOutputType = {
    id: string
    productId: string
    sku: string
    name: string | null
    cost: number
    price: number
    compareAtPrice: number | null
    trackInventory: boolean
    barcode: string | null
    upc: string | null
    ean: string | null
    color: string | null
    size: string | null
    material: string | null
    style: string | null
    weight: number | null
    weightUnit: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProductVariantCountAggregateOutputType | null
    _avg: ProductVariantAvgAggregateOutputType | null
    _sum: ProductVariantSumAggregateOutputType | null
    _min: ProductVariantMinAggregateOutputType | null
    _max: ProductVariantMaxAggregateOutputType | null
  }

  type GetProductVariantGroupByPayload<T extends ProductVariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductVariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductVariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
            : GetScalarType<T[P], ProductVariantGroupByOutputType[P]>
        }
      >
    >


  export type ProductVariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    cost?: boolean
    price?: boolean
    compareAtPrice?: boolean
    trackInventory?: boolean
    barcode?: boolean
    upc?: boolean
    ean?: boolean
    color?: boolean
    size?: boolean
    material?: boolean
    style?: boolean
    weight?: boolean
    weightUnit?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItems?: boolean | ProductVariant$inventoryItemsArgs<ExtArgs>
    saleOrderLines?: boolean | ProductVariant$saleOrderLinesArgs<ExtArgs>
    returnOrderLines?: boolean | ProductVariant$returnOrderLinesArgs<ExtArgs>
    stockAdjustmentLines?: boolean | ProductVariant$stockAdjustmentLinesArgs<ExtArgs>
    stockTransferLines?: boolean | ProductVariant$stockTransferLinesArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    cost?: boolean
    price?: boolean
    compareAtPrice?: boolean
    trackInventory?: boolean
    barcode?: boolean
    upc?: boolean
    ean?: boolean
    color?: boolean
    size?: boolean
    material?: boolean
    style?: boolean
    weight?: boolean
    weightUnit?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    cost?: boolean
    price?: boolean
    compareAtPrice?: boolean
    trackInventory?: boolean
    barcode?: boolean
    upc?: boolean
    ean?: boolean
    color?: boolean
    size?: boolean
    material?: boolean
    style?: boolean
    weight?: boolean
    weightUnit?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productVariant"]>

  export type ProductVariantSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    name?: boolean
    cost?: boolean
    price?: boolean
    compareAtPrice?: boolean
    trackInventory?: boolean
    barcode?: boolean
    upc?: boolean
    ean?: boolean
    color?: boolean
    size?: boolean
    material?: boolean
    style?: boolean
    weight?: boolean
    weightUnit?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductVariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "sku" | "name" | "cost" | "price" | "compareAtPrice" | "trackInventory" | "barcode" | "upc" | "ean" | "color" | "size" | "material" | "style" | "weight" | "weightUnit" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["productVariant"]>
  export type ProductVariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    inventoryItems?: boolean | ProductVariant$inventoryItemsArgs<ExtArgs>
    saleOrderLines?: boolean | ProductVariant$saleOrderLinesArgs<ExtArgs>
    returnOrderLines?: boolean | ProductVariant$returnOrderLinesArgs<ExtArgs>
    stockAdjustmentLines?: boolean | ProductVariant$stockAdjustmentLinesArgs<ExtArgs>
    stockTransferLines?: boolean | ProductVariant$stockTransferLinesArgs<ExtArgs>
    _count?: boolean | ProductVariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductVariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductVariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductVariant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      inventoryItems: Prisma.$InventoryItemPayload<ExtArgs>[]
      saleOrderLines: Prisma.$SaleOrderLinePayload<ExtArgs>[]
      returnOrderLines: Prisma.$ReturnOrderLinePayload<ExtArgs>[]
      stockAdjustmentLines: Prisma.$StockAdjustmentLinePayload<ExtArgs>[]
      stockTransferLines: Prisma.$StockTransferLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      name: string | null
      cost: number
      price: number
      compareAtPrice: number | null
      trackInventory: boolean
      barcode: string | null
      upc: string | null
      ean: string | null
      color: string | null
      size: string | null
      material: string | null
      style: string | null
      weight: number | null
      weightUnit: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["productVariant"]>
    composites: {}
  }

  type ProductVariantGetPayload<S extends boolean | null | undefined | ProductVariantDefaultArgs> = $Result.GetResult<Prisma.$ProductVariantPayload, S>

  type ProductVariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductVariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductVariantCountAggregateInputType | true
    }

  export interface ProductVariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductVariant'], meta: { name: 'ProductVariant' } }
    /**
     * Find zero or one ProductVariant that matches the filter.
     * @param {ProductVariantFindUniqueArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductVariantFindUniqueArgs>(args: SelectSubset<T, ProductVariantFindUniqueArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductVariant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductVariantFindUniqueOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductVariantFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductVariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductVariantFindFirstArgs>(args?: SelectSubset<T, ProductVariantFindFirstArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductVariant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindFirstOrThrowArgs} args - Arguments to find a ProductVariant
     * @example
     * // Get one ProductVariant
     * const productVariant = await prisma.productVariant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductVariantFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductVariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductVariants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductVariants
     * const productVariants = await prisma.productVariant.findMany()
     * 
     * // Get first 10 ProductVariants
     * const productVariants = await prisma.productVariant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductVariantFindManyArgs>(args?: SelectSubset<T, ProductVariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductVariant.
     * @param {ProductVariantCreateArgs} args - Arguments to create a ProductVariant.
     * @example
     * // Create one ProductVariant
     * const ProductVariant = await prisma.productVariant.create({
     *   data: {
     *     // ... data to create a ProductVariant
     *   }
     * })
     * 
     */
    create<T extends ProductVariantCreateArgs>(args: SelectSubset<T, ProductVariantCreateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductVariants.
     * @param {ProductVariantCreateManyArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductVariantCreateManyArgs>(args?: SelectSubset<T, ProductVariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductVariants and returns the data saved in the database.
     * @param {ProductVariantCreateManyAndReturnArgs} args - Arguments to create many ProductVariants.
     * @example
     * // Create many ProductVariants
     * const productVariant = await prisma.productVariant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductVariantCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductVariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductVariant.
     * @param {ProductVariantDeleteArgs} args - Arguments to delete one ProductVariant.
     * @example
     * // Delete one ProductVariant
     * const ProductVariant = await prisma.productVariant.delete({
     *   where: {
     *     // ... filter to delete one ProductVariant
     *   }
     * })
     * 
     */
    delete<T extends ProductVariantDeleteArgs>(args: SelectSubset<T, ProductVariantDeleteArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductVariant.
     * @param {ProductVariantUpdateArgs} args - Arguments to update one ProductVariant.
     * @example
     * // Update one ProductVariant
     * const productVariant = await prisma.productVariant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductVariantUpdateArgs>(args: SelectSubset<T, ProductVariantUpdateArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductVariants.
     * @param {ProductVariantDeleteManyArgs} args - Arguments to filter ProductVariants to delete.
     * @example
     * // Delete a few ProductVariants
     * const { count } = await prisma.productVariant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductVariantDeleteManyArgs>(args?: SelectSubset<T, ProductVariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductVariantUpdateManyArgs>(args: SelectSubset<T, ProductVariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductVariants and returns the data updated in the database.
     * @param {ProductVariantUpdateManyAndReturnArgs} args - Arguments to update many ProductVariants.
     * @example
     * // Update many ProductVariants
     * const productVariant = await prisma.productVariant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductVariants and only return the `id`
     * const productVariantWithIdOnly = await prisma.productVariant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductVariantUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductVariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductVariant.
     * @param {ProductVariantUpsertArgs} args - Arguments to update or create a ProductVariant.
     * @example
     * // Update or create a ProductVariant
     * const productVariant = await prisma.productVariant.upsert({
     *   create: {
     *     // ... data to create a ProductVariant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductVariant we want to update
     *   }
     * })
     */
    upsert<T extends ProductVariantUpsertArgs>(args: SelectSubset<T, ProductVariantUpsertArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductVariants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantCountArgs} args - Arguments to filter ProductVariants to count.
     * @example
     * // Count the number of ProductVariants
     * const count = await prisma.productVariant.count({
     *   where: {
     *     // ... the filter for the ProductVariants we want to count
     *   }
     * })
    **/
    count<T extends ProductVariantCountArgs>(
      args?: Subset<T, ProductVariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductVariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductVariantAggregateArgs>(args: Subset<T, ProductVariantAggregateArgs>): Prisma.PrismaPromise<GetProductVariantAggregateType<T>>

    /**
     * Group by ProductVariant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductVariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductVariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductVariantGroupByArgs['orderBy'] }
        : { orderBy?: ProductVariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductVariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductVariant model
   */
  readonly fields: ProductVariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductVariant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductVariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inventoryItems<T extends ProductVariant$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleOrderLines<T extends ProductVariant$saleOrderLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$saleOrderLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnOrderLines<T extends ProductVariant$returnOrderLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$returnOrderLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockAdjustmentLines<T extends ProductVariant$stockAdjustmentLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockAdjustmentLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockTransferLines<T extends ProductVariant$stockTransferLinesArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariant$stockTransferLinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductVariant model
   */
  interface ProductVariantFieldRefs {
    readonly id: FieldRef<"ProductVariant", 'String'>
    readonly productId: FieldRef<"ProductVariant", 'String'>
    readonly sku: FieldRef<"ProductVariant", 'String'>
    readonly name: FieldRef<"ProductVariant", 'String'>
    readonly cost: FieldRef<"ProductVariant", 'Float'>
    readonly price: FieldRef<"ProductVariant", 'Float'>
    readonly compareAtPrice: FieldRef<"ProductVariant", 'Float'>
    readonly trackInventory: FieldRef<"ProductVariant", 'Boolean'>
    readonly barcode: FieldRef<"ProductVariant", 'String'>
    readonly upc: FieldRef<"ProductVariant", 'String'>
    readonly ean: FieldRef<"ProductVariant", 'String'>
    readonly color: FieldRef<"ProductVariant", 'String'>
    readonly size: FieldRef<"ProductVariant", 'String'>
    readonly material: FieldRef<"ProductVariant", 'String'>
    readonly style: FieldRef<"ProductVariant", 'String'>
    readonly weight: FieldRef<"ProductVariant", 'Float'>
    readonly weightUnit: FieldRef<"ProductVariant", 'String'>
    readonly syncVersion: FieldRef<"ProductVariant", 'Int'>
    readonly lastSyncedAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly isDirty: FieldRef<"ProductVariant", 'Boolean'>
    readonly isActive: FieldRef<"ProductVariant", 'Boolean'>
    readonly createdAt: FieldRef<"ProductVariant", 'DateTime'>
    readonly updatedAt: FieldRef<"ProductVariant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductVariant findUnique
   */
  export type ProductVariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findUniqueOrThrow
   */
  export type ProductVariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant findFirst
   */
  export type ProductVariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findFirstOrThrow
   */
  export type ProductVariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariant to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductVariants.
     */
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant findMany
   */
  export type ProductVariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter, which ProductVariants to fetch.
     */
    where?: ProductVariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductVariants to fetch.
     */
    orderBy?: ProductVariantOrderByWithRelationInput | ProductVariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductVariants.
     */
    cursor?: ProductVariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductVariants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductVariants.
     */
    skip?: number
    distinct?: ProductVariantScalarFieldEnum | ProductVariantScalarFieldEnum[]
  }

  /**
   * ProductVariant create
   */
  export type ProductVariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductVariant.
     */
    data: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
  }

  /**
   * ProductVariant createMany
   */
  export type ProductVariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
  }

  /**
   * ProductVariant createManyAndReturn
   */
  export type ProductVariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to create many ProductVariants.
     */
    data: ProductVariantCreateManyInput | ProductVariantCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant update
   */
  export type ProductVariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductVariant.
     */
    data: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
    /**
     * Choose, which ProductVariant to update.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant updateMany
   */
  export type ProductVariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
  }

  /**
   * ProductVariant updateManyAndReturn
   */
  export type ProductVariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * The data used to update ProductVariants.
     */
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyInput>
    /**
     * Filter which ProductVariants to update
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductVariant upsert
   */
  export type ProductVariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductVariant to update in case it exists.
     */
    where: ProductVariantWhereUniqueInput
    /**
     * In case the ProductVariant found by the `where` argument doesn't exist, create a new ProductVariant with this data.
     */
    create: XOR<ProductVariantCreateInput, ProductVariantUncheckedCreateInput>
    /**
     * In case the ProductVariant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductVariantUpdateInput, ProductVariantUncheckedUpdateInput>
  }

  /**
   * ProductVariant delete
   */
  export type ProductVariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
    /**
     * Filter which ProductVariant to delete.
     */
    where: ProductVariantWhereUniqueInput
  }

  /**
   * ProductVariant deleteMany
   */
  export type ProductVariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductVariants to delete
     */
    where?: ProductVariantWhereInput
    /**
     * Limit how many ProductVariants to delete.
     */
    limit?: number
  }

  /**
   * ProductVariant.inventoryItems
   */
  export type ProductVariant$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    cursor?: InventoryItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * ProductVariant.saleOrderLines
   */
  export type ProductVariant$saleOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    where?: SaleOrderLineWhereInput
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    cursor?: SaleOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderLineScalarFieldEnum | SaleOrderLineScalarFieldEnum[]
  }

  /**
   * ProductVariant.returnOrderLines
   */
  export type ProductVariant$returnOrderLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    where?: ReturnOrderLineWhereInput
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    cursor?: ReturnOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnOrderLineScalarFieldEnum | ReturnOrderLineScalarFieldEnum[]
  }

  /**
   * ProductVariant.stockAdjustmentLines
   */
  export type ProductVariant$stockAdjustmentLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    where?: StockAdjustmentLineWhereInput
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    cursor?: StockAdjustmentLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAdjustmentLineScalarFieldEnum | StockAdjustmentLineScalarFieldEnum[]
  }

  /**
   * ProductVariant.stockTransferLines
   */
  export type ProductVariant$stockTransferLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    where?: StockTransferLineWhereInput
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    cursor?: StockTransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferLineScalarFieldEnum | StockTransferLineScalarFieldEnum[]
  }

  /**
   * ProductVariant without action
   */
  export type ProductVariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductVariant
     */
    select?: ProductVariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductVariant
     */
    omit?: ProductVariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductVariantInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type CategorySumAggregateOutputType = {
    syncVersion: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    parentId: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    imageUrl: string | null
    parentId: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    imageUrl: number
    parentId: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    syncVersion?: true
  }

  export type CategorySumAggregateInputType = {
    syncVersion?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    parentId?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    parentId?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    imageUrl?: true
    parentId?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    imageUrl: string | null
    parentId: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    parentId?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    parentId?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    parentId?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parent?: boolean | Category$parentArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    imageUrl?: boolean
    parentId?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "imageUrl" | "parentId" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
    children?: boolean | Category$childrenArgs<ExtArgs>
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Category$parentArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      parent: Prisma.$CategoryPayload<ExtArgs> | null
      children: Prisma.$CategoryPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      imageUrl: string | null
      parentId: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Category$parentArgs<ExtArgs> = {}>(args?: Subset<T, Category$parentArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Category$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Category$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly code: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly imageUrl: FieldRef<"Category", 'String'>
    readonly parentId: FieldRef<"Category", 'String'>
    readonly syncVersion: FieldRef<"Category", 'Int'>
    readonly lastSyncedAt: FieldRef<"Category", 'DateTime'>
    readonly isDirty: FieldRef<"Category", 'Boolean'>
    readonly isActive: FieldRef<"Category", 'Boolean'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.parent
   */
  export type Category$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Category.children
   */
  export type Category$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    cursor?: CategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type BrandSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    logoUrl: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    logoUrl: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandAvgAggregateInputType = {
    syncVersion?: true
  }

  export type BrandSumAggregateInputType = {
    syncVersion?: true
  }

  export type BrandMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    logoUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    logoUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    logoUrl?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BrandAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BrandSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _avg?: BrandAvgAggregateInputType
    _sum?: BrandSumAggregateInputType
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    logoUrl: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _avg: BrandAvgAggregateOutputType | null
    _sum: BrandSumAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Brand$productsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    logoUrl?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "logoUrl" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Brand$productsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      logoUrl: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Brand$productsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly code: FieldRef<"Brand", 'String'>
    readonly name: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
    readonly logoUrl: FieldRef<"Brand", 'String'>
    readonly syncVersion: FieldRef<"Brand", 'Int'>
    readonly lastSyncedAt: FieldRef<"Brand", 'DateTime'>
    readonly isDirty: FieldRef<"Brand", 'Boolean'>
    readonly isActive: FieldRef<"Brand", 'Boolean'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.products
   */
  export type Brand$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    loyaltyPoints: number | null
    totalSpent: number | null
    totalOrders: number | null
    creditLimit: number | null
    currentBalance: number | null
    syncVersion: number | null
  }

  export type CustomerSumAggregateOutputType = {
    loyaltyPoints: number | null
    totalSpent: number | null
    totalOrders: number | null
    creditLimit: number | null
    currentBalance: number | null
    syncVersion: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    code: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    type: $Enums.CustomerType | null
    groupId: string | null
    loyaltyPoints: number | null
    totalSpent: number | null
    totalOrders: number | null
    creditLimit: number | null
    currentBalance: number | null
    allowMarketing: boolean | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    code: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    type: $Enums.CustomerType | null
    groupId: string | null
    loyaltyPoints: number | null
    totalSpent: number | null
    totalOrders: number | null
    creditLimit: number | null
    currentBalance: number | null
    allowMarketing: boolean | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    code: number
    firstName: number
    lastName: number
    email: number
    phone: number
    dateOfBirth: number
    gender: number
    type: number
    groupId: number
    loyaltyPoints: number
    totalSpent: number
    totalOrders: number
    creditLimit: number
    currentBalance: number
    allowMarketing: number
    notes: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    loyaltyPoints?: true
    totalSpent?: true
    totalOrders?: true
    creditLimit?: true
    currentBalance?: true
    syncVersion?: true
  }

  export type CustomerSumAggregateInputType = {
    loyaltyPoints?: true
    totalSpent?: true
    totalOrders?: true
    creditLimit?: true
    currentBalance?: true
    syncVersion?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    type?: true
    groupId?: true
    loyaltyPoints?: true
    totalSpent?: true
    totalOrders?: true
    creditLimit?: true
    currentBalance?: true
    allowMarketing?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    type?: true
    groupId?: true
    loyaltyPoints?: true
    totalSpent?: true
    totalOrders?: true
    creditLimit?: true
    currentBalance?: true
    allowMarketing?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    code?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    type?: true
    groupId?: true
    loyaltyPoints?: true
    totalSpent?: true
    totalOrders?: true
    creditLimit?: true
    currentBalance?: true
    allowMarketing?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    code: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: string | null
    type: $Enums.CustomerType
    groupId: string | null
    loyaltyPoints: number
    totalSpent: number
    totalOrders: number
    creditLimit: number | null
    currentBalance: number
    allowMarketing: boolean
    notes: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    type?: boolean
    groupId?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    totalOrders?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    allowMarketing?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | Customer$groupArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    saleOrders?: boolean | Customer$saleOrdersArgs<ExtArgs>
    returnOrders?: boolean | Customer$returnOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    type?: boolean
    groupId?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    totalOrders?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    allowMarketing?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | Customer$groupArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    type?: boolean
    groupId?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    totalOrders?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    allowMarketing?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    group?: boolean | Customer$groupArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    code?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    type?: boolean
    groupId?: boolean
    loyaltyPoints?: boolean
    totalSpent?: boolean
    totalOrders?: boolean
    creditLimit?: boolean
    currentBalance?: boolean
    allowMarketing?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "firstName" | "lastName" | "email" | "phone" | "dateOfBirth" | "gender" | "type" | "groupId" | "loyaltyPoints" | "totalSpent" | "totalOrders" | "creditLimit" | "currentBalance" | "allowMarketing" | "notes" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Customer$groupArgs<ExtArgs>
    addresses?: boolean | Customer$addressesArgs<ExtArgs>
    saleOrders?: boolean | Customer$saleOrdersArgs<ExtArgs>
    returnOrders?: boolean | Customer$returnOrdersArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Customer$groupArgs<ExtArgs>
  }
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | Customer$groupArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      group: Prisma.$CustomerGroupPayload<ExtArgs> | null
      addresses: Prisma.$CustomerAddressPayload<ExtArgs>[]
      saleOrders: Prisma.$SaleOrderPayload<ExtArgs>[]
      returnOrders: Prisma.$ReturnOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      dateOfBirth: Date | null
      gender: string | null
      type: $Enums.CustomerType
      groupId: string | null
      loyaltyPoints: number
      totalSpent: number
      totalOrders: number
      creditLimit: number | null
      currentBalance: number
      allowMarketing: boolean
      notes: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends Customer$groupArgs<ExtArgs> = {}>(args?: Subset<T, Customer$groupArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    addresses<T extends Customer$addressesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleOrders<T extends Customer$saleOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$saleOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnOrders<T extends Customer$returnOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Customer$returnOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly code: FieldRef<"Customer", 'String'>
    readonly firstName: FieldRef<"Customer", 'String'>
    readonly lastName: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly dateOfBirth: FieldRef<"Customer", 'DateTime'>
    readonly gender: FieldRef<"Customer", 'String'>
    readonly type: FieldRef<"Customer", 'CustomerType'>
    readonly groupId: FieldRef<"Customer", 'String'>
    readonly loyaltyPoints: FieldRef<"Customer", 'Int'>
    readonly totalSpent: FieldRef<"Customer", 'Float'>
    readonly totalOrders: FieldRef<"Customer", 'Int'>
    readonly creditLimit: FieldRef<"Customer", 'Float'>
    readonly currentBalance: FieldRef<"Customer", 'Float'>
    readonly allowMarketing: FieldRef<"Customer", 'Boolean'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly syncVersion: FieldRef<"Customer", 'Int'>
    readonly lastSyncedAt: FieldRef<"Customer", 'DateTime'>
    readonly isDirty: FieldRef<"Customer", 'Boolean'>
    readonly isActive: FieldRef<"Customer", 'Boolean'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.group
   */
  export type Customer$groupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    where?: CustomerGroupWhereInput
  }

  /**
   * Customer.addresses
   */
  export type Customer$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    cursor?: CustomerAddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * Customer.saleOrders
   */
  export type Customer$saleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    cursor?: SaleOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * Customer.returnOrders
   */
  export type Customer$returnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    where?: ReturnOrderWhereInput
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    cursor?: ReturnOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model CustomerGroup
   */

  export type AggregateCustomerGroup = {
    _count: CustomerGroupCountAggregateOutputType | null
    _avg: CustomerGroupAvgAggregateOutputType | null
    _sum: CustomerGroupSumAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  export type CustomerGroupAvgAggregateOutputType = {
    discountPercent: number | null
    syncVersion: number | null
  }

  export type CustomerGroupSumAggregateOutputType = {
    discountPercent: number | null
    syncVersion: number | null
  }

  export type CustomerGroupMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    discountPercent: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    discountPercent: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerGroupCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    discountPercent: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerGroupAvgAggregateInputType = {
    discountPercent?: true
    syncVersion?: true
  }

  export type CustomerGroupSumAggregateInputType = {
    discountPercent?: true
    syncVersion?: true
  }

  export type CustomerGroupMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    discountPercent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    discountPercent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerGroupCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    discountPercent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroup to aggregate.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerGroups
    **/
    _count?: true | CustomerGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type GetCustomerGroupAggregateType<T extends CustomerGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerGroup[P]>
      : GetScalarType<T[P], AggregateCustomerGroup[P]>
  }




  export type CustomerGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerGroupWhereInput
    orderBy?: CustomerGroupOrderByWithAggregationInput | CustomerGroupOrderByWithAggregationInput[]
    by: CustomerGroupScalarFieldEnum[] | CustomerGroupScalarFieldEnum
    having?: CustomerGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerGroupCountAggregateInputType | true
    _avg?: CustomerGroupAvgAggregateInputType
    _sum?: CustomerGroupSumAggregateInputType
    _min?: CustomerGroupMinAggregateInputType
    _max?: CustomerGroupMaxAggregateInputType
  }

  export type CustomerGroupGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    discountPercent: number
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerGroupCountAggregateOutputType | null
    _avg: CustomerGroupAvgAggregateOutputType | null
    _sum: CustomerGroupSumAggregateOutputType | null
    _min: CustomerGroupMinAggregateOutputType | null
    _max: CustomerGroupMaxAggregateOutputType | null
  }

  type GetCustomerGroupGroupByPayload<T extends CustomerGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupGroupByOutputType[P]>
        }
      >
    >


  export type CustomerGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    discountPercent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customers?: boolean | CustomerGroup$customersArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    discountPercent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    discountPercent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customerGroup"]>

  export type CustomerGroupSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    discountPercent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "discountPercent" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["customerGroup"]>
  export type CustomerGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CustomerGroup$customersArgs<ExtArgs>
    _count?: boolean | CustomerGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerGroup"
    objects: {
      customers: Prisma.$CustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      discountPercent: number
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerGroup"]>
    composites: {}
  }

  type CustomerGroupGetPayload<S extends boolean | null | undefined | CustomerGroupDefaultArgs> = $Result.GetResult<Prisma.$CustomerGroupPayload, S>

  type CustomerGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerGroupCountAggregateInputType | true
    }

  export interface CustomerGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerGroup'], meta: { name: 'CustomerGroup' } }
    /**
     * Find zero or one CustomerGroup that matches the filter.
     * @param {CustomerGroupFindUniqueArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerGroupFindUniqueArgs>(args: SelectSubset<T, CustomerGroupFindUniqueArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerGroupFindUniqueOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerGroupFindFirstArgs>(args?: SelectSubset<T, CustomerGroupFindFirstArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindFirstOrThrowArgs} args - Arguments to find a CustomerGroup
     * @example
     * // Get one CustomerGroup
     * const customerGroup = await prisma.customerGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany()
     * 
     * // Get first 10 CustomerGroups
     * const customerGroups = await prisma.customerGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerGroupFindManyArgs>(args?: SelectSubset<T, CustomerGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerGroup.
     * @param {CustomerGroupCreateArgs} args - Arguments to create a CustomerGroup.
     * @example
     * // Create one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.create({
     *   data: {
     *     // ... data to create a CustomerGroup
     *   }
     * })
     * 
     */
    create<T extends CustomerGroupCreateArgs>(args: SelectSubset<T, CustomerGroupCreateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerGroups.
     * @param {CustomerGroupCreateManyArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerGroupCreateManyArgs>(args?: SelectSubset<T, CustomerGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerGroups and returns the data saved in the database.
     * @param {CustomerGroupCreateManyAndReturnArgs} args - Arguments to create many CustomerGroups.
     * @example
     * // Create many CustomerGroups
     * const customerGroup = await prisma.customerGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerGroup.
     * @param {CustomerGroupDeleteArgs} args - Arguments to delete one CustomerGroup.
     * @example
     * // Delete one CustomerGroup
     * const CustomerGroup = await prisma.customerGroup.delete({
     *   where: {
     *     // ... filter to delete one CustomerGroup
     *   }
     * })
     * 
     */
    delete<T extends CustomerGroupDeleteArgs>(args: SelectSubset<T, CustomerGroupDeleteArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerGroup.
     * @param {CustomerGroupUpdateArgs} args - Arguments to update one CustomerGroup.
     * @example
     * // Update one CustomerGroup
     * const customerGroup = await prisma.customerGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerGroupUpdateArgs>(args: SelectSubset<T, CustomerGroupUpdateArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerGroups.
     * @param {CustomerGroupDeleteManyArgs} args - Arguments to filter CustomerGroups to delete.
     * @example
     * // Delete a few CustomerGroups
     * const { count } = await prisma.customerGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerGroupDeleteManyArgs>(args?: SelectSubset<T, CustomerGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerGroupUpdateManyArgs>(args: SelectSubset<T, CustomerGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerGroups and returns the data updated in the database.
     * @param {CustomerGroupUpdateManyAndReturnArgs} args - Arguments to update many CustomerGroups.
     * @example
     * // Update many CustomerGroups
     * const customerGroup = await prisma.customerGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerGroups and only return the `id`
     * const customerGroupWithIdOnly = await prisma.customerGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerGroup.
     * @param {CustomerGroupUpsertArgs} args - Arguments to update or create a CustomerGroup.
     * @example
     * // Update or create a CustomerGroup
     * const customerGroup = await prisma.customerGroup.upsert({
     *   create: {
     *     // ... data to create a CustomerGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerGroup we want to update
     *   }
     * })
     */
    upsert<T extends CustomerGroupUpsertArgs>(args: SelectSubset<T, CustomerGroupUpsertArgs<ExtArgs>>): Prisma__CustomerGroupClient<$Result.GetResult<Prisma.$CustomerGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupCountArgs} args - Arguments to filter CustomerGroups to count.
     * @example
     * // Count the number of CustomerGroups
     * const count = await prisma.customerGroup.count({
     *   where: {
     *     // ... the filter for the CustomerGroups we want to count
     *   }
     * })
    **/
    count<T extends CustomerGroupCountArgs>(
      args?: Subset<T, CustomerGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerGroupAggregateArgs>(args: Subset<T, CustomerGroupAggregateArgs>): Prisma.PrismaPromise<GetCustomerGroupAggregateType<T>>

    /**
     * Group by CustomerGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerGroup model
   */
  readonly fields: CustomerGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customers<T extends CustomerGroup$customersArgs<ExtArgs> = {}>(args?: Subset<T, CustomerGroup$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerGroup model
   */
  interface CustomerGroupFieldRefs {
    readonly id: FieldRef<"CustomerGroup", 'String'>
    readonly code: FieldRef<"CustomerGroup", 'String'>
    readonly name: FieldRef<"CustomerGroup", 'String'>
    readonly description: FieldRef<"CustomerGroup", 'String'>
    readonly discountPercent: FieldRef<"CustomerGroup", 'Float'>
    readonly syncVersion: FieldRef<"CustomerGroup", 'Int'>
    readonly lastSyncedAt: FieldRef<"CustomerGroup", 'DateTime'>
    readonly isDirty: FieldRef<"CustomerGroup", 'Boolean'>
    readonly isActive: FieldRef<"CustomerGroup", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerGroup findUnique
   */
  export type CustomerGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findUniqueOrThrow
   */
  export type CustomerGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup findFirst
   */
  export type CustomerGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findFirstOrThrow
   */
  export type CustomerGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroup to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerGroups.
     */
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup findMany
   */
  export type CustomerGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter, which CustomerGroups to fetch.
     */
    where?: CustomerGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerGroups to fetch.
     */
    orderBy?: CustomerGroupOrderByWithRelationInput | CustomerGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerGroups.
     */
    cursor?: CustomerGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerGroups.
     */
    skip?: number
    distinct?: CustomerGroupScalarFieldEnum | CustomerGroupScalarFieldEnum[]
  }

  /**
   * CustomerGroup create
   */
  export type CustomerGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerGroup.
     */
    data: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
  }

  /**
   * CustomerGroup createMany
   */
  export type CustomerGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
  }

  /**
   * CustomerGroup createManyAndReturn
   */
  export type CustomerGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerGroups.
     */
    data: CustomerGroupCreateManyInput | CustomerGroupCreateManyInput[]
  }

  /**
   * CustomerGroup update
   */
  export type CustomerGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerGroup.
     */
    data: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
    /**
     * Choose, which CustomerGroup to update.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup updateMany
   */
  export type CustomerGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup updateManyAndReturn
   */
  export type CustomerGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * The data used to update CustomerGroups.
     */
    data: XOR<CustomerGroupUpdateManyMutationInput, CustomerGroupUncheckedUpdateManyInput>
    /**
     * Filter which CustomerGroups to update
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to update.
     */
    limit?: number
  }

  /**
   * CustomerGroup upsert
   */
  export type CustomerGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerGroup to update in case it exists.
     */
    where: CustomerGroupWhereUniqueInput
    /**
     * In case the CustomerGroup found by the `where` argument doesn't exist, create a new CustomerGroup with this data.
     */
    create: XOR<CustomerGroupCreateInput, CustomerGroupUncheckedCreateInput>
    /**
     * In case the CustomerGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerGroupUpdateInput, CustomerGroupUncheckedUpdateInput>
  }

  /**
   * CustomerGroup delete
   */
  export type CustomerGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
    /**
     * Filter which CustomerGroup to delete.
     */
    where: CustomerGroupWhereUniqueInput
  }

  /**
   * CustomerGroup deleteMany
   */
  export type CustomerGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerGroups to delete
     */
    where?: CustomerGroupWhereInput
    /**
     * Limit how many CustomerGroups to delete.
     */
    limit?: number
  }

  /**
   * CustomerGroup.customers
   */
  export type CustomerGroup$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * CustomerGroup without action
   */
  export type CustomerGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerGroup
     */
    select?: CustomerGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerGroup
     */
    omit?: CustomerGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerGroupInclude<ExtArgs> | null
  }


  /**
   * Model CustomerAddress
   */

  export type AggregateCustomerAddress = {
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  export type CustomerAddressMinAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.AddressType | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressMaxAggregateOutputType = {
    id: string | null
    customerId: string | null
    type: $Enums.AddressType | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerAddressCountAggregateOutputType = {
    id: number
    customerId: number
    type: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    zipCode: number
    country: number
    isDefault: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAddressMinAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressMaxAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerAddressCountAggregateInputType = {
    id?: true
    customerId?: true
    type?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddress to aggregate.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerAddresses
    **/
    _count?: true | CustomerAddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerAddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type GetCustomerAddressAggregateType<T extends CustomerAddressAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerAddress[P]>
      : GetScalarType<T[P], AggregateCustomerAddress[P]>
  }




  export type CustomerAddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerAddressWhereInput
    orderBy?: CustomerAddressOrderByWithAggregationInput | CustomerAddressOrderByWithAggregationInput[]
    by: CustomerAddressScalarFieldEnum[] | CustomerAddressScalarFieldEnum
    having?: CustomerAddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerAddressCountAggregateInputType | true
    _min?: CustomerAddressMinAggregateInputType
    _max?: CustomerAddressMaxAggregateInputType
  }

  export type CustomerAddressGroupByOutputType = {
    id: string
    customerId: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2: string | null
    city: string
    state: string | null
    zipCode: string
    country: string
    isDefault: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerAddressCountAggregateOutputType | null
    _min: CustomerAddressMinAggregateOutputType | null
    _max: CustomerAddressMaxAggregateOutputType | null
  }

  type GetCustomerAddressGroupByPayload<T extends CustomerAddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerAddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerAddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerAddressGroupByOutputType[P]>
        }
      >
    >


  export type CustomerAddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerAddress"]>

  export type CustomerAddressSelectScalar = {
    id?: boolean
    customerId?: boolean
    type?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerAddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerId" | "type" | "addressLine1" | "addressLine2" | "city" | "state" | "zipCode" | "country" | "isDefault" | "createdAt" | "updatedAt", ExtArgs["result"]["customerAddress"]>
  export type CustomerAddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }
  export type CustomerAddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
  }

  export type $CustomerAddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerAddress"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      customerId: string
      type: $Enums.AddressType
      addressLine1: string
      addressLine2: string | null
      city: string
      state: string | null
      zipCode: string
      country: string
      isDefault: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerAddress"]>
    composites: {}
  }

  type CustomerAddressGetPayload<S extends boolean | null | undefined | CustomerAddressDefaultArgs> = $Result.GetResult<Prisma.$CustomerAddressPayload, S>

  type CustomerAddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerAddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerAddressCountAggregateInputType | true
    }

  export interface CustomerAddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerAddress'], meta: { name: 'CustomerAddress' } }
    /**
     * Find zero or one CustomerAddress that matches the filter.
     * @param {CustomerAddressFindUniqueArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerAddressFindUniqueArgs>(args: SelectSubset<T, CustomerAddressFindUniqueArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerAddress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerAddressFindUniqueOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerAddressFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerAddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerAddressFindFirstArgs>(args?: SelectSubset<T, CustomerAddressFindFirstArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerAddress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindFirstOrThrowArgs} args - Arguments to find a CustomerAddress
     * @example
     * // Get one CustomerAddress
     * const customerAddress = await prisma.customerAddress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerAddressFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerAddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerAddresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany()
     * 
     * // Get first 10 CustomerAddresses
     * const customerAddresses = await prisma.customerAddress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerAddressFindManyArgs>(args?: SelectSubset<T, CustomerAddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerAddress.
     * @param {CustomerAddressCreateArgs} args - Arguments to create a CustomerAddress.
     * @example
     * // Create one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.create({
     *   data: {
     *     // ... data to create a CustomerAddress
     *   }
     * })
     * 
     */
    create<T extends CustomerAddressCreateArgs>(args: SelectSubset<T, CustomerAddressCreateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerAddresses.
     * @param {CustomerAddressCreateManyArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerAddressCreateManyArgs>(args?: SelectSubset<T, CustomerAddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerAddresses and returns the data saved in the database.
     * @param {CustomerAddressCreateManyAndReturnArgs} args - Arguments to create many CustomerAddresses.
     * @example
     * // Create many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerAddressCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerAddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerAddress.
     * @param {CustomerAddressDeleteArgs} args - Arguments to delete one CustomerAddress.
     * @example
     * // Delete one CustomerAddress
     * const CustomerAddress = await prisma.customerAddress.delete({
     *   where: {
     *     // ... filter to delete one CustomerAddress
     *   }
     * })
     * 
     */
    delete<T extends CustomerAddressDeleteArgs>(args: SelectSubset<T, CustomerAddressDeleteArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerAddress.
     * @param {CustomerAddressUpdateArgs} args - Arguments to update one CustomerAddress.
     * @example
     * // Update one CustomerAddress
     * const customerAddress = await prisma.customerAddress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerAddressUpdateArgs>(args: SelectSubset<T, CustomerAddressUpdateArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerAddresses.
     * @param {CustomerAddressDeleteManyArgs} args - Arguments to filter CustomerAddresses to delete.
     * @example
     * // Delete a few CustomerAddresses
     * const { count } = await prisma.customerAddress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerAddressDeleteManyArgs>(args?: SelectSubset<T, CustomerAddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerAddressUpdateManyArgs>(args: SelectSubset<T, CustomerAddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerAddresses and returns the data updated in the database.
     * @param {CustomerAddressUpdateManyAndReturnArgs} args - Arguments to update many CustomerAddresses.
     * @example
     * // Update many CustomerAddresses
     * const customerAddress = await prisma.customerAddress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerAddresses and only return the `id`
     * const customerAddressWithIdOnly = await prisma.customerAddress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerAddressUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerAddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerAddress.
     * @param {CustomerAddressUpsertArgs} args - Arguments to update or create a CustomerAddress.
     * @example
     * // Update or create a CustomerAddress
     * const customerAddress = await prisma.customerAddress.upsert({
     *   create: {
     *     // ... data to create a CustomerAddress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerAddress we want to update
     *   }
     * })
     */
    upsert<T extends CustomerAddressUpsertArgs>(args: SelectSubset<T, CustomerAddressUpsertArgs<ExtArgs>>): Prisma__CustomerAddressClient<$Result.GetResult<Prisma.$CustomerAddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerAddresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressCountArgs} args - Arguments to filter CustomerAddresses to count.
     * @example
     * // Count the number of CustomerAddresses
     * const count = await prisma.customerAddress.count({
     *   where: {
     *     // ... the filter for the CustomerAddresses we want to count
     *   }
     * })
    **/
    count<T extends CustomerAddressCountArgs>(
      args?: Subset<T, CustomerAddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerAddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAddressAggregateArgs>(args: Subset<T, CustomerAddressAggregateArgs>): Prisma.PrismaPromise<GetCustomerAddressAggregateType<T>>

    /**
     * Group by CustomerAddress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerAddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerAddressGroupByArgs['orderBy'] }
        : { orderBy?: CustomerAddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerAddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerAddress model
   */
  readonly fields: CustomerAddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerAddress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerAddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerAddress model
   */
  interface CustomerAddressFieldRefs {
    readonly id: FieldRef<"CustomerAddress", 'String'>
    readonly customerId: FieldRef<"CustomerAddress", 'String'>
    readonly type: FieldRef<"CustomerAddress", 'AddressType'>
    readonly addressLine1: FieldRef<"CustomerAddress", 'String'>
    readonly addressLine2: FieldRef<"CustomerAddress", 'String'>
    readonly city: FieldRef<"CustomerAddress", 'String'>
    readonly state: FieldRef<"CustomerAddress", 'String'>
    readonly zipCode: FieldRef<"CustomerAddress", 'String'>
    readonly country: FieldRef<"CustomerAddress", 'String'>
    readonly isDefault: FieldRef<"CustomerAddress", 'Boolean'>
    readonly createdAt: FieldRef<"CustomerAddress", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerAddress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerAddress findUnique
   */
  export type CustomerAddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findUniqueOrThrow
   */
  export type CustomerAddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress findFirst
   */
  export type CustomerAddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findFirstOrThrow
   */
  export type CustomerAddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddress to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerAddresses.
     */
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress findMany
   */
  export type CustomerAddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter, which CustomerAddresses to fetch.
     */
    where?: CustomerAddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerAddresses to fetch.
     */
    orderBy?: CustomerAddressOrderByWithRelationInput | CustomerAddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerAddresses.
     */
    cursor?: CustomerAddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerAddresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerAddresses.
     */
    skip?: number
    distinct?: CustomerAddressScalarFieldEnum | CustomerAddressScalarFieldEnum[]
  }

  /**
   * CustomerAddress create
   */
  export type CustomerAddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerAddress.
     */
    data: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
  }

  /**
   * CustomerAddress createMany
   */
  export type CustomerAddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
  }

  /**
   * CustomerAddress createManyAndReturn
   */
  export type CustomerAddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerAddresses.
     */
    data: CustomerAddressCreateManyInput | CustomerAddressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress update
   */
  export type CustomerAddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerAddress.
     */
    data: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
    /**
     * Choose, which CustomerAddress to update.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress updateMany
   */
  export type CustomerAddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
  }

  /**
   * CustomerAddress updateManyAndReturn
   */
  export type CustomerAddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * The data used to update CustomerAddresses.
     */
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyInput>
    /**
     * Filter which CustomerAddresses to update
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerAddress upsert
   */
  export type CustomerAddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerAddress to update in case it exists.
     */
    where: CustomerAddressWhereUniqueInput
    /**
     * In case the CustomerAddress found by the `where` argument doesn't exist, create a new CustomerAddress with this data.
     */
    create: XOR<CustomerAddressCreateInput, CustomerAddressUncheckedCreateInput>
    /**
     * In case the CustomerAddress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerAddressUpdateInput, CustomerAddressUncheckedUpdateInput>
  }

  /**
   * CustomerAddress delete
   */
  export type CustomerAddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
    /**
     * Filter which CustomerAddress to delete.
     */
    where: CustomerAddressWhereUniqueInput
  }

  /**
   * CustomerAddress deleteMany
   */
  export type CustomerAddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerAddresses to delete
     */
    where?: CustomerAddressWhereInput
    /**
     * Limit how many CustomerAddresses to delete.
     */
    limit?: number
  }

  /**
   * CustomerAddress without action
   */
  export type CustomerAddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerAddress
     */
    select?: CustomerAddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerAddress
     */
    omit?: CustomerAddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerAddressInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    quantityOnHand: number | null
    quantityReserved: number | null
    quantityAvailable: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    syncVersion: number | null
  }

  export type InventoryItemSumAggregateOutputType = {
    quantityOnHand: number | null
    quantityReserved: number | null
    quantityAvailable: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    syncVersion: number | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    variantId: string | null
    locationId: string | null
    quantityOnHand: number | null
    quantityReserved: number | null
    quantityAvailable: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    lastCountedAt: Date | null
    lastReceivedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    pendingSync: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    variantId: string | null
    locationId: string | null
    quantityOnHand: number | null
    quantityReserved: number | null
    quantityAvailable: number | null
    reorderPoint: number | null
    reorderQuantity: number | null
    lastCountedAt: Date | null
    lastReceivedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    pendingSync: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    variantId: number
    locationId: number
    quantityOnHand: number
    quantityReserved: number
    quantityAvailable: number
    reorderPoint: number
    reorderQuantity: number
    lastCountedAt: number
    lastReceivedAt: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    pendingSync: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    quantityOnHand?: true
    quantityReserved?: true
    quantityAvailable?: true
    reorderPoint?: true
    reorderQuantity?: true
    syncVersion?: true
  }

  export type InventoryItemSumAggregateInputType = {
    quantityOnHand?: true
    quantityReserved?: true
    quantityAvailable?: true
    reorderPoint?: true
    reorderQuantity?: true
    syncVersion?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    variantId?: true
    locationId?: true
    quantityOnHand?: true
    quantityReserved?: true
    quantityAvailable?: true
    reorderPoint?: true
    reorderQuantity?: true
    lastCountedAt?: true
    lastReceivedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    pendingSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    variantId?: true
    locationId?: true
    quantityOnHand?: true
    quantityReserved?: true
    quantityAvailable?: true
    reorderPoint?: true
    reorderQuantity?: true
    lastCountedAt?: true
    lastReceivedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    pendingSync?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    variantId?: true
    locationId?: true
    quantityOnHand?: true
    quantityReserved?: true
    quantityAvailable?: true
    reorderPoint?: true
    reorderQuantity?: true
    lastCountedAt?: true
    lastReceivedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    pendingSync?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    variantId: string
    locationId: string
    quantityOnHand: number
    quantityReserved: number
    quantityAvailable: number
    reorderPoint: number | null
    reorderQuantity: number | null
    lastCountedAt: Date | null
    lastReceivedAt: Date | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    pendingSync: boolean
    createdAt: Date
    updatedAt: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    locationId?: boolean
    quantityOnHand?: boolean
    quantityReserved?: boolean
    quantityAvailable?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    lastCountedAt?: boolean
    lastReceivedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    locationId?: boolean
    quantityOnHand?: boolean
    quantityReserved?: boolean
    quantityAvailable?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    lastCountedAt?: boolean
    lastReceivedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    locationId?: boolean
    quantityOnHand?: boolean
    quantityReserved?: boolean
    quantityAvailable?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    lastCountedAt?: boolean
    lastReceivedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    variantId?: boolean
    locationId?: boolean
    quantityOnHand?: boolean
    quantityReserved?: boolean
    quantityAvailable?: boolean
    reorderPoint?: boolean
    reorderQuantity?: boolean
    lastCountedAt?: boolean
    lastReceivedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variantId" | "locationId" | "quantityOnHand" | "quantityReserved" | "quantityAvailable" | "reorderPoint" | "reorderQuantity" | "lastCountedAt" | "lastReceivedAt" | "syncVersion" | "lastSyncedAt" | "isDirty" | "pendingSync" | "createdAt" | "updatedAt", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      variant: Prisma.$ProductVariantPayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variantId: string
      locationId: string
      quantityOnHand: number
      quantityReserved: number
      quantityAvailable: number
      reorderPoint: number | null
      reorderQuantity: number | null
      lastCountedAt: Date | null
      lastReceivedAt: Date | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      pendingSync: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly variantId: FieldRef<"InventoryItem", 'String'>
    readonly locationId: FieldRef<"InventoryItem", 'String'>
    readonly quantityOnHand: FieldRef<"InventoryItem", 'Int'>
    readonly quantityReserved: FieldRef<"InventoryItem", 'Int'>
    readonly quantityAvailable: FieldRef<"InventoryItem", 'Int'>
    readonly reorderPoint: FieldRef<"InventoryItem", 'Int'>
    readonly reorderQuantity: FieldRef<"InventoryItem", 'Int'>
    readonly lastCountedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly lastReceivedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly syncVersion: FieldRef<"InventoryItem", 'Int'>
    readonly lastSyncedAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly isDirty: FieldRef<"InventoryItem", 'Boolean'>
    readonly pendingSync: FieldRef<"InventoryItem", 'Boolean'>
    readonly createdAt: FieldRef<"InventoryItem", 'DateTime'>
    readonly updatedAt: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model StockAdjustment
   */

  export type AggregateStockAdjustment = {
    _count: StockAdjustmentCountAggregateOutputType | null
    _avg: StockAdjustmentAvgAggregateOutputType | null
    _sum: StockAdjustmentSumAggregateOutputType | null
    _min: StockAdjustmentMinAggregateOutputType | null
    _max: StockAdjustmentMaxAggregateOutputType | null
  }

  export type StockAdjustmentAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type StockAdjustmentSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type StockAdjustmentMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    adjustmentType: $Enums.StockAdjustmentType | null
    reason: string | null
    referenceNumber: string | null
    notes: string | null
    adjustedBy: string | null
    adjustedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
  }

  export type StockAdjustmentMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    adjustmentType: $Enums.StockAdjustmentType | null
    reason: string | null
    referenceNumber: string | null
    notes: string | null
    adjustedBy: string | null
    adjustedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
  }

  export type StockAdjustmentCountAggregateOutputType = {
    id: number
    locationId: number
    adjustmentType: number
    reason: number
    referenceNumber: number
    notes: number
    adjustedBy: number
    adjustedAt: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    createdAt: number
    _all: number
  }


  export type StockAdjustmentAvgAggregateInputType = {
    syncVersion?: true
  }

  export type StockAdjustmentSumAggregateInputType = {
    syncVersion?: true
  }

  export type StockAdjustmentMinAggregateInputType = {
    id?: true
    locationId?: true
    adjustmentType?: true
    reason?: true
    referenceNumber?: true
    notes?: true
    adjustedBy?: true
    adjustedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
  }

  export type StockAdjustmentMaxAggregateInputType = {
    id?: true
    locationId?: true
    adjustmentType?: true
    reason?: true
    referenceNumber?: true
    notes?: true
    adjustedBy?: true
    adjustedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
  }

  export type StockAdjustmentCountAggregateInputType = {
    id?: true
    locationId?: true
    adjustmentType?: true
    reason?: true
    referenceNumber?: true
    notes?: true
    adjustedBy?: true
    adjustedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    _all?: true
  }

  export type StockAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAdjustment to aggregate.
     */
    where?: StockAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustments to fetch.
     */
    orderBy?: StockAdjustmentOrderByWithRelationInput | StockAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockAdjustments
    **/
    _count?: true | StockAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockAdjustmentMaxAggregateInputType
  }

  export type GetStockAdjustmentAggregateType<T extends StockAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateStockAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockAdjustment[P]>
      : GetScalarType<T[P], AggregateStockAdjustment[P]>
  }




  export type StockAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAdjustmentWhereInput
    orderBy?: StockAdjustmentOrderByWithAggregationInput | StockAdjustmentOrderByWithAggregationInput[]
    by: StockAdjustmentScalarFieldEnum[] | StockAdjustmentScalarFieldEnum
    having?: StockAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockAdjustmentCountAggregateInputType | true
    _avg?: StockAdjustmentAvgAggregateInputType
    _sum?: StockAdjustmentSumAggregateInputType
    _min?: StockAdjustmentMinAggregateInputType
    _max?: StockAdjustmentMaxAggregateInputType
  }

  export type StockAdjustmentGroupByOutputType = {
    id: string
    locationId: string
    adjustmentType: $Enums.StockAdjustmentType
    reason: string | null
    referenceNumber: string | null
    notes: string | null
    adjustedBy: string | null
    adjustedAt: Date
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    createdAt: Date
    _count: StockAdjustmentCountAggregateOutputType | null
    _avg: StockAdjustmentAvgAggregateOutputType | null
    _sum: StockAdjustmentSumAggregateOutputType | null
    _min: StockAdjustmentMinAggregateOutputType | null
    _max: StockAdjustmentMaxAggregateOutputType | null
  }

  type GetStockAdjustmentGroupByPayload<T extends StockAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], StockAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type StockAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    adjustmentType?: boolean
    reason?: boolean
    referenceNumber?: boolean
    notes?: boolean
    adjustedBy?: boolean
    adjustedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    lineItems?: boolean | StockAdjustment$lineItemsArgs<ExtArgs>
    _count?: boolean | StockAdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustment"]>

  export type StockAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    adjustmentType?: boolean
    reason?: boolean
    referenceNumber?: boolean
    notes?: boolean
    adjustedBy?: boolean
    adjustedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustment"]>

  export type StockAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    adjustmentType?: boolean
    reason?: boolean
    referenceNumber?: boolean
    notes?: boolean
    adjustedBy?: boolean
    adjustedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustment"]>

  export type StockAdjustmentSelectScalar = {
    id?: boolean
    locationId?: boolean
    adjustmentType?: boolean
    reason?: boolean
    referenceNumber?: boolean
    notes?: boolean
    adjustedBy?: boolean
    adjustedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
  }

  export type StockAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "adjustmentType" | "reason" | "referenceNumber" | "notes" | "adjustedBy" | "adjustedAt" | "syncVersion" | "lastSyncedAt" | "isDirty" | "createdAt", ExtArgs["result"]["stockAdjustment"]>
  export type StockAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    lineItems?: boolean | StockAdjustment$lineItemsArgs<ExtArgs>
    _count?: boolean | StockAdjustmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type StockAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $StockAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockAdjustment"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      lineItems: Prisma.$StockAdjustmentLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      adjustmentType: $Enums.StockAdjustmentType
      reason: string | null
      referenceNumber: string | null
      notes: string | null
      adjustedBy: string | null
      adjustedAt: Date
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      createdAt: Date
    }, ExtArgs["result"]["stockAdjustment"]>
    composites: {}
  }

  type StockAdjustmentGetPayload<S extends boolean | null | undefined | StockAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$StockAdjustmentPayload, S>

  type StockAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockAdjustmentCountAggregateInputType | true
    }

  export interface StockAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockAdjustment'], meta: { name: 'StockAdjustment' } }
    /**
     * Find zero or one StockAdjustment that matches the filter.
     * @param {StockAdjustmentFindUniqueArgs} args - Arguments to find a StockAdjustment
     * @example
     * // Get one StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockAdjustmentFindUniqueArgs>(args: SelectSubset<T, StockAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a StockAdjustment
     * @example
     * // Get one StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, StockAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentFindFirstArgs} args - Arguments to find a StockAdjustment
     * @example
     * // Get one StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockAdjustmentFindFirstArgs>(args?: SelectSubset<T, StockAdjustmentFindFirstArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentFindFirstOrThrowArgs} args - Arguments to find a StockAdjustment
     * @example
     * // Get one StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, StockAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockAdjustments
     * const stockAdjustments = await prisma.stockAdjustment.findMany()
     * 
     * // Get first 10 StockAdjustments
     * const stockAdjustments = await prisma.stockAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockAdjustmentWithIdOnly = await prisma.stockAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockAdjustmentFindManyArgs>(args?: SelectSubset<T, StockAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockAdjustment.
     * @param {StockAdjustmentCreateArgs} args - Arguments to create a StockAdjustment.
     * @example
     * // Create one StockAdjustment
     * const StockAdjustment = await prisma.stockAdjustment.create({
     *   data: {
     *     // ... data to create a StockAdjustment
     *   }
     * })
     * 
     */
    create<T extends StockAdjustmentCreateArgs>(args: SelectSubset<T, StockAdjustmentCreateArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockAdjustments.
     * @param {StockAdjustmentCreateManyArgs} args - Arguments to create many StockAdjustments.
     * @example
     * // Create many StockAdjustments
     * const stockAdjustment = await prisma.stockAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockAdjustmentCreateManyArgs>(args?: SelectSubset<T, StockAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockAdjustments and returns the data saved in the database.
     * @param {StockAdjustmentCreateManyAndReturnArgs} args - Arguments to create many StockAdjustments.
     * @example
     * // Create many StockAdjustments
     * const stockAdjustment = await prisma.stockAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockAdjustments and only return the `id`
     * const stockAdjustmentWithIdOnly = await prisma.stockAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, StockAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockAdjustment.
     * @param {StockAdjustmentDeleteArgs} args - Arguments to delete one StockAdjustment.
     * @example
     * // Delete one StockAdjustment
     * const StockAdjustment = await prisma.stockAdjustment.delete({
     *   where: {
     *     // ... filter to delete one StockAdjustment
     *   }
     * })
     * 
     */
    delete<T extends StockAdjustmentDeleteArgs>(args: SelectSubset<T, StockAdjustmentDeleteArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockAdjustment.
     * @param {StockAdjustmentUpdateArgs} args - Arguments to update one StockAdjustment.
     * @example
     * // Update one StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockAdjustmentUpdateArgs>(args: SelectSubset<T, StockAdjustmentUpdateArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockAdjustments.
     * @param {StockAdjustmentDeleteManyArgs} args - Arguments to filter StockAdjustments to delete.
     * @example
     * // Delete a few StockAdjustments
     * const { count } = await prisma.stockAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockAdjustmentDeleteManyArgs>(args?: SelectSubset<T, StockAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockAdjustments
     * const stockAdjustment = await prisma.stockAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockAdjustmentUpdateManyArgs>(args: SelectSubset<T, StockAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAdjustments and returns the data updated in the database.
     * @param {StockAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many StockAdjustments.
     * @example
     * // Update many StockAdjustments
     * const stockAdjustment = await prisma.stockAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockAdjustments and only return the `id`
     * const stockAdjustmentWithIdOnly = await prisma.stockAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, StockAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockAdjustment.
     * @param {StockAdjustmentUpsertArgs} args - Arguments to update or create a StockAdjustment.
     * @example
     * // Update or create a StockAdjustment
     * const stockAdjustment = await prisma.stockAdjustment.upsert({
     *   create: {
     *     // ... data to create a StockAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends StockAdjustmentUpsertArgs>(args: SelectSubset<T, StockAdjustmentUpsertArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentCountArgs} args - Arguments to filter StockAdjustments to count.
     * @example
     * // Count the number of StockAdjustments
     * const count = await prisma.stockAdjustment.count({
     *   where: {
     *     // ... the filter for the StockAdjustments we want to count
     *   }
     * })
    **/
    count<T extends StockAdjustmentCountArgs>(
      args?: Subset<T, StockAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAdjustmentAggregateArgs>(args: Subset<T, StockAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetStockAdjustmentAggregateType<T>>

    /**
     * Group by StockAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: StockAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockAdjustment model
   */
  readonly fields: StockAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lineItems<T extends StockAdjustment$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, StockAdjustment$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockAdjustment model
   */
  interface StockAdjustmentFieldRefs {
    readonly id: FieldRef<"StockAdjustment", 'String'>
    readonly locationId: FieldRef<"StockAdjustment", 'String'>
    readonly adjustmentType: FieldRef<"StockAdjustment", 'StockAdjustmentType'>
    readonly reason: FieldRef<"StockAdjustment", 'String'>
    readonly referenceNumber: FieldRef<"StockAdjustment", 'String'>
    readonly notes: FieldRef<"StockAdjustment", 'String'>
    readonly adjustedBy: FieldRef<"StockAdjustment", 'String'>
    readonly adjustedAt: FieldRef<"StockAdjustment", 'DateTime'>
    readonly syncVersion: FieldRef<"StockAdjustment", 'Int'>
    readonly lastSyncedAt: FieldRef<"StockAdjustment", 'DateTime'>
    readonly isDirty: FieldRef<"StockAdjustment", 'Boolean'>
    readonly createdAt: FieldRef<"StockAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockAdjustment findUnique
   */
  export type StockAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustment to fetch.
     */
    where: StockAdjustmentWhereUniqueInput
  }

  /**
   * StockAdjustment findUniqueOrThrow
   */
  export type StockAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustment to fetch.
     */
    where: StockAdjustmentWhereUniqueInput
  }

  /**
   * StockAdjustment findFirst
   */
  export type StockAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustment to fetch.
     */
    where?: StockAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustments to fetch.
     */
    orderBy?: StockAdjustmentOrderByWithRelationInput | StockAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAdjustments.
     */
    cursor?: StockAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAdjustments.
     */
    distinct?: StockAdjustmentScalarFieldEnum | StockAdjustmentScalarFieldEnum[]
  }

  /**
   * StockAdjustment findFirstOrThrow
   */
  export type StockAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustment to fetch.
     */
    where?: StockAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustments to fetch.
     */
    orderBy?: StockAdjustmentOrderByWithRelationInput | StockAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAdjustments.
     */
    cursor?: StockAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAdjustments.
     */
    distinct?: StockAdjustmentScalarFieldEnum | StockAdjustmentScalarFieldEnum[]
  }

  /**
   * StockAdjustment findMany
   */
  export type StockAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustments to fetch.
     */
    where?: StockAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustments to fetch.
     */
    orderBy?: StockAdjustmentOrderByWithRelationInput | StockAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockAdjustments.
     */
    cursor?: StockAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustments.
     */
    skip?: number
    distinct?: StockAdjustmentScalarFieldEnum | StockAdjustmentScalarFieldEnum[]
  }

  /**
   * StockAdjustment create
   */
  export type StockAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a StockAdjustment.
     */
    data: XOR<StockAdjustmentCreateInput, StockAdjustmentUncheckedCreateInput>
  }

  /**
   * StockAdjustment createMany
   */
  export type StockAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockAdjustments.
     */
    data: StockAdjustmentCreateManyInput | StockAdjustmentCreateManyInput[]
  }

  /**
   * StockAdjustment createManyAndReturn
   */
  export type StockAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many StockAdjustments.
     */
    data: StockAdjustmentCreateManyInput | StockAdjustmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAdjustment update
   */
  export type StockAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a StockAdjustment.
     */
    data: XOR<StockAdjustmentUpdateInput, StockAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which StockAdjustment to update.
     */
    where: StockAdjustmentWhereUniqueInput
  }

  /**
   * StockAdjustment updateMany
   */
  export type StockAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockAdjustments.
     */
    data: XOR<StockAdjustmentUpdateManyMutationInput, StockAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which StockAdjustments to update
     */
    where?: StockAdjustmentWhereInput
    /**
     * Limit how many StockAdjustments to update.
     */
    limit?: number
  }

  /**
   * StockAdjustment updateManyAndReturn
   */
  export type StockAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update StockAdjustments.
     */
    data: XOR<StockAdjustmentUpdateManyMutationInput, StockAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which StockAdjustments to update
     */
    where?: StockAdjustmentWhereInput
    /**
     * Limit how many StockAdjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAdjustment upsert
   */
  export type StockAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the StockAdjustment to update in case it exists.
     */
    where: StockAdjustmentWhereUniqueInput
    /**
     * In case the StockAdjustment found by the `where` argument doesn't exist, create a new StockAdjustment with this data.
     */
    create: XOR<StockAdjustmentCreateInput, StockAdjustmentUncheckedCreateInput>
    /**
     * In case the StockAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockAdjustmentUpdateInput, StockAdjustmentUncheckedUpdateInput>
  }

  /**
   * StockAdjustment delete
   */
  export type StockAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which StockAdjustment to delete.
     */
    where: StockAdjustmentWhereUniqueInput
  }

  /**
   * StockAdjustment deleteMany
   */
  export type StockAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAdjustments to delete
     */
    where?: StockAdjustmentWhereInput
    /**
     * Limit how many StockAdjustments to delete.
     */
    limit?: number
  }

  /**
   * StockAdjustment.lineItems
   */
  export type StockAdjustment$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    where?: StockAdjustmentLineWhereInput
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    cursor?: StockAdjustmentLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockAdjustmentLineScalarFieldEnum | StockAdjustmentLineScalarFieldEnum[]
  }

  /**
   * StockAdjustment without action
   */
  export type StockAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustment
     */
    select?: StockAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustment
     */
    omit?: StockAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model StockAdjustmentLine
   */

  export type AggregateStockAdjustmentLine = {
    _count: StockAdjustmentLineCountAggregateOutputType | null
    _avg: StockAdjustmentLineAvgAggregateOutputType | null
    _sum: StockAdjustmentLineSumAggregateOutputType | null
    _min: StockAdjustmentLineMinAggregateOutputType | null
    _max: StockAdjustmentLineMaxAggregateOutputType | null
  }

  export type StockAdjustmentLineAvgAggregateOutputType = {
    quantityBefore: number | null
    quantityAfter: number | null
    quantityChange: number | null
  }

  export type StockAdjustmentLineSumAggregateOutputType = {
    quantityBefore: number | null
    quantityAfter: number | null
    quantityChange: number | null
  }

  export type StockAdjustmentLineMinAggregateOutputType = {
    id: string | null
    adjustmentId: string | null
    variantId: string | null
    quantityBefore: number | null
    quantityAfter: number | null
    quantityChange: number | null
  }

  export type StockAdjustmentLineMaxAggregateOutputType = {
    id: string | null
    adjustmentId: string | null
    variantId: string | null
    quantityBefore: number | null
    quantityAfter: number | null
    quantityChange: number | null
  }

  export type StockAdjustmentLineCountAggregateOutputType = {
    id: number
    adjustmentId: number
    variantId: number
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
    _all: number
  }


  export type StockAdjustmentLineAvgAggregateInputType = {
    quantityBefore?: true
    quantityAfter?: true
    quantityChange?: true
  }

  export type StockAdjustmentLineSumAggregateInputType = {
    quantityBefore?: true
    quantityAfter?: true
    quantityChange?: true
  }

  export type StockAdjustmentLineMinAggregateInputType = {
    id?: true
    adjustmentId?: true
    variantId?: true
    quantityBefore?: true
    quantityAfter?: true
    quantityChange?: true
  }

  export type StockAdjustmentLineMaxAggregateInputType = {
    id?: true
    adjustmentId?: true
    variantId?: true
    quantityBefore?: true
    quantityAfter?: true
    quantityChange?: true
  }

  export type StockAdjustmentLineCountAggregateInputType = {
    id?: true
    adjustmentId?: true
    variantId?: true
    quantityBefore?: true
    quantityAfter?: true
    quantityChange?: true
    _all?: true
  }

  export type StockAdjustmentLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAdjustmentLine to aggregate.
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustmentLines to fetch.
     */
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockAdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockAdjustmentLines
    **/
    _count?: true | StockAdjustmentLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockAdjustmentLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockAdjustmentLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockAdjustmentLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockAdjustmentLineMaxAggregateInputType
  }

  export type GetStockAdjustmentLineAggregateType<T extends StockAdjustmentLineAggregateArgs> = {
        [P in keyof T & keyof AggregateStockAdjustmentLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockAdjustmentLine[P]>
      : GetScalarType<T[P], AggregateStockAdjustmentLine[P]>
  }




  export type StockAdjustmentLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockAdjustmentLineWhereInput
    orderBy?: StockAdjustmentLineOrderByWithAggregationInput | StockAdjustmentLineOrderByWithAggregationInput[]
    by: StockAdjustmentLineScalarFieldEnum[] | StockAdjustmentLineScalarFieldEnum
    having?: StockAdjustmentLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockAdjustmentLineCountAggregateInputType | true
    _avg?: StockAdjustmentLineAvgAggregateInputType
    _sum?: StockAdjustmentLineSumAggregateInputType
    _min?: StockAdjustmentLineMinAggregateInputType
    _max?: StockAdjustmentLineMaxAggregateInputType
  }

  export type StockAdjustmentLineGroupByOutputType = {
    id: string
    adjustmentId: string
    variantId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
    _count: StockAdjustmentLineCountAggregateOutputType | null
    _avg: StockAdjustmentLineAvgAggregateOutputType | null
    _sum: StockAdjustmentLineSumAggregateOutputType | null
    _min: StockAdjustmentLineMinAggregateOutputType | null
    _max: StockAdjustmentLineMaxAggregateOutputType | null
  }

  type GetStockAdjustmentLineGroupByPayload<T extends StockAdjustmentLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockAdjustmentLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockAdjustmentLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockAdjustmentLineGroupByOutputType[P]>
            : GetScalarType<T[P], StockAdjustmentLineGroupByOutputType[P]>
        }
      >
    >


  export type StockAdjustmentLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    variantId?: boolean
    quantityBefore?: boolean
    quantityAfter?: boolean
    quantityChange?: boolean
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustmentLine"]>

  export type StockAdjustmentLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    variantId?: boolean
    quantityBefore?: boolean
    quantityAfter?: boolean
    quantityChange?: boolean
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustmentLine"]>

  export type StockAdjustmentLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adjustmentId?: boolean
    variantId?: boolean
    quantityBefore?: boolean
    quantityAfter?: boolean
    quantityChange?: boolean
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockAdjustmentLine"]>

  export type StockAdjustmentLineSelectScalar = {
    id?: boolean
    adjustmentId?: boolean
    variantId?: boolean
    quantityBefore?: boolean
    quantityAfter?: boolean
    quantityChange?: boolean
  }

  export type StockAdjustmentLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adjustmentId" | "variantId" | "quantityBefore" | "quantityAfter" | "quantityChange", ExtArgs["result"]["stockAdjustmentLine"]>
  export type StockAdjustmentLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type StockAdjustmentLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type StockAdjustmentLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adjustment?: boolean | StockAdjustmentDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $StockAdjustmentLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockAdjustmentLine"
    objects: {
      adjustment: Prisma.$StockAdjustmentPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adjustmentId: string
      variantId: string
      quantityBefore: number
      quantityAfter: number
      quantityChange: number
    }, ExtArgs["result"]["stockAdjustmentLine"]>
    composites: {}
  }

  type StockAdjustmentLineGetPayload<S extends boolean | null | undefined | StockAdjustmentLineDefaultArgs> = $Result.GetResult<Prisma.$StockAdjustmentLinePayload, S>

  type StockAdjustmentLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockAdjustmentLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockAdjustmentLineCountAggregateInputType | true
    }

  export interface StockAdjustmentLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockAdjustmentLine'], meta: { name: 'StockAdjustmentLine' } }
    /**
     * Find zero or one StockAdjustmentLine that matches the filter.
     * @param {StockAdjustmentLineFindUniqueArgs} args - Arguments to find a StockAdjustmentLine
     * @example
     * // Get one StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockAdjustmentLineFindUniqueArgs>(args: SelectSubset<T, StockAdjustmentLineFindUniqueArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockAdjustmentLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockAdjustmentLineFindUniqueOrThrowArgs} args - Arguments to find a StockAdjustmentLine
     * @example
     * // Get one StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockAdjustmentLineFindUniqueOrThrowArgs>(args: SelectSubset<T, StockAdjustmentLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAdjustmentLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineFindFirstArgs} args - Arguments to find a StockAdjustmentLine
     * @example
     * // Get one StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockAdjustmentLineFindFirstArgs>(args?: SelectSubset<T, StockAdjustmentLineFindFirstArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockAdjustmentLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineFindFirstOrThrowArgs} args - Arguments to find a StockAdjustmentLine
     * @example
     * // Get one StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockAdjustmentLineFindFirstOrThrowArgs>(args?: SelectSubset<T, StockAdjustmentLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockAdjustmentLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockAdjustmentLines
     * const stockAdjustmentLines = await prisma.stockAdjustmentLine.findMany()
     * 
     * // Get first 10 StockAdjustmentLines
     * const stockAdjustmentLines = await prisma.stockAdjustmentLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockAdjustmentLineWithIdOnly = await prisma.stockAdjustmentLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockAdjustmentLineFindManyArgs>(args?: SelectSubset<T, StockAdjustmentLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockAdjustmentLine.
     * @param {StockAdjustmentLineCreateArgs} args - Arguments to create a StockAdjustmentLine.
     * @example
     * // Create one StockAdjustmentLine
     * const StockAdjustmentLine = await prisma.stockAdjustmentLine.create({
     *   data: {
     *     // ... data to create a StockAdjustmentLine
     *   }
     * })
     * 
     */
    create<T extends StockAdjustmentLineCreateArgs>(args: SelectSubset<T, StockAdjustmentLineCreateArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockAdjustmentLines.
     * @param {StockAdjustmentLineCreateManyArgs} args - Arguments to create many StockAdjustmentLines.
     * @example
     * // Create many StockAdjustmentLines
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockAdjustmentLineCreateManyArgs>(args?: SelectSubset<T, StockAdjustmentLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockAdjustmentLines and returns the data saved in the database.
     * @param {StockAdjustmentLineCreateManyAndReturnArgs} args - Arguments to create many StockAdjustmentLines.
     * @example
     * // Create many StockAdjustmentLines
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockAdjustmentLines and only return the `id`
     * const stockAdjustmentLineWithIdOnly = await prisma.stockAdjustmentLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockAdjustmentLineCreateManyAndReturnArgs>(args?: SelectSubset<T, StockAdjustmentLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockAdjustmentLine.
     * @param {StockAdjustmentLineDeleteArgs} args - Arguments to delete one StockAdjustmentLine.
     * @example
     * // Delete one StockAdjustmentLine
     * const StockAdjustmentLine = await prisma.stockAdjustmentLine.delete({
     *   where: {
     *     // ... filter to delete one StockAdjustmentLine
     *   }
     * })
     * 
     */
    delete<T extends StockAdjustmentLineDeleteArgs>(args: SelectSubset<T, StockAdjustmentLineDeleteArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockAdjustmentLine.
     * @param {StockAdjustmentLineUpdateArgs} args - Arguments to update one StockAdjustmentLine.
     * @example
     * // Update one StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockAdjustmentLineUpdateArgs>(args: SelectSubset<T, StockAdjustmentLineUpdateArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockAdjustmentLines.
     * @param {StockAdjustmentLineDeleteManyArgs} args - Arguments to filter StockAdjustmentLines to delete.
     * @example
     * // Delete a few StockAdjustmentLines
     * const { count } = await prisma.stockAdjustmentLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockAdjustmentLineDeleteManyArgs>(args?: SelectSubset<T, StockAdjustmentLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAdjustmentLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockAdjustmentLines
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockAdjustmentLineUpdateManyArgs>(args: SelectSubset<T, StockAdjustmentLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockAdjustmentLines and returns the data updated in the database.
     * @param {StockAdjustmentLineUpdateManyAndReturnArgs} args - Arguments to update many StockAdjustmentLines.
     * @example
     * // Update many StockAdjustmentLines
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockAdjustmentLines and only return the `id`
     * const stockAdjustmentLineWithIdOnly = await prisma.stockAdjustmentLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockAdjustmentLineUpdateManyAndReturnArgs>(args: SelectSubset<T, StockAdjustmentLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockAdjustmentLine.
     * @param {StockAdjustmentLineUpsertArgs} args - Arguments to update or create a StockAdjustmentLine.
     * @example
     * // Update or create a StockAdjustmentLine
     * const stockAdjustmentLine = await prisma.stockAdjustmentLine.upsert({
     *   create: {
     *     // ... data to create a StockAdjustmentLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockAdjustmentLine we want to update
     *   }
     * })
     */
    upsert<T extends StockAdjustmentLineUpsertArgs>(args: SelectSubset<T, StockAdjustmentLineUpsertArgs<ExtArgs>>): Prisma__StockAdjustmentLineClient<$Result.GetResult<Prisma.$StockAdjustmentLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockAdjustmentLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineCountArgs} args - Arguments to filter StockAdjustmentLines to count.
     * @example
     * // Count the number of StockAdjustmentLines
     * const count = await prisma.stockAdjustmentLine.count({
     *   where: {
     *     // ... the filter for the StockAdjustmentLines we want to count
     *   }
     * })
    **/
    count<T extends StockAdjustmentLineCountArgs>(
      args?: Subset<T, StockAdjustmentLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockAdjustmentLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockAdjustmentLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockAdjustmentLineAggregateArgs>(args: Subset<T, StockAdjustmentLineAggregateArgs>): Prisma.PrismaPromise<GetStockAdjustmentLineAggregateType<T>>

    /**
     * Group by StockAdjustmentLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockAdjustmentLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockAdjustmentLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockAdjustmentLineGroupByArgs['orderBy'] }
        : { orderBy?: StockAdjustmentLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockAdjustmentLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockAdjustmentLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockAdjustmentLine model
   */
  readonly fields: StockAdjustmentLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockAdjustmentLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockAdjustmentLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adjustment<T extends StockAdjustmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockAdjustmentDefaultArgs<ExtArgs>>): Prisma__StockAdjustmentClient<$Result.GetResult<Prisma.$StockAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockAdjustmentLine model
   */
  interface StockAdjustmentLineFieldRefs {
    readonly id: FieldRef<"StockAdjustmentLine", 'String'>
    readonly adjustmentId: FieldRef<"StockAdjustmentLine", 'String'>
    readonly variantId: FieldRef<"StockAdjustmentLine", 'String'>
    readonly quantityBefore: FieldRef<"StockAdjustmentLine", 'Int'>
    readonly quantityAfter: FieldRef<"StockAdjustmentLine", 'Int'>
    readonly quantityChange: FieldRef<"StockAdjustmentLine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StockAdjustmentLine findUnique
   */
  export type StockAdjustmentLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustmentLine to fetch.
     */
    where: StockAdjustmentLineWhereUniqueInput
  }

  /**
   * StockAdjustmentLine findUniqueOrThrow
   */
  export type StockAdjustmentLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustmentLine to fetch.
     */
    where: StockAdjustmentLineWhereUniqueInput
  }

  /**
   * StockAdjustmentLine findFirst
   */
  export type StockAdjustmentLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustmentLine to fetch.
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustmentLines to fetch.
     */
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAdjustmentLines.
     */
    cursor?: StockAdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAdjustmentLines.
     */
    distinct?: StockAdjustmentLineScalarFieldEnum | StockAdjustmentLineScalarFieldEnum[]
  }

  /**
   * StockAdjustmentLine findFirstOrThrow
   */
  export type StockAdjustmentLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustmentLine to fetch.
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustmentLines to fetch.
     */
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockAdjustmentLines.
     */
    cursor?: StockAdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustmentLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockAdjustmentLines.
     */
    distinct?: StockAdjustmentLineScalarFieldEnum | StockAdjustmentLineScalarFieldEnum[]
  }

  /**
   * StockAdjustmentLine findMany
   */
  export type StockAdjustmentLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter, which StockAdjustmentLines to fetch.
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockAdjustmentLines to fetch.
     */
    orderBy?: StockAdjustmentLineOrderByWithRelationInput | StockAdjustmentLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockAdjustmentLines.
     */
    cursor?: StockAdjustmentLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockAdjustmentLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockAdjustmentLines.
     */
    skip?: number
    distinct?: StockAdjustmentLineScalarFieldEnum | StockAdjustmentLineScalarFieldEnum[]
  }

  /**
   * StockAdjustmentLine create
   */
  export type StockAdjustmentLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * The data needed to create a StockAdjustmentLine.
     */
    data: XOR<StockAdjustmentLineCreateInput, StockAdjustmentLineUncheckedCreateInput>
  }

  /**
   * StockAdjustmentLine createMany
   */
  export type StockAdjustmentLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockAdjustmentLines.
     */
    data: StockAdjustmentLineCreateManyInput | StockAdjustmentLineCreateManyInput[]
  }

  /**
   * StockAdjustmentLine createManyAndReturn
   */
  export type StockAdjustmentLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * The data used to create many StockAdjustmentLines.
     */
    data: StockAdjustmentLineCreateManyInput | StockAdjustmentLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAdjustmentLine update
   */
  export type StockAdjustmentLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * The data needed to update a StockAdjustmentLine.
     */
    data: XOR<StockAdjustmentLineUpdateInput, StockAdjustmentLineUncheckedUpdateInput>
    /**
     * Choose, which StockAdjustmentLine to update.
     */
    where: StockAdjustmentLineWhereUniqueInput
  }

  /**
   * StockAdjustmentLine updateMany
   */
  export type StockAdjustmentLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockAdjustmentLines.
     */
    data: XOR<StockAdjustmentLineUpdateManyMutationInput, StockAdjustmentLineUncheckedUpdateManyInput>
    /**
     * Filter which StockAdjustmentLines to update
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * Limit how many StockAdjustmentLines to update.
     */
    limit?: number
  }

  /**
   * StockAdjustmentLine updateManyAndReturn
   */
  export type StockAdjustmentLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * The data used to update StockAdjustmentLines.
     */
    data: XOR<StockAdjustmentLineUpdateManyMutationInput, StockAdjustmentLineUncheckedUpdateManyInput>
    /**
     * Filter which StockAdjustmentLines to update
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * Limit how many StockAdjustmentLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockAdjustmentLine upsert
   */
  export type StockAdjustmentLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * The filter to search for the StockAdjustmentLine to update in case it exists.
     */
    where: StockAdjustmentLineWhereUniqueInput
    /**
     * In case the StockAdjustmentLine found by the `where` argument doesn't exist, create a new StockAdjustmentLine with this data.
     */
    create: XOR<StockAdjustmentLineCreateInput, StockAdjustmentLineUncheckedCreateInput>
    /**
     * In case the StockAdjustmentLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockAdjustmentLineUpdateInput, StockAdjustmentLineUncheckedUpdateInput>
  }

  /**
   * StockAdjustmentLine delete
   */
  export type StockAdjustmentLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
    /**
     * Filter which StockAdjustmentLine to delete.
     */
    where: StockAdjustmentLineWhereUniqueInput
  }

  /**
   * StockAdjustmentLine deleteMany
   */
  export type StockAdjustmentLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockAdjustmentLines to delete
     */
    where?: StockAdjustmentLineWhereInput
    /**
     * Limit how many StockAdjustmentLines to delete.
     */
    limit?: number
  }

  /**
   * StockAdjustmentLine without action
   */
  export type StockAdjustmentLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockAdjustmentLine
     */
    select?: StockAdjustmentLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockAdjustmentLine
     */
    omit?: StockAdjustmentLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockAdjustmentLineInclude<ExtArgs> | null
  }


  /**
   * Model StockTransfer
   */

  export type AggregateStockTransfer = {
    _count: StockTransferCountAggregateOutputType | null
    _avg: StockTransferAvgAggregateOutputType | null
    _sum: StockTransferSumAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  export type StockTransferAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type StockTransferSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type StockTransferMinAggregateOutputType = {
    id: string | null
    fromLocationId: string | null
    toLocationId: string | null
    transferNumber: string | null
    status: $Enums.TransferStatus | null
    transferDate: Date | null
    notes: string | null
    createdBy: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferMaxAggregateOutputType = {
    id: string | null
    fromLocationId: string | null
    toLocationId: string | null
    transferNumber: string | null
    status: $Enums.TransferStatus | null
    transferDate: Date | null
    notes: string | null
    createdBy: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StockTransferCountAggregateOutputType = {
    id: number
    fromLocationId: number
    toLocationId: number
    transferNumber: number
    status: number
    transferDate: number
    notes: number
    createdBy: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StockTransferAvgAggregateInputType = {
    syncVersion?: true
  }

  export type StockTransferSumAggregateInputType = {
    syncVersion?: true
  }

  export type StockTransferMinAggregateInputType = {
    id?: true
    fromLocationId?: true
    toLocationId?: true
    transferNumber?: true
    status?: true
    transferDate?: true
    notes?: true
    createdBy?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferMaxAggregateInputType = {
    id?: true
    fromLocationId?: true
    toLocationId?: true
    transferNumber?: true
    status?: true
    transferDate?: true
    notes?: true
    createdBy?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StockTransferCountAggregateInputType = {
    id?: true
    fromLocationId?: true
    toLocationId?: true
    transferNumber?: true
    status?: true
    transferDate?: true
    notes?: true
    createdBy?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StockTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfer to aggregate.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransfers
    **/
    _count?: true | StockTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferMaxAggregateInputType
  }

  export type GetStockTransferAggregateType<T extends StockTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransfer[P]>
      : GetScalarType<T[P], AggregateStockTransfer[P]>
  }




  export type StockTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferWhereInput
    orderBy?: StockTransferOrderByWithAggregationInput | StockTransferOrderByWithAggregationInput[]
    by: StockTransferScalarFieldEnum[] | StockTransferScalarFieldEnum
    having?: StockTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferCountAggregateInputType | true
    _avg?: StockTransferAvgAggregateInputType
    _sum?: StockTransferSumAggregateInputType
    _min?: StockTransferMinAggregateInputType
    _max?: StockTransferMaxAggregateInputType
  }

  export type StockTransferGroupByOutputType = {
    id: string
    fromLocationId: string
    toLocationId: string
    transferNumber: string
    status: $Enums.TransferStatus
    transferDate: Date
    notes: string | null
    createdBy: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    createdAt: Date
    updatedAt: Date
    _count: StockTransferCountAggregateOutputType | null
    _avg: StockTransferAvgAggregateOutputType | null
    _sum: StockTransferSumAggregateOutputType | null
    _min: StockTransferMinAggregateOutputType | null
    _max: StockTransferMaxAggregateOutputType | null
  }

  type GetStockTransferGroupByPayload<T extends StockTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    transferNumber?: boolean
    status?: boolean
    transferDate?: boolean
    notes?: boolean
    createdBy?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
    lineItems?: boolean | StockTransfer$lineItemsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    transferNumber?: boolean
    status?: boolean
    transferDate?: boolean
    notes?: boolean
    createdBy?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    transferNumber?: boolean
    status?: boolean
    transferDate?: boolean
    notes?: boolean
    createdBy?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransfer"]>

  export type StockTransferSelectScalar = {
    id?: boolean
    fromLocationId?: boolean
    toLocationId?: boolean
    transferNumber?: boolean
    status?: boolean
    transferDate?: boolean
    notes?: boolean
    createdBy?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StockTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fromLocationId" | "toLocationId" | "transferNumber" | "status" | "transferDate" | "notes" | "createdBy" | "syncVersion" | "lastSyncedAt" | "isDirty" | "createdAt" | "updatedAt", ExtArgs["result"]["stockTransfer"]>
  export type StockTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
    lineItems?: boolean | StockTransfer$lineItemsArgs<ExtArgs>
    _count?: boolean | StockTransferCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StockTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type StockTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fromLocation?: boolean | LocationDefaultArgs<ExtArgs>
    toLocation?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $StockTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransfer"
    objects: {
      fromLocation: Prisma.$LocationPayload<ExtArgs>
      toLocation: Prisma.$LocationPayload<ExtArgs>
      lineItems: Prisma.$StockTransferLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromLocationId: string
      toLocationId: string
      transferNumber: string
      status: $Enums.TransferStatus
      transferDate: Date
      notes: string | null
      createdBy: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stockTransfer"]>
    composites: {}
  }

  type StockTransferGetPayload<S extends boolean | null | undefined | StockTransferDefaultArgs> = $Result.GetResult<Prisma.$StockTransferPayload, S>

  type StockTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransferCountAggregateInputType | true
    }

  export interface StockTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransfer'], meta: { name: 'StockTransfer' } }
    /**
     * Find zero or one StockTransfer that matches the filter.
     * @param {StockTransferFindUniqueArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransferFindUniqueArgs>(args: SelectSubset<T, StockTransferFindUniqueArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransferFindUniqueOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransferFindFirstArgs>(args?: SelectSubset<T, StockTransferFindFirstArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindFirstOrThrowArgs} args - Arguments to find a StockTransfer
     * @example
     * // Get one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany()
     * 
     * // Get first 10 StockTransfers
     * const stockTransfers = await prisma.stockTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransferFindManyArgs>(args?: SelectSubset<T, StockTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransfer.
     * @param {StockTransferCreateArgs} args - Arguments to create a StockTransfer.
     * @example
     * // Create one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.create({
     *   data: {
     *     // ... data to create a StockTransfer
     *   }
     * })
     * 
     */
    create<T extends StockTransferCreateArgs>(args: SelectSubset<T, StockTransferCreateArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransfers.
     * @param {StockTransferCreateManyArgs} args - Arguments to create many StockTransfers.
     * @example
     * // Create many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransferCreateManyArgs>(args?: SelectSubset<T, StockTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransfers and returns the data saved in the database.
     * @param {StockTransferCreateManyAndReturnArgs} args - Arguments to create many StockTransfers.
     * @example
     * // Create many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransfers and only return the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransfer.
     * @param {StockTransferDeleteArgs} args - Arguments to delete one StockTransfer.
     * @example
     * // Delete one StockTransfer
     * const StockTransfer = await prisma.stockTransfer.delete({
     *   where: {
     *     // ... filter to delete one StockTransfer
     *   }
     * })
     * 
     */
    delete<T extends StockTransferDeleteArgs>(args: SelectSubset<T, StockTransferDeleteArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransfer.
     * @param {StockTransferUpdateArgs} args - Arguments to update one StockTransfer.
     * @example
     * // Update one StockTransfer
     * const stockTransfer = await prisma.stockTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransferUpdateArgs>(args: SelectSubset<T, StockTransferUpdateArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransfers.
     * @param {StockTransferDeleteManyArgs} args - Arguments to filter StockTransfers to delete.
     * @example
     * // Delete a few StockTransfers
     * const { count } = await prisma.stockTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransferDeleteManyArgs>(args?: SelectSubset<T, StockTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransferUpdateManyArgs>(args: SelectSubset<T, StockTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransfers and returns the data updated in the database.
     * @param {StockTransferUpdateManyAndReturnArgs} args - Arguments to update many StockTransfers.
     * @example
     * // Update many StockTransfers
     * const stockTransfer = await prisma.stockTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransfers and only return the `id`
     * const stockTransferWithIdOnly = await prisma.stockTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransfer.
     * @param {StockTransferUpsertArgs} args - Arguments to update or create a StockTransfer.
     * @example
     * // Update or create a StockTransfer
     * const stockTransfer = await prisma.stockTransfer.upsert({
     *   create: {
     *     // ... data to create a StockTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransfer we want to update
     *   }
     * })
     */
    upsert<T extends StockTransferUpsertArgs>(args: SelectSubset<T, StockTransferUpsertArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferCountArgs} args - Arguments to filter StockTransfers to count.
     * @example
     * // Count the number of StockTransfers
     * const count = await prisma.stockTransfer.count({
     *   where: {
     *     // ... the filter for the StockTransfers we want to count
     *   }
     * })
    **/
    count<T extends StockTransferCountArgs>(
      args?: Subset<T, StockTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferAggregateArgs>(args: Subset<T, StockTransferAggregateArgs>): Prisma.PrismaPromise<GetStockTransferAggregateType<T>>

    /**
     * Group by StockTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransfer model
   */
  readonly fields: StockTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fromLocation<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    toLocation<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lineItems<T extends StockTransfer$lineItemsArgs<ExtArgs> = {}>(args?: Subset<T, StockTransfer$lineItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransfer model
   */
  interface StockTransferFieldRefs {
    readonly id: FieldRef<"StockTransfer", 'String'>
    readonly fromLocationId: FieldRef<"StockTransfer", 'String'>
    readonly toLocationId: FieldRef<"StockTransfer", 'String'>
    readonly transferNumber: FieldRef<"StockTransfer", 'String'>
    readonly status: FieldRef<"StockTransfer", 'TransferStatus'>
    readonly transferDate: FieldRef<"StockTransfer", 'DateTime'>
    readonly notes: FieldRef<"StockTransfer", 'String'>
    readonly createdBy: FieldRef<"StockTransfer", 'String'>
    readonly syncVersion: FieldRef<"StockTransfer", 'Int'>
    readonly lastSyncedAt: FieldRef<"StockTransfer", 'DateTime'>
    readonly isDirty: FieldRef<"StockTransfer", 'Boolean'>
    readonly createdAt: FieldRef<"StockTransfer", 'DateTime'>
    readonly updatedAt: FieldRef<"StockTransfer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockTransfer findUnique
   */
  export type StockTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer findUniqueOrThrow
   */
  export type StockTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer findFirst
   */
  export type StockTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer findFirstOrThrow
   */
  export type StockTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfer to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransfers.
     */
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer findMany
   */
  export type StockTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter, which StockTransfers to fetch.
     */
    where?: StockTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransfers to fetch.
     */
    orderBy?: StockTransferOrderByWithRelationInput | StockTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransfers.
     */
    cursor?: StockTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransfers.
     */
    skip?: number
    distinct?: StockTransferScalarFieldEnum | StockTransferScalarFieldEnum[]
  }

  /**
   * StockTransfer create
   */
  export type StockTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransfer.
     */
    data: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
  }

  /**
   * StockTransfer createMany
   */
  export type StockTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransfers.
     */
    data: StockTransferCreateManyInput | StockTransferCreateManyInput[]
  }

  /**
   * StockTransfer createManyAndReturn
   */
  export type StockTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransfers.
     */
    data: StockTransferCreateManyInput | StockTransferCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransfer update
   */
  export type StockTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransfer.
     */
    data: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
    /**
     * Choose, which StockTransfer to update.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer updateMany
   */
  export type StockTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransfers.
     */
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyInput>
    /**
     * Filter which StockTransfers to update
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to update.
     */
    limit?: number
  }

  /**
   * StockTransfer updateManyAndReturn
   */
  export type StockTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * The data used to update StockTransfers.
     */
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyInput>
    /**
     * Filter which StockTransfers to update
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransfer upsert
   */
  export type StockTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransfer to update in case it exists.
     */
    where: StockTransferWhereUniqueInput
    /**
     * In case the StockTransfer found by the `where` argument doesn't exist, create a new StockTransfer with this data.
     */
    create: XOR<StockTransferCreateInput, StockTransferUncheckedCreateInput>
    /**
     * In case the StockTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferUpdateInput, StockTransferUncheckedUpdateInput>
  }

  /**
   * StockTransfer delete
   */
  export type StockTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
    /**
     * Filter which StockTransfer to delete.
     */
    where: StockTransferWhereUniqueInput
  }

  /**
   * StockTransfer deleteMany
   */
  export type StockTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransfers to delete
     */
    where?: StockTransferWhereInput
    /**
     * Limit how many StockTransfers to delete.
     */
    limit?: number
  }

  /**
   * StockTransfer.lineItems
   */
  export type StockTransfer$lineItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    where?: StockTransferLineWhereInput
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    cursor?: StockTransferLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockTransferLineScalarFieldEnum | StockTransferLineScalarFieldEnum[]
  }

  /**
   * StockTransfer without action
   */
  export type StockTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransfer
     */
    select?: StockTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransfer
     */
    omit?: StockTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferInclude<ExtArgs> | null
  }


  /**
   * Model StockTransferLine
   */

  export type AggregateStockTransferLine = {
    _count: StockTransferLineCountAggregateOutputType | null
    _avg: StockTransferLineAvgAggregateOutputType | null
    _sum: StockTransferLineSumAggregateOutputType | null
    _min: StockTransferLineMinAggregateOutputType | null
    _max: StockTransferLineMaxAggregateOutputType | null
  }

  export type StockTransferLineAvgAggregateOutputType = {
    quantity: number | null
    received: number | null
  }

  export type StockTransferLineSumAggregateOutputType = {
    quantity: number | null
    received: number | null
  }

  export type StockTransferLineMinAggregateOutputType = {
    id: string | null
    transferId: string | null
    variantId: string | null
    quantity: number | null
    received: number | null
  }

  export type StockTransferLineMaxAggregateOutputType = {
    id: string | null
    transferId: string | null
    variantId: string | null
    quantity: number | null
    received: number | null
  }

  export type StockTransferLineCountAggregateOutputType = {
    id: number
    transferId: number
    variantId: number
    quantity: number
    received: number
    _all: number
  }


  export type StockTransferLineAvgAggregateInputType = {
    quantity?: true
    received?: true
  }

  export type StockTransferLineSumAggregateInputType = {
    quantity?: true
    received?: true
  }

  export type StockTransferLineMinAggregateInputType = {
    id?: true
    transferId?: true
    variantId?: true
    quantity?: true
    received?: true
  }

  export type StockTransferLineMaxAggregateInputType = {
    id?: true
    transferId?: true
    variantId?: true
    quantity?: true
    received?: true
  }

  export type StockTransferLineCountAggregateInputType = {
    id?: true
    transferId?: true
    variantId?: true
    quantity?: true
    received?: true
    _all?: true
  }

  export type StockTransferLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferLine to aggregate.
     */
    where?: StockTransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferLines to fetch.
     */
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockTransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockTransferLines
    **/
    _count?: true | StockTransferLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockTransferLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockTransferLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockTransferLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockTransferLineMaxAggregateInputType
  }

  export type GetStockTransferLineAggregateType<T extends StockTransferLineAggregateArgs> = {
        [P in keyof T & keyof AggregateStockTransferLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockTransferLine[P]>
      : GetScalarType<T[P], AggregateStockTransferLine[P]>
  }




  export type StockTransferLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockTransferLineWhereInput
    orderBy?: StockTransferLineOrderByWithAggregationInput | StockTransferLineOrderByWithAggregationInput[]
    by: StockTransferLineScalarFieldEnum[] | StockTransferLineScalarFieldEnum
    having?: StockTransferLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockTransferLineCountAggregateInputType | true
    _avg?: StockTransferLineAvgAggregateInputType
    _sum?: StockTransferLineSumAggregateInputType
    _min?: StockTransferLineMinAggregateInputType
    _max?: StockTransferLineMaxAggregateInputType
  }

  export type StockTransferLineGroupByOutputType = {
    id: string
    transferId: string
    variantId: string
    quantity: number
    received: number | null
    _count: StockTransferLineCountAggregateOutputType | null
    _avg: StockTransferLineAvgAggregateOutputType | null
    _sum: StockTransferLineSumAggregateOutputType | null
    _min: StockTransferLineMinAggregateOutputType | null
    _max: StockTransferLineMaxAggregateOutputType | null
  }

  type GetStockTransferLineGroupByPayload<T extends StockTransferLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockTransferLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockTransferLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockTransferLineGroupByOutputType[P]>
            : GetScalarType<T[P], StockTransferLineGroupByOutputType[P]>
        }
      >
    >


  export type StockTransferLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    variantId?: boolean
    quantity?: boolean
    received?: boolean
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferLine"]>

  export type StockTransferLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    variantId?: boolean
    quantity?: boolean
    received?: boolean
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferLine"]>

  export type StockTransferLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transferId?: boolean
    variantId?: boolean
    quantity?: boolean
    received?: boolean
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockTransferLine"]>

  export type StockTransferLineSelectScalar = {
    id?: boolean
    transferId?: boolean
    variantId?: boolean
    quantity?: boolean
    received?: boolean
  }

  export type StockTransferLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "transferId" | "variantId" | "quantity" | "received", ExtArgs["result"]["stockTransferLine"]>
  export type StockTransferLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type StockTransferLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type StockTransferLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfer?: boolean | StockTransferDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $StockTransferLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockTransferLine"
    objects: {
      transfer: Prisma.$StockTransferPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transferId: string
      variantId: string
      quantity: number
      received: number | null
    }, ExtArgs["result"]["stockTransferLine"]>
    composites: {}
  }

  type StockTransferLineGetPayload<S extends boolean | null | undefined | StockTransferLineDefaultArgs> = $Result.GetResult<Prisma.$StockTransferLinePayload, S>

  type StockTransferLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockTransferLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockTransferLineCountAggregateInputType | true
    }

  export interface StockTransferLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockTransferLine'], meta: { name: 'StockTransferLine' } }
    /**
     * Find zero or one StockTransferLine that matches the filter.
     * @param {StockTransferLineFindUniqueArgs} args - Arguments to find a StockTransferLine
     * @example
     * // Get one StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockTransferLineFindUniqueArgs>(args: SelectSubset<T, StockTransferLineFindUniqueArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockTransferLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockTransferLineFindUniqueOrThrowArgs} args - Arguments to find a StockTransferLine
     * @example
     * // Get one StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockTransferLineFindUniqueOrThrowArgs>(args: SelectSubset<T, StockTransferLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransferLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineFindFirstArgs} args - Arguments to find a StockTransferLine
     * @example
     * // Get one StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockTransferLineFindFirstArgs>(args?: SelectSubset<T, StockTransferLineFindFirstArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockTransferLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineFindFirstOrThrowArgs} args - Arguments to find a StockTransferLine
     * @example
     * // Get one StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockTransferLineFindFirstOrThrowArgs>(args?: SelectSubset<T, StockTransferLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockTransferLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockTransferLines
     * const stockTransferLines = await prisma.stockTransferLine.findMany()
     * 
     * // Get first 10 StockTransferLines
     * const stockTransferLines = await prisma.stockTransferLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockTransferLineWithIdOnly = await prisma.stockTransferLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockTransferLineFindManyArgs>(args?: SelectSubset<T, StockTransferLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockTransferLine.
     * @param {StockTransferLineCreateArgs} args - Arguments to create a StockTransferLine.
     * @example
     * // Create one StockTransferLine
     * const StockTransferLine = await prisma.stockTransferLine.create({
     *   data: {
     *     // ... data to create a StockTransferLine
     *   }
     * })
     * 
     */
    create<T extends StockTransferLineCreateArgs>(args: SelectSubset<T, StockTransferLineCreateArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockTransferLines.
     * @param {StockTransferLineCreateManyArgs} args - Arguments to create many StockTransferLines.
     * @example
     * // Create many StockTransferLines
     * const stockTransferLine = await prisma.stockTransferLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockTransferLineCreateManyArgs>(args?: SelectSubset<T, StockTransferLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StockTransferLines and returns the data saved in the database.
     * @param {StockTransferLineCreateManyAndReturnArgs} args - Arguments to create many StockTransferLines.
     * @example
     * // Create many StockTransferLines
     * const stockTransferLine = await prisma.stockTransferLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StockTransferLines and only return the `id`
     * const stockTransferLineWithIdOnly = await prisma.stockTransferLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StockTransferLineCreateManyAndReturnArgs>(args?: SelectSubset<T, StockTransferLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StockTransferLine.
     * @param {StockTransferLineDeleteArgs} args - Arguments to delete one StockTransferLine.
     * @example
     * // Delete one StockTransferLine
     * const StockTransferLine = await prisma.stockTransferLine.delete({
     *   where: {
     *     // ... filter to delete one StockTransferLine
     *   }
     * })
     * 
     */
    delete<T extends StockTransferLineDeleteArgs>(args: SelectSubset<T, StockTransferLineDeleteArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockTransferLine.
     * @param {StockTransferLineUpdateArgs} args - Arguments to update one StockTransferLine.
     * @example
     * // Update one StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockTransferLineUpdateArgs>(args: SelectSubset<T, StockTransferLineUpdateArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockTransferLines.
     * @param {StockTransferLineDeleteManyArgs} args - Arguments to filter StockTransferLines to delete.
     * @example
     * // Delete a few StockTransferLines
     * const { count } = await prisma.stockTransferLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockTransferLineDeleteManyArgs>(args?: SelectSubset<T, StockTransferLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockTransferLines
     * const stockTransferLine = await prisma.stockTransferLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockTransferLineUpdateManyArgs>(args: SelectSubset<T, StockTransferLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockTransferLines and returns the data updated in the database.
     * @param {StockTransferLineUpdateManyAndReturnArgs} args - Arguments to update many StockTransferLines.
     * @example
     * // Update many StockTransferLines
     * const stockTransferLine = await prisma.stockTransferLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StockTransferLines and only return the `id`
     * const stockTransferLineWithIdOnly = await prisma.stockTransferLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StockTransferLineUpdateManyAndReturnArgs>(args: SelectSubset<T, StockTransferLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StockTransferLine.
     * @param {StockTransferLineUpsertArgs} args - Arguments to update or create a StockTransferLine.
     * @example
     * // Update or create a StockTransferLine
     * const stockTransferLine = await prisma.stockTransferLine.upsert({
     *   create: {
     *     // ... data to create a StockTransferLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockTransferLine we want to update
     *   }
     * })
     */
    upsert<T extends StockTransferLineUpsertArgs>(args: SelectSubset<T, StockTransferLineUpsertArgs<ExtArgs>>): Prisma__StockTransferLineClient<$Result.GetResult<Prisma.$StockTransferLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StockTransferLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineCountArgs} args - Arguments to filter StockTransferLines to count.
     * @example
     * // Count the number of StockTransferLines
     * const count = await prisma.stockTransferLine.count({
     *   where: {
     *     // ... the filter for the StockTransferLines we want to count
     *   }
     * })
    **/
    count<T extends StockTransferLineCountArgs>(
      args?: Subset<T, StockTransferLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockTransferLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockTransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockTransferLineAggregateArgs>(args: Subset<T, StockTransferLineAggregateArgs>): Prisma.PrismaPromise<GetStockTransferLineAggregateType<T>>

    /**
     * Group by StockTransferLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockTransferLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockTransferLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockTransferLineGroupByArgs['orderBy'] }
        : { orderBy?: StockTransferLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockTransferLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockTransferLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockTransferLine model
   */
  readonly fields: StockTransferLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockTransferLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockTransferLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transfer<T extends StockTransferDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StockTransferDefaultArgs<ExtArgs>>): Prisma__StockTransferClient<$Result.GetResult<Prisma.$StockTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockTransferLine model
   */
  interface StockTransferLineFieldRefs {
    readonly id: FieldRef<"StockTransferLine", 'String'>
    readonly transferId: FieldRef<"StockTransferLine", 'String'>
    readonly variantId: FieldRef<"StockTransferLine", 'String'>
    readonly quantity: FieldRef<"StockTransferLine", 'Int'>
    readonly received: FieldRef<"StockTransferLine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StockTransferLine findUnique
   */
  export type StockTransferLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferLine to fetch.
     */
    where: StockTransferLineWhereUniqueInput
  }

  /**
   * StockTransferLine findUniqueOrThrow
   */
  export type StockTransferLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferLine to fetch.
     */
    where: StockTransferLineWhereUniqueInput
  }

  /**
   * StockTransferLine findFirst
   */
  export type StockTransferLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferLine to fetch.
     */
    where?: StockTransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferLines to fetch.
     */
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferLines.
     */
    cursor?: StockTransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferLines.
     */
    distinct?: StockTransferLineScalarFieldEnum | StockTransferLineScalarFieldEnum[]
  }

  /**
   * StockTransferLine findFirstOrThrow
   */
  export type StockTransferLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferLine to fetch.
     */
    where?: StockTransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferLines to fetch.
     */
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockTransferLines.
     */
    cursor?: StockTransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockTransferLines.
     */
    distinct?: StockTransferLineScalarFieldEnum | StockTransferLineScalarFieldEnum[]
  }

  /**
   * StockTransferLine findMany
   */
  export type StockTransferLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter, which StockTransferLines to fetch.
     */
    where?: StockTransferLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockTransferLines to fetch.
     */
    orderBy?: StockTransferLineOrderByWithRelationInput | StockTransferLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockTransferLines.
     */
    cursor?: StockTransferLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockTransferLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockTransferLines.
     */
    skip?: number
    distinct?: StockTransferLineScalarFieldEnum | StockTransferLineScalarFieldEnum[]
  }

  /**
   * StockTransferLine create
   */
  export type StockTransferLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * The data needed to create a StockTransferLine.
     */
    data: XOR<StockTransferLineCreateInput, StockTransferLineUncheckedCreateInput>
  }

  /**
   * StockTransferLine createMany
   */
  export type StockTransferLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockTransferLines.
     */
    data: StockTransferLineCreateManyInput | StockTransferLineCreateManyInput[]
  }

  /**
   * StockTransferLine createManyAndReturn
   */
  export type StockTransferLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * The data used to create many StockTransferLines.
     */
    data: StockTransferLineCreateManyInput | StockTransferLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransferLine update
   */
  export type StockTransferLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * The data needed to update a StockTransferLine.
     */
    data: XOR<StockTransferLineUpdateInput, StockTransferLineUncheckedUpdateInput>
    /**
     * Choose, which StockTransferLine to update.
     */
    where: StockTransferLineWhereUniqueInput
  }

  /**
   * StockTransferLine updateMany
   */
  export type StockTransferLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockTransferLines.
     */
    data: XOR<StockTransferLineUpdateManyMutationInput, StockTransferLineUncheckedUpdateManyInput>
    /**
     * Filter which StockTransferLines to update
     */
    where?: StockTransferLineWhereInput
    /**
     * Limit how many StockTransferLines to update.
     */
    limit?: number
  }

  /**
   * StockTransferLine updateManyAndReturn
   */
  export type StockTransferLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * The data used to update StockTransferLines.
     */
    data: XOR<StockTransferLineUpdateManyMutationInput, StockTransferLineUncheckedUpdateManyInput>
    /**
     * Filter which StockTransferLines to update
     */
    where?: StockTransferLineWhereInput
    /**
     * Limit how many StockTransferLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StockTransferLine upsert
   */
  export type StockTransferLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * The filter to search for the StockTransferLine to update in case it exists.
     */
    where: StockTransferLineWhereUniqueInput
    /**
     * In case the StockTransferLine found by the `where` argument doesn't exist, create a new StockTransferLine with this data.
     */
    create: XOR<StockTransferLineCreateInput, StockTransferLineUncheckedCreateInput>
    /**
     * In case the StockTransferLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockTransferLineUpdateInput, StockTransferLineUncheckedUpdateInput>
  }

  /**
   * StockTransferLine delete
   */
  export type StockTransferLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
    /**
     * Filter which StockTransferLine to delete.
     */
    where: StockTransferLineWhereUniqueInput
  }

  /**
   * StockTransferLine deleteMany
   */
  export type StockTransferLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockTransferLines to delete
     */
    where?: StockTransferLineWhereInput
    /**
     * Limit how many StockTransferLines to delete.
     */
    limit?: number
  }

  /**
   * StockTransferLine without action
   */
  export type StockTransferLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockTransferLine
     */
    select?: StockTransferLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockTransferLine
     */
    omit?: StockTransferLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockTransferLineInclude<ExtArgs> | null
  }


  /**
   * Model SaleOrder
   */

  export type AggregateSaleOrder = {
    _count: SaleOrderCountAggregateOutputType | null
    _avg: SaleOrderAvgAggregateOutputType | null
    _sum: SaleOrderSumAggregateOutputType | null
    _min: SaleOrderMinAggregateOutputType | null
    _max: SaleOrderMaxAggregateOutputType | null
  }

  export type SaleOrderAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    total: number | null
    syncVersion: number | null
    syncPriority: number | null
    syncAttempts: number | null
  }

  export type SaleOrderSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    total: number | null
    syncVersion: number | null
    syncPriority: number | null
    syncAttempts: number | null
  }

  export type SaleOrderMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    terminalId: string | null
    orderNumber: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    source: $Enums.OrderSource | null
    customerId: string | null
    shiftId: string | null
    userId: string | null
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    total: number | null
    completedAt: Date | null
    voidedAt: Date | null
    voidReason: string | null
    receiptPrinted: boolean | null
    receiptEmailed: boolean | null
    receiptPrintedAt: Date | null
    receiptEmailedAt: Date | null
    receiptNumber: string | null
    discountReason: string | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncPriority: number | null
    syncAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleOrderMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    terminalId: string | null
    orderNumber: string | null
    type: $Enums.OrderType | null
    status: $Enums.OrderStatus | null
    source: $Enums.OrderSource | null
    customerId: string | null
    shiftId: string | null
    userId: string | null
    subtotal: number | null
    taxAmount: number | null
    discountAmount: number | null
    total: number | null
    completedAt: Date | null
    voidedAt: Date | null
    voidReason: string | null
    receiptPrinted: boolean | null
    receiptEmailed: boolean | null
    receiptPrintedAt: Date | null
    receiptEmailedAt: Date | null
    receiptNumber: string | null
    discountReason: string | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncPriority: number | null
    syncAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleOrderCountAggregateOutputType = {
    id: number
    locationId: number
    terminalId: number
    orderNumber: number
    type: number
    status: number
    source: number
    customerId: number
    shiftId: number
    userId: number
    subtotal: number
    taxAmount: number
    discountAmount: number
    total: number
    completedAt: number
    voidedAt: number
    voidReason: number
    receiptPrinted: number
    receiptEmailed: number
    receiptPrintedAt: number
    receiptEmailedAt: number
    receiptNumber: number
    discountReason: number
    notes: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    syncPriority: number
    syncAttempts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleOrderAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    syncVersion?: true
    syncPriority?: true
    syncAttempts?: true
  }

  export type SaleOrderSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    syncVersion?: true
    syncPriority?: true
    syncAttempts?: true
  }

  export type SaleOrderMinAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    orderNumber?: true
    type?: true
    status?: true
    source?: true
    customerId?: true
    shiftId?: true
    userId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    completedAt?: true
    voidedAt?: true
    voidReason?: true
    receiptPrinted?: true
    receiptEmailed?: true
    receiptPrintedAt?: true
    receiptEmailedAt?: true
    receiptNumber?: true
    discountReason?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleOrderMaxAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    orderNumber?: true
    type?: true
    status?: true
    source?: true
    customerId?: true
    shiftId?: true
    userId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    completedAt?: true
    voidedAt?: true
    voidReason?: true
    receiptPrinted?: true
    receiptEmailed?: true
    receiptPrintedAt?: true
    receiptEmailedAt?: true
    receiptNumber?: true
    discountReason?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleOrderCountAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    orderNumber?: true
    type?: true
    status?: true
    source?: true
    customerId?: true
    shiftId?: true
    userId?: true
    subtotal?: true
    taxAmount?: true
    discountAmount?: true
    total?: true
    completedAt?: true
    voidedAt?: true
    voidReason?: true
    receiptPrinted?: true
    receiptEmailed?: true
    receiptPrintedAt?: true
    receiptEmailedAt?: true
    receiptNumber?: true
    discountReason?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleOrder to aggregate.
     */
    where?: SaleOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrders to fetch.
     */
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleOrders
    **/
    _count?: true | SaleOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleOrderMaxAggregateInputType
  }

  export type GetSaleOrderAggregateType<T extends SaleOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleOrder[P]>
      : GetScalarType<T[P], AggregateSaleOrder[P]>
  }




  export type SaleOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithAggregationInput | SaleOrderOrderByWithAggregationInput[]
    by: SaleOrderScalarFieldEnum[] | SaleOrderScalarFieldEnum
    having?: SaleOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleOrderCountAggregateInputType | true
    _avg?: SaleOrderAvgAggregateInputType
    _sum?: SaleOrderSumAggregateInputType
    _min?: SaleOrderMinAggregateInputType
    _max?: SaleOrderMaxAggregateInputType
  }

  export type SaleOrderGroupByOutputType = {
    id: string
    locationId: string
    terminalId: string | null
    orderNumber: string
    type: $Enums.OrderType
    status: $Enums.OrderStatus
    source: $Enums.OrderSource
    customerId: string | null
    shiftId: string | null
    userId: string | null
    subtotal: number
    taxAmount: number
    discountAmount: number
    total: number
    completedAt: Date | null
    voidedAt: Date | null
    voidReason: string | null
    receiptPrinted: boolean
    receiptEmailed: boolean
    receiptPrintedAt: Date | null
    receiptEmailedAt: Date | null
    receiptNumber: string | null
    discountReason: string | null
    notes: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    syncPriority: number
    syncAttempts: number
    createdAt: Date
    updatedAt: Date
    _count: SaleOrderCountAggregateOutputType | null
    _avg: SaleOrderAvgAggregateOutputType | null
    _sum: SaleOrderSumAggregateOutputType | null
    _min: SaleOrderMinAggregateOutputType | null
    _max: SaleOrderMaxAggregateOutputType | null
  }

  type GetSaleOrderGroupByPayload<T extends SaleOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleOrderGroupByOutputType[P]>
            : GetScalarType<T[P], SaleOrderGroupByOutputType[P]>
        }
      >
    >


  export type SaleOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    customerId?: boolean
    shiftId?: boolean
    userId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    completedAt?: boolean
    voidedAt?: boolean
    voidReason?: boolean
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: boolean
    receiptEmailedAt?: boolean
    receiptNumber?: boolean
    discountReason?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
    lines?: boolean | SaleOrder$linesArgs<ExtArgs>
    payments?: boolean | SaleOrder$paymentsArgs<ExtArgs>
    discounts?: boolean | SaleOrder$discountsArgs<ExtArgs>
    returnOrders?: boolean | SaleOrder$returnOrdersArgs<ExtArgs>
    parkedOrders?: boolean | SaleOrder$parkedOrdersArgs<ExtArgs>
    exchangesFrom?: boolean | SaleOrder$exchangesFromArgs<ExtArgs>
    exchangesTo?: boolean | SaleOrder$exchangesToArgs<ExtArgs>
    _count?: boolean | SaleOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrder"]>

  export type SaleOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    customerId?: boolean
    shiftId?: boolean
    userId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    completedAt?: boolean
    voidedAt?: boolean
    voidReason?: boolean
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: boolean
    receiptEmailedAt?: boolean
    receiptNumber?: boolean
    discountReason?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrder"]>

  export type SaleOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    customerId?: boolean
    shiftId?: boolean
    userId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    completedAt?: boolean
    voidedAt?: boolean
    voidReason?: boolean
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: boolean
    receiptEmailedAt?: boolean
    receiptNumber?: boolean
    discountReason?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrder"]>

  export type SaleOrderSelectScalar = {
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    orderNumber?: boolean
    type?: boolean
    status?: boolean
    source?: boolean
    customerId?: boolean
    shiftId?: boolean
    userId?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    total?: boolean
    completedAt?: boolean
    voidedAt?: boolean
    voidReason?: boolean
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: boolean
    receiptEmailedAt?: boolean
    receiptNumber?: boolean
    discountReason?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "terminalId" | "orderNumber" | "type" | "status" | "source" | "customerId" | "shiftId" | "userId" | "subtotal" | "taxAmount" | "discountAmount" | "total" | "completedAt" | "voidedAt" | "voidReason" | "receiptPrinted" | "receiptEmailed" | "receiptPrintedAt" | "receiptEmailedAt" | "receiptNumber" | "discountReason" | "notes" | "syncVersion" | "lastSyncedAt" | "isDirty" | "syncPriority" | "syncAttempts" | "createdAt" | "updatedAt", ExtArgs["result"]["saleOrder"]>
  export type SaleOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
    lines?: boolean | SaleOrder$linesArgs<ExtArgs>
    payments?: boolean | SaleOrder$paymentsArgs<ExtArgs>
    discounts?: boolean | SaleOrder$discountsArgs<ExtArgs>
    returnOrders?: boolean | SaleOrder$returnOrdersArgs<ExtArgs>
    parkedOrders?: boolean | SaleOrder$parkedOrdersArgs<ExtArgs>
    exchangesFrom?: boolean | SaleOrder$exchangesFromArgs<ExtArgs>
    exchangesTo?: boolean | SaleOrder$exchangesToArgs<ExtArgs>
    _count?: boolean | SaleOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SaleOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
  }
  export type SaleOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | SaleOrder$terminalArgs<ExtArgs>
    customer?: boolean | SaleOrder$customerArgs<ExtArgs>
    shift?: boolean | SaleOrder$shiftArgs<ExtArgs>
    user?: boolean | SaleOrder$userArgs<ExtArgs>
  }

  export type $SaleOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleOrder"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      terminal: Prisma.$TerminalPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      shift: Prisma.$ShiftPayload<ExtArgs> | null
      user: Prisma.$LocalUserPayload<ExtArgs> | null
      lines: Prisma.$SaleOrderLinePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      discounts: Prisma.$DiscountPayload<ExtArgs>[]
      returnOrders: Prisma.$ReturnOrderPayload<ExtArgs>[]
      parkedOrders: Prisma.$ParkedOrderPayload<ExtArgs>[]
      exchangesFrom: Prisma.$ExchangeOrderPayload<ExtArgs>[]
      exchangesTo: Prisma.$ExchangeOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      terminalId: string | null
      orderNumber: string
      type: $Enums.OrderType
      status: $Enums.OrderStatus
      source: $Enums.OrderSource
      customerId: string | null
      shiftId: string | null
      userId: string | null
      subtotal: number
      taxAmount: number
      discountAmount: number
      total: number
      completedAt: Date | null
      voidedAt: Date | null
      voidReason: string | null
      receiptPrinted: boolean
      receiptEmailed: boolean
      receiptPrintedAt: Date | null
      receiptEmailedAt: Date | null
      receiptNumber: string | null
      discountReason: string | null
      notes: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      syncPriority: number
      syncAttempts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleOrder"]>
    composites: {}
  }

  type SaleOrderGetPayload<S extends boolean | null | undefined | SaleOrderDefaultArgs> = $Result.GetResult<Prisma.$SaleOrderPayload, S>

  type SaleOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleOrderCountAggregateInputType | true
    }

  export interface SaleOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleOrder'], meta: { name: 'SaleOrder' } }
    /**
     * Find zero or one SaleOrder that matches the filter.
     * @param {SaleOrderFindUniqueArgs} args - Arguments to find a SaleOrder
     * @example
     * // Get one SaleOrder
     * const saleOrder = await prisma.saleOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleOrderFindUniqueArgs>(args: SelectSubset<T, SaleOrderFindUniqueArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleOrderFindUniqueOrThrowArgs} args - Arguments to find a SaleOrder
     * @example
     * // Get one SaleOrder
     * const saleOrder = await prisma.saleOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderFindFirstArgs} args - Arguments to find a SaleOrder
     * @example
     * // Get one SaleOrder
     * const saleOrder = await prisma.saleOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleOrderFindFirstArgs>(args?: SelectSubset<T, SaleOrderFindFirstArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderFindFirstOrThrowArgs} args - Arguments to find a SaleOrder
     * @example
     * // Get one SaleOrder
     * const saleOrder = await prisma.saleOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleOrders
     * const saleOrders = await prisma.saleOrder.findMany()
     * 
     * // Get first 10 SaleOrders
     * const saleOrders = await prisma.saleOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleOrderWithIdOnly = await prisma.saleOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleOrderFindManyArgs>(args?: SelectSubset<T, SaleOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleOrder.
     * @param {SaleOrderCreateArgs} args - Arguments to create a SaleOrder.
     * @example
     * // Create one SaleOrder
     * const SaleOrder = await prisma.saleOrder.create({
     *   data: {
     *     // ... data to create a SaleOrder
     *   }
     * })
     * 
     */
    create<T extends SaleOrderCreateArgs>(args: SelectSubset<T, SaleOrderCreateArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleOrders.
     * @param {SaleOrderCreateManyArgs} args - Arguments to create many SaleOrders.
     * @example
     * // Create many SaleOrders
     * const saleOrder = await prisma.saleOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleOrderCreateManyArgs>(args?: SelectSubset<T, SaleOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleOrders and returns the data saved in the database.
     * @param {SaleOrderCreateManyAndReturnArgs} args - Arguments to create many SaleOrders.
     * @example
     * // Create many SaleOrders
     * const saleOrder = await prisma.saleOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleOrders and only return the `id`
     * const saleOrderWithIdOnly = await prisma.saleOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleOrder.
     * @param {SaleOrderDeleteArgs} args - Arguments to delete one SaleOrder.
     * @example
     * // Delete one SaleOrder
     * const SaleOrder = await prisma.saleOrder.delete({
     *   where: {
     *     // ... filter to delete one SaleOrder
     *   }
     * })
     * 
     */
    delete<T extends SaleOrderDeleteArgs>(args: SelectSubset<T, SaleOrderDeleteArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleOrder.
     * @param {SaleOrderUpdateArgs} args - Arguments to update one SaleOrder.
     * @example
     * // Update one SaleOrder
     * const saleOrder = await prisma.saleOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleOrderUpdateArgs>(args: SelectSubset<T, SaleOrderUpdateArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleOrders.
     * @param {SaleOrderDeleteManyArgs} args - Arguments to filter SaleOrders to delete.
     * @example
     * // Delete a few SaleOrders
     * const { count } = await prisma.saleOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleOrderDeleteManyArgs>(args?: SelectSubset<T, SaleOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleOrders
     * const saleOrder = await prisma.saleOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleOrderUpdateManyArgs>(args: SelectSubset<T, SaleOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleOrders and returns the data updated in the database.
     * @param {SaleOrderUpdateManyAndReturnArgs} args - Arguments to update many SaleOrders.
     * @example
     * // Update many SaleOrders
     * const saleOrder = await prisma.saleOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleOrders and only return the `id`
     * const saleOrderWithIdOnly = await prisma.saleOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleOrder.
     * @param {SaleOrderUpsertArgs} args - Arguments to update or create a SaleOrder.
     * @example
     * // Update or create a SaleOrder
     * const saleOrder = await prisma.saleOrder.upsert({
     *   create: {
     *     // ... data to create a SaleOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleOrder we want to update
     *   }
     * })
     */
    upsert<T extends SaleOrderUpsertArgs>(args: SelectSubset<T, SaleOrderUpsertArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderCountArgs} args - Arguments to filter SaleOrders to count.
     * @example
     * // Count the number of SaleOrders
     * const count = await prisma.saleOrder.count({
     *   where: {
     *     // ... the filter for the SaleOrders we want to count
     *   }
     * })
    **/
    count<T extends SaleOrderCountArgs>(
      args?: Subset<T, SaleOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleOrderAggregateArgs>(args: Subset<T, SaleOrderAggregateArgs>): Prisma.PrismaPromise<GetSaleOrderAggregateType<T>>

    /**
     * Group by SaleOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleOrderGroupByArgs['orderBy'] }
        : { orderBy?: SaleOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleOrder model
   */
  readonly fields: SaleOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    terminal<T extends SaleOrder$terminalArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$terminalArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends SaleOrder$customerArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shift<T extends SaleOrder$shiftArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends SaleOrder$userArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$userArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lines<T extends SaleOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends SaleOrder$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discounts<T extends SaleOrder$discountsArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnOrders<T extends SaleOrder$returnOrdersArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$returnOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parkedOrders<T extends SaleOrder$parkedOrdersArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$parkedOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangesFrom<T extends SaleOrder$exchangesFromArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$exchangesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exchangesTo<T extends SaleOrder$exchangesToArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrder$exchangesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleOrder model
   */
  interface SaleOrderFieldRefs {
    readonly id: FieldRef<"SaleOrder", 'String'>
    readonly locationId: FieldRef<"SaleOrder", 'String'>
    readonly terminalId: FieldRef<"SaleOrder", 'String'>
    readonly orderNumber: FieldRef<"SaleOrder", 'String'>
    readonly type: FieldRef<"SaleOrder", 'OrderType'>
    readonly status: FieldRef<"SaleOrder", 'OrderStatus'>
    readonly source: FieldRef<"SaleOrder", 'OrderSource'>
    readonly customerId: FieldRef<"SaleOrder", 'String'>
    readonly shiftId: FieldRef<"SaleOrder", 'String'>
    readonly userId: FieldRef<"SaleOrder", 'String'>
    readonly subtotal: FieldRef<"SaleOrder", 'Float'>
    readonly taxAmount: FieldRef<"SaleOrder", 'Float'>
    readonly discountAmount: FieldRef<"SaleOrder", 'Float'>
    readonly total: FieldRef<"SaleOrder", 'Float'>
    readonly completedAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly voidedAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly voidReason: FieldRef<"SaleOrder", 'String'>
    readonly receiptPrinted: FieldRef<"SaleOrder", 'Boolean'>
    readonly receiptEmailed: FieldRef<"SaleOrder", 'Boolean'>
    readonly receiptPrintedAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly receiptEmailedAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly receiptNumber: FieldRef<"SaleOrder", 'String'>
    readonly discountReason: FieldRef<"SaleOrder", 'String'>
    readonly notes: FieldRef<"SaleOrder", 'String'>
    readonly syncVersion: FieldRef<"SaleOrder", 'Int'>
    readonly lastSyncedAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly isDirty: FieldRef<"SaleOrder", 'Boolean'>
    readonly syncPriority: FieldRef<"SaleOrder", 'Int'>
    readonly syncAttempts: FieldRef<"SaleOrder", 'Int'>
    readonly createdAt: FieldRef<"SaleOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleOrder findUnique
   */
  export type SaleOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrder to fetch.
     */
    where: SaleOrderWhereUniqueInput
  }

  /**
   * SaleOrder findUniqueOrThrow
   */
  export type SaleOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrder to fetch.
     */
    where: SaleOrderWhereUniqueInput
  }

  /**
   * SaleOrder findFirst
   */
  export type SaleOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrder to fetch.
     */
    where?: SaleOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrders to fetch.
     */
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleOrders.
     */
    cursor?: SaleOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleOrders.
     */
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder findFirstOrThrow
   */
  export type SaleOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrder to fetch.
     */
    where?: SaleOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrders to fetch.
     */
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleOrders.
     */
    cursor?: SaleOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleOrders.
     */
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder findMany
   */
  export type SaleOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrders to fetch.
     */
    where?: SaleOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrders to fetch.
     */
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleOrders.
     */
    cursor?: SaleOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrders.
     */
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder create
   */
  export type SaleOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleOrder.
     */
    data: XOR<SaleOrderCreateInput, SaleOrderUncheckedCreateInput>
  }

  /**
   * SaleOrder createMany
   */
  export type SaleOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleOrders.
     */
    data: SaleOrderCreateManyInput | SaleOrderCreateManyInput[]
  }

  /**
   * SaleOrder createManyAndReturn
   */
  export type SaleOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * The data used to create many SaleOrders.
     */
    data: SaleOrderCreateManyInput | SaleOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleOrder update
   */
  export type SaleOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleOrder.
     */
    data: XOR<SaleOrderUpdateInput, SaleOrderUncheckedUpdateInput>
    /**
     * Choose, which SaleOrder to update.
     */
    where: SaleOrderWhereUniqueInput
  }

  /**
   * SaleOrder updateMany
   */
  export type SaleOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleOrders.
     */
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyInput>
    /**
     * Filter which SaleOrders to update
     */
    where?: SaleOrderWhereInput
    /**
     * Limit how many SaleOrders to update.
     */
    limit?: number
  }

  /**
   * SaleOrder updateManyAndReturn
   */
  export type SaleOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * The data used to update SaleOrders.
     */
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyInput>
    /**
     * Filter which SaleOrders to update
     */
    where?: SaleOrderWhereInput
    /**
     * Limit how many SaleOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleOrder upsert
   */
  export type SaleOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleOrder to update in case it exists.
     */
    where: SaleOrderWhereUniqueInput
    /**
     * In case the SaleOrder found by the `where` argument doesn't exist, create a new SaleOrder with this data.
     */
    create: XOR<SaleOrderCreateInput, SaleOrderUncheckedCreateInput>
    /**
     * In case the SaleOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleOrderUpdateInput, SaleOrderUncheckedUpdateInput>
  }

  /**
   * SaleOrder delete
   */
  export type SaleOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    /**
     * Filter which SaleOrder to delete.
     */
    where: SaleOrderWhereUniqueInput
  }

  /**
   * SaleOrder deleteMany
   */
  export type SaleOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleOrders to delete
     */
    where?: SaleOrderWhereInput
    /**
     * Limit how many SaleOrders to delete.
     */
    limit?: number
  }

  /**
   * SaleOrder.terminal
   */
  export type SaleOrder$terminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    where?: TerminalWhereInput
  }

  /**
   * SaleOrder.customer
   */
  export type SaleOrder$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SaleOrder.shift
   */
  export type SaleOrder$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * SaleOrder.user
   */
  export type SaleOrder$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalUser
     */
    select?: LocalUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalUser
     */
    omit?: LocalUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocalUserInclude<ExtArgs> | null
    where?: LocalUserWhereInput
  }

  /**
   * SaleOrder.lines
   */
  export type SaleOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    where?: SaleOrderLineWhereInput
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    cursor?: SaleOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderLineScalarFieldEnum | SaleOrderLineScalarFieldEnum[]
  }

  /**
   * SaleOrder.payments
   */
  export type SaleOrder$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * SaleOrder.discounts
   */
  export type SaleOrder$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    cursor?: DiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * SaleOrder.returnOrders
   */
  export type SaleOrder$returnOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    where?: ReturnOrderWhereInput
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    cursor?: ReturnOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder.parkedOrders
   */
  export type SaleOrder$parkedOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    where?: ParkedOrderWhereInput
    orderBy?: ParkedOrderOrderByWithRelationInput | ParkedOrderOrderByWithRelationInput[]
    cursor?: ParkedOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParkedOrderScalarFieldEnum | ParkedOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder.exchangesFrom
   */
  export type SaleOrder$exchangesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    where?: ExchangeOrderWhereInput
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    cursor?: ExchangeOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeOrderScalarFieldEnum | ExchangeOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder.exchangesTo
   */
  export type SaleOrder$exchangesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    where?: ExchangeOrderWhereInput
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    cursor?: ExchangeOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeOrderScalarFieldEnum | ExchangeOrderScalarFieldEnum[]
  }

  /**
   * SaleOrder without action
   */
  export type SaleOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
  }


  /**
   * Model SaleOrderLine
   */

  export type AggregateSaleOrderLine = {
    _count: SaleOrderLineCountAggregateOutputType | null
    _avg: SaleOrderLineAvgAggregateOutputType | null
    _sum: SaleOrderLineSumAggregateOutputType | null
    _min: SaleOrderLineMinAggregateOutputType | null
    _max: SaleOrderLineMaxAggregateOutputType | null
  }

  export type SaleOrderLineAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    lineTotal: number | null
    syncVersion: number | null
  }

  export type SaleOrderLineSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    lineTotal: number | null
    syncVersion: number | null
  }

  export type SaleOrderLineMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    variantId: string | null
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    lineTotal: number | null
    notes: string | null
    syncVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleOrderLineMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    variantId: string | null
    quantity: number | null
    unitPrice: number | null
    discountAmount: number | null
    taxAmount: number | null
    lineTotal: number | null
    notes: string | null
    syncVersion: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleOrderLineCountAggregateOutputType = {
    id: number
    orderId: number
    variantId: number
    quantity: number
    unitPrice: number
    discountAmount: number
    taxAmount: number
    lineTotal: number
    notes: number
    syncVersion: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleOrderLineAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    lineTotal?: true
    syncVersion?: true
  }

  export type SaleOrderLineSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    lineTotal?: true
    syncVersion?: true
  }

  export type SaleOrderLineMinAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    lineTotal?: true
    notes?: true
    syncVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleOrderLineMaxAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    lineTotal?: true
    notes?: true
    syncVersion?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleOrderLineCountAggregateInputType = {
    id?: true
    orderId?: true
    variantId?: true
    quantity?: true
    unitPrice?: true
    discountAmount?: true
    taxAmount?: true
    lineTotal?: true
    notes?: true
    syncVersion?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleOrderLine to aggregate.
     */
    where?: SaleOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrderLines to fetch.
     */
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleOrderLines
    **/
    _count?: true | SaleOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleOrderLineMaxAggregateInputType
  }

  export type GetSaleOrderLineAggregateType<T extends SaleOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleOrderLine[P]>
      : GetScalarType<T[P], AggregateSaleOrderLine[P]>
  }




  export type SaleOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleOrderLineWhereInput
    orderBy?: SaleOrderLineOrderByWithAggregationInput | SaleOrderLineOrderByWithAggregationInput[]
    by: SaleOrderLineScalarFieldEnum[] | SaleOrderLineScalarFieldEnum
    having?: SaleOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleOrderLineCountAggregateInputType | true
    _avg?: SaleOrderLineAvgAggregateInputType
    _sum?: SaleOrderLineSumAggregateInputType
    _min?: SaleOrderLineMinAggregateInputType
    _max?: SaleOrderLineMaxAggregateInputType
  }

  export type SaleOrderLineGroupByOutputType = {
    id: string
    orderId: string
    variantId: string
    quantity: number
    unitPrice: number
    discountAmount: number
    taxAmount: number
    lineTotal: number
    notes: string | null
    syncVersion: number
    createdAt: Date
    updatedAt: Date
    _count: SaleOrderLineCountAggregateOutputType | null
    _avg: SaleOrderLineAvgAggregateOutputType | null
    _sum: SaleOrderLineSumAggregateOutputType | null
    _min: SaleOrderLineMinAggregateOutputType | null
    _max: SaleOrderLineMaxAggregateOutputType | null
  }

  type GetSaleOrderLineGroupByPayload<T extends SaleOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], SaleOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type SaleOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    lineTotal?: boolean
    notes?: boolean
    syncVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrderLine"]>

  export type SaleOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    lineTotal?: boolean
    notes?: boolean
    syncVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrderLine"]>

  export type SaleOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    lineTotal?: boolean
    notes?: boolean
    syncVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleOrderLine"]>

  export type SaleOrderLineSelectScalar = {
    id?: boolean
    orderId?: boolean
    variantId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    discountAmount?: boolean
    taxAmount?: boolean
    lineTotal?: boolean
    notes?: boolean
    syncVersion?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "variantId" | "quantity" | "unitPrice" | "discountAmount" | "taxAmount" | "lineTotal" | "notes" | "syncVersion" | "createdAt" | "updatedAt", ExtArgs["result"]["saleOrderLine"]>
  export type SaleOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type SaleOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type SaleOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $SaleOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleOrderLine"
    objects: {
      order: Prisma.$SaleOrderPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      variantId: string
      quantity: number
      unitPrice: number
      discountAmount: number
      taxAmount: number
      lineTotal: number
      notes: string | null
      syncVersion: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["saleOrderLine"]>
    composites: {}
  }

  type SaleOrderLineGetPayload<S extends boolean | null | undefined | SaleOrderLineDefaultArgs> = $Result.GetResult<Prisma.$SaleOrderLinePayload, S>

  type SaleOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleOrderLineCountAggregateInputType | true
    }

  export interface SaleOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleOrderLine'], meta: { name: 'SaleOrderLine' } }
    /**
     * Find zero or one SaleOrderLine that matches the filter.
     * @param {SaleOrderLineFindUniqueArgs} args - Arguments to find a SaleOrderLine
     * @example
     * // Get one SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleOrderLineFindUniqueArgs>(args: SelectSubset<T, SaleOrderLineFindUniqueArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleOrderLineFindUniqueOrThrowArgs} args - Arguments to find a SaleOrderLine
     * @example
     * // Get one SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineFindFirstArgs} args - Arguments to find a SaleOrderLine
     * @example
     * // Get one SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleOrderLineFindFirstArgs>(args?: SelectSubset<T, SaleOrderLineFindFirstArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineFindFirstOrThrowArgs} args - Arguments to find a SaleOrderLine
     * @example
     * // Get one SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleOrderLines
     * const saleOrderLines = await prisma.saleOrderLine.findMany()
     * 
     * // Get first 10 SaleOrderLines
     * const saleOrderLines = await prisma.saleOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleOrderLineWithIdOnly = await prisma.saleOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleOrderLineFindManyArgs>(args?: SelectSubset<T, SaleOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleOrderLine.
     * @param {SaleOrderLineCreateArgs} args - Arguments to create a SaleOrderLine.
     * @example
     * // Create one SaleOrderLine
     * const SaleOrderLine = await prisma.saleOrderLine.create({
     *   data: {
     *     // ... data to create a SaleOrderLine
     *   }
     * })
     * 
     */
    create<T extends SaleOrderLineCreateArgs>(args: SelectSubset<T, SaleOrderLineCreateArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleOrderLines.
     * @param {SaleOrderLineCreateManyArgs} args - Arguments to create many SaleOrderLines.
     * @example
     * // Create many SaleOrderLines
     * const saleOrderLine = await prisma.saleOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleOrderLineCreateManyArgs>(args?: SelectSubset<T, SaleOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleOrderLines and returns the data saved in the database.
     * @param {SaleOrderLineCreateManyAndReturnArgs} args - Arguments to create many SaleOrderLines.
     * @example
     * // Create many SaleOrderLines
     * const saleOrderLine = await prisma.saleOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleOrderLines and only return the `id`
     * const saleOrderLineWithIdOnly = await prisma.saleOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleOrderLine.
     * @param {SaleOrderLineDeleteArgs} args - Arguments to delete one SaleOrderLine.
     * @example
     * // Delete one SaleOrderLine
     * const SaleOrderLine = await prisma.saleOrderLine.delete({
     *   where: {
     *     // ... filter to delete one SaleOrderLine
     *   }
     * })
     * 
     */
    delete<T extends SaleOrderLineDeleteArgs>(args: SelectSubset<T, SaleOrderLineDeleteArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleOrderLine.
     * @param {SaleOrderLineUpdateArgs} args - Arguments to update one SaleOrderLine.
     * @example
     * // Update one SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleOrderLineUpdateArgs>(args: SelectSubset<T, SaleOrderLineUpdateArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleOrderLines.
     * @param {SaleOrderLineDeleteManyArgs} args - Arguments to filter SaleOrderLines to delete.
     * @example
     * // Delete a few SaleOrderLines
     * const { count } = await prisma.saleOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleOrderLineDeleteManyArgs>(args?: SelectSubset<T, SaleOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleOrderLines
     * const saleOrderLine = await prisma.saleOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleOrderLineUpdateManyArgs>(args: SelectSubset<T, SaleOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleOrderLines and returns the data updated in the database.
     * @param {SaleOrderLineUpdateManyAndReturnArgs} args - Arguments to update many SaleOrderLines.
     * @example
     * // Update many SaleOrderLines
     * const saleOrderLine = await prisma.saleOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleOrderLines and only return the `id`
     * const saleOrderLineWithIdOnly = await prisma.saleOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleOrderLine.
     * @param {SaleOrderLineUpsertArgs} args - Arguments to update or create a SaleOrderLine.
     * @example
     * // Update or create a SaleOrderLine
     * const saleOrderLine = await prisma.saleOrderLine.upsert({
     *   create: {
     *     // ... data to create a SaleOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends SaleOrderLineUpsertArgs>(args: SelectSubset<T, SaleOrderLineUpsertArgs<ExtArgs>>): Prisma__SaleOrderLineClient<$Result.GetResult<Prisma.$SaleOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineCountArgs} args - Arguments to filter SaleOrderLines to count.
     * @example
     * // Count the number of SaleOrderLines
     * const count = await prisma.saleOrderLine.count({
     *   where: {
     *     // ... the filter for the SaleOrderLines we want to count
     *   }
     * })
    **/
    count<T extends SaleOrderLineCountArgs>(
      args?: Subset<T, SaleOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleOrderLineAggregateArgs>(args: Subset<T, SaleOrderLineAggregateArgs>): Prisma.PrismaPromise<GetSaleOrderLineAggregateType<T>>

    /**
     * Group by SaleOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: SaleOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleOrderLine model
   */
  readonly fields: SaleOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleOrderLine model
   */
  interface SaleOrderLineFieldRefs {
    readonly id: FieldRef<"SaleOrderLine", 'String'>
    readonly orderId: FieldRef<"SaleOrderLine", 'String'>
    readonly variantId: FieldRef<"SaleOrderLine", 'String'>
    readonly quantity: FieldRef<"SaleOrderLine", 'Int'>
    readonly unitPrice: FieldRef<"SaleOrderLine", 'Float'>
    readonly discountAmount: FieldRef<"SaleOrderLine", 'Float'>
    readonly taxAmount: FieldRef<"SaleOrderLine", 'Float'>
    readonly lineTotal: FieldRef<"SaleOrderLine", 'Float'>
    readonly notes: FieldRef<"SaleOrderLine", 'String'>
    readonly syncVersion: FieldRef<"SaleOrderLine", 'Int'>
    readonly createdAt: FieldRef<"SaleOrderLine", 'DateTime'>
    readonly updatedAt: FieldRef<"SaleOrderLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SaleOrderLine findUnique
   */
  export type SaleOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrderLine to fetch.
     */
    where: SaleOrderLineWhereUniqueInput
  }

  /**
   * SaleOrderLine findUniqueOrThrow
   */
  export type SaleOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrderLine to fetch.
     */
    where: SaleOrderLineWhereUniqueInput
  }

  /**
   * SaleOrderLine findFirst
   */
  export type SaleOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrderLine to fetch.
     */
    where?: SaleOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrderLines to fetch.
     */
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleOrderLines.
     */
    cursor?: SaleOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleOrderLines.
     */
    distinct?: SaleOrderLineScalarFieldEnum | SaleOrderLineScalarFieldEnum[]
  }

  /**
   * SaleOrderLine findFirstOrThrow
   */
  export type SaleOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrderLine to fetch.
     */
    where?: SaleOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrderLines to fetch.
     */
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleOrderLines.
     */
    cursor?: SaleOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleOrderLines.
     */
    distinct?: SaleOrderLineScalarFieldEnum | SaleOrderLineScalarFieldEnum[]
  }

  /**
   * SaleOrderLine findMany
   */
  export type SaleOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which SaleOrderLines to fetch.
     */
    where?: SaleOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleOrderLines to fetch.
     */
    orderBy?: SaleOrderLineOrderByWithRelationInput | SaleOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleOrderLines.
     */
    cursor?: SaleOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleOrderLines.
     */
    skip?: number
    distinct?: SaleOrderLineScalarFieldEnum | SaleOrderLineScalarFieldEnum[]
  }

  /**
   * SaleOrderLine create
   */
  export type SaleOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleOrderLine.
     */
    data: XOR<SaleOrderLineCreateInput, SaleOrderLineUncheckedCreateInput>
  }

  /**
   * SaleOrderLine createMany
   */
  export type SaleOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleOrderLines.
     */
    data: SaleOrderLineCreateManyInput | SaleOrderLineCreateManyInput[]
  }

  /**
   * SaleOrderLine createManyAndReturn
   */
  export type SaleOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many SaleOrderLines.
     */
    data: SaleOrderLineCreateManyInput | SaleOrderLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleOrderLine update
   */
  export type SaleOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleOrderLine.
     */
    data: XOR<SaleOrderLineUpdateInput, SaleOrderLineUncheckedUpdateInput>
    /**
     * Choose, which SaleOrderLine to update.
     */
    where: SaleOrderLineWhereUniqueInput
  }

  /**
   * SaleOrderLine updateMany
   */
  export type SaleOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleOrderLines.
     */
    data: XOR<SaleOrderLineUpdateManyMutationInput, SaleOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SaleOrderLines to update
     */
    where?: SaleOrderLineWhereInput
    /**
     * Limit how many SaleOrderLines to update.
     */
    limit?: number
  }

  /**
   * SaleOrderLine updateManyAndReturn
   */
  export type SaleOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update SaleOrderLines.
     */
    data: XOR<SaleOrderLineUpdateManyMutationInput, SaleOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which SaleOrderLines to update
     */
    where?: SaleOrderLineWhereInput
    /**
     * Limit how many SaleOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleOrderLine upsert
   */
  export type SaleOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleOrderLine to update in case it exists.
     */
    where: SaleOrderLineWhereUniqueInput
    /**
     * In case the SaleOrderLine found by the `where` argument doesn't exist, create a new SaleOrderLine with this data.
     */
    create: XOR<SaleOrderLineCreateInput, SaleOrderLineUncheckedCreateInput>
    /**
     * In case the SaleOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleOrderLineUpdateInput, SaleOrderLineUncheckedUpdateInput>
  }

  /**
   * SaleOrderLine delete
   */
  export type SaleOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
    /**
     * Filter which SaleOrderLine to delete.
     */
    where: SaleOrderLineWhereUniqueInput
  }

  /**
   * SaleOrderLine deleteMany
   */
  export type SaleOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleOrderLines to delete
     */
    where?: SaleOrderLineWhereInput
    /**
     * Limit how many SaleOrderLines to delete.
     */
    limit?: number
  }

  /**
   * SaleOrderLine without action
   */
  export type SaleOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrderLine
     */
    select?: SaleOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrderLine
     */
    omit?: SaleOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    syncVersion: number | null
    syncPriority: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    syncVersion: number | null
    syncPriority: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    currency: string | null
    reference: string | null
    cardLast4: string | null
    cardBrand: string | null
    authCode: string | null
    status: $Enums.PaymentStatus | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncPriority: number | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    currency: string | null
    reference: string | null
    cardLast4: string | null
    cardBrand: string | null
    authCode: string | null
    status: $Enums.PaymentStatus | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncPriority: number | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    method: number
    amount: number
    currency: number
    reference: number
    cardLast4: number
    cardBrand: number
    authCode: number
    status: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    syncPriority: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    syncVersion?: true
    syncPriority?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    syncVersion?: true
    syncPriority?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    method?: true
    amount?: true
    currency?: true
    reference?: true
    cardLast4?: true
    cardBrand?: true
    authCode?: true
    status?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    method?: true
    amount?: true
    currency?: true
    reference?: true
    cardLast4?: true
    cardBrand?: true
    authCode?: true
    status?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    method?: true
    amount?: true
    currency?: true
    reference?: true
    cardLast4?: true
    cardBrand?: true
    authCode?: true
    status?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncPriority?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    orderId: string
    method: $Enums.PaymentMethod
    amount: number
    currency: string
    reference: string | null
    cardLast4: string | null
    cardBrand: string | null
    authCode: string | null
    status: $Enums.PaymentStatus
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    syncPriority: number
    processedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    method?: boolean
    amount?: boolean
    currency?: boolean
    reference?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    authCode?: boolean
    status?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    method?: boolean
    amount?: boolean
    currency?: boolean
    reference?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    authCode?: boolean
    status?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    method?: boolean
    amount?: boolean
    currency?: boolean
    reference?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    authCode?: boolean
    status?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    method?: boolean
    amount?: boolean
    currency?: boolean
    reference?: boolean
    cardLast4?: boolean
    cardBrand?: boolean
    authCode?: boolean
    status?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncPriority?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "method" | "amount" | "currency" | "reference" | "cardLast4" | "cardBrand" | "authCode" | "status" | "syncVersion" | "lastSyncedAt" | "isDirty" | "syncPriority" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$SaleOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      method: $Enums.PaymentMethod
      amount: number
      currency: string
      reference: string | null
      cardLast4: string | null
      cardBrand: string | null
      authCode: string | null
      status: $Enums.PaymentStatus
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      syncPriority: number
      processedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly orderId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly reference: FieldRef<"Payment", 'String'>
    readonly cardLast4: FieldRef<"Payment", 'String'>
    readonly cardBrand: FieldRef<"Payment", 'String'>
    readonly authCode: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly syncVersion: FieldRef<"Payment", 'Int'>
    readonly lastSyncedAt: FieldRef<"Payment", 'DateTime'>
    readonly isDirty: FieldRef<"Payment", 'Boolean'>
    readonly syncPriority: FieldRef<"Payment", 'Int'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    amount: number | null
    percent: number | null
    syncVersion: number | null
  }

  export type DiscountSumAggregateOutputType = {
    amount: number | null
    percent: number | null
    syncVersion: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    type: $Enums.DiscountType | null
    name: string | null
    code: string | null
    amount: number | null
    percent: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    type: $Enums.DiscountType | null
    name: string | null
    code: string | null
    amount: number | null
    percent: number | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    orderId: number
    type: number
    name: number
    code: number
    amount: number
    percent: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    createdAt: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    amount?: true
    percent?: true
    syncVersion?: true
  }

  export type DiscountSumAggregateInputType = {
    amount?: true
    percent?: true
    syncVersion?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    code?: true
    amount?: true
    percent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    code?: true
    amount?: true
    percent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    orderId?: true
    type?: true
    name?: true
    code?: true
    amount?: true
    percent?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    orderId: string
    type: $Enums.DiscountType
    name: string
    code: string | null
    amount: number
    percent: number | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    createdAt: Date
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    amount?: boolean
    percent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    amount?: boolean
    percent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    amount?: boolean
    percent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    orderId?: boolean
    type?: boolean
    name?: boolean
    code?: boolean
    amount?: boolean
    percent?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "type" | "name" | "code" | "amount" | "percent" | "syncVersion" | "lastSyncedAt" | "isDirty" | "createdAt", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      order: Prisma.$SaleOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      type: $Enums.DiscountType
      name: string
      code: string | null
      amount: number
      percent: number | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      createdAt: Date
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly orderId: FieldRef<"Discount", 'String'>
    readonly type: FieldRef<"Discount", 'DiscountType'>
    readonly name: FieldRef<"Discount", 'String'>
    readonly code: FieldRef<"Discount", 'String'>
    readonly amount: FieldRef<"Discount", 'Float'>
    readonly percent: FieldRef<"Discount", 'Float'>
    readonly syncVersion: FieldRef<"Discount", 'Int'>
    readonly lastSyncedAt: FieldRef<"Discount", 'DateTime'>
    readonly isDirty: FieldRef<"Discount", 'Boolean'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model ReturnOrder
   */

  export type AggregateReturnOrder = {
    _count: ReturnOrderCountAggregateOutputType | null
    _avg: ReturnOrderAvgAggregateOutputType | null
    _sum: ReturnOrderSumAggregateOutputType | null
    _min: ReturnOrderMinAggregateOutputType | null
    _max: ReturnOrderMaxAggregateOutputType | null
  }

  export type ReturnOrderAvgAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    total: number | null
    refundAmount: number | null
    syncVersion: number | null
    syncAttempts: number | null
  }

  export type ReturnOrderSumAggregateOutputType = {
    subtotal: number | null
    taxAmount: number | null
    total: number | null
    refundAmount: number | null
    syncVersion: number | null
    syncAttempts: number | null
  }

  export type ReturnOrderMinAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    originalOrderId: string | null
    customerId: string | null
    locationId: string | null
    reason: $Enums.ReturnReason | null
    notes: string | null
    subtotal: number | null
    taxAmount: number | null
    total: number | null
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number | null
    status: $Enums.ReturnStatus | null
    processedBy: string | null
    processedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnOrderMaxAggregateOutputType = {
    id: string | null
    returnNumber: string | null
    originalOrderId: string | null
    customerId: string | null
    locationId: string | null
    reason: $Enums.ReturnReason | null
    notes: string | null
    subtotal: number | null
    taxAmount: number | null
    total: number | null
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number | null
    status: $Enums.ReturnStatus | null
    processedBy: string | null
    processedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    syncAttempts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReturnOrderCountAggregateOutputType = {
    id: number
    returnNumber: number
    originalOrderId: number
    customerId: number
    locationId: number
    reason: number
    notes: number
    subtotal: number
    taxAmount: number
    total: number
    refundMethod: number
    refundAmount: number
    status: number
    processedBy: number
    processedAt: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    syncAttempts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReturnOrderAvgAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    total?: true
    refundAmount?: true
    syncVersion?: true
    syncAttempts?: true
  }

  export type ReturnOrderSumAggregateInputType = {
    subtotal?: true
    taxAmount?: true
    total?: true
    refundAmount?: true
    syncVersion?: true
    syncAttempts?: true
  }

  export type ReturnOrderMinAggregateInputType = {
    id?: true
    returnNumber?: true
    originalOrderId?: true
    customerId?: true
    locationId?: true
    reason?: true
    notes?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    refundMethod?: true
    refundAmount?: true
    status?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnOrderMaxAggregateInputType = {
    id?: true
    returnNumber?: true
    originalOrderId?: true
    customerId?: true
    locationId?: true
    reason?: true
    notes?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    refundMethod?: true
    refundAmount?: true
    status?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReturnOrderCountAggregateInputType = {
    id?: true
    returnNumber?: true
    originalOrderId?: true
    customerId?: true
    locationId?: true
    reason?: true
    notes?: true
    subtotal?: true
    taxAmount?: true
    total?: true
    refundMethod?: true
    refundAmount?: true
    status?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    syncAttempts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReturnOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnOrder to aggregate.
     */
    where?: ReturnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrders to fetch.
     */
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnOrders
    **/
    _count?: true | ReturnOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnOrderMaxAggregateInputType
  }

  export type GetReturnOrderAggregateType<T extends ReturnOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnOrder[P]>
      : GetScalarType<T[P], AggregateReturnOrder[P]>
  }




  export type ReturnOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderWhereInput
    orderBy?: ReturnOrderOrderByWithAggregationInput | ReturnOrderOrderByWithAggregationInput[]
    by: ReturnOrderScalarFieldEnum[] | ReturnOrderScalarFieldEnum
    having?: ReturnOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnOrderCountAggregateInputType | true
    _avg?: ReturnOrderAvgAggregateInputType
    _sum?: ReturnOrderSumAggregateInputType
    _min?: ReturnOrderMinAggregateInputType
    _max?: ReturnOrderMaxAggregateInputType
  }

  export type ReturnOrderGroupByOutputType = {
    id: string
    returnNumber: string
    originalOrderId: string
    customerId: string | null
    locationId: string
    reason: $Enums.ReturnReason | null
    notes: string | null
    subtotal: number
    taxAmount: number
    total: number
    refundMethod: $Enums.RefundMethod | null
    refundAmount: number
    status: $Enums.ReturnStatus
    processedBy: string | null
    processedAt: Date | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    syncAttempts: number
    createdAt: Date
    updatedAt: Date
    _count: ReturnOrderCountAggregateOutputType | null
    _avg: ReturnOrderAvgAggregateOutputType | null
    _sum: ReturnOrderSumAggregateOutputType | null
    _min: ReturnOrderMinAggregateOutputType | null
    _max: ReturnOrderMaxAggregateOutputType | null
  }

  type GetReturnOrderGroupByPayload<T extends ReturnOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnOrderGroupByOutputType[P]>
        }
      >
    >


  export type ReturnOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    originalOrderId?: boolean
    customerId?: boolean
    locationId?: boolean
    reason?: boolean
    notes?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    lines?: boolean | ReturnOrder$linesArgs<ExtArgs>
    _count?: boolean | ReturnOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrder"]>

  export type ReturnOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    originalOrderId?: boolean
    customerId?: boolean
    locationId?: boolean
    reason?: boolean
    notes?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrder"]>

  export type ReturnOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnNumber?: boolean
    originalOrderId?: boolean
    customerId?: boolean
    locationId?: boolean
    reason?: boolean
    notes?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrder"]>

  export type ReturnOrderSelectScalar = {
    id?: boolean
    returnNumber?: boolean
    originalOrderId?: boolean
    customerId?: boolean
    locationId?: boolean
    reason?: boolean
    notes?: boolean
    subtotal?: boolean
    taxAmount?: boolean
    total?: boolean
    refundMethod?: boolean
    refundAmount?: boolean
    status?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    syncAttempts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReturnOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnNumber" | "originalOrderId" | "customerId" | "locationId" | "reason" | "notes" | "subtotal" | "taxAmount" | "total" | "refundMethod" | "refundAmount" | "status" | "processedBy" | "processedAt" | "syncVersion" | "lastSyncedAt" | "isDirty" | "syncAttempts" | "createdAt" | "updatedAt", ExtArgs["result"]["returnOrder"]>
  export type ReturnOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
    lines?: boolean | ReturnOrder$linesArgs<ExtArgs>
    _count?: boolean | ReturnOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReturnOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }
  export type ReturnOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    customer?: boolean | ReturnOrder$customerArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $ReturnOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnOrder"
    objects: {
      originalOrder: Prisma.$SaleOrderPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      location: Prisma.$LocationPayload<ExtArgs>
      lines: Prisma.$ReturnOrderLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnNumber: string
      originalOrderId: string
      customerId: string | null
      locationId: string
      reason: $Enums.ReturnReason | null
      notes: string | null
      subtotal: number
      taxAmount: number
      total: number
      refundMethod: $Enums.RefundMethod | null
      refundAmount: number
      status: $Enums.ReturnStatus
      processedBy: string | null
      processedAt: Date | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      syncAttempts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["returnOrder"]>
    composites: {}
  }

  type ReturnOrderGetPayload<S extends boolean | null | undefined | ReturnOrderDefaultArgs> = $Result.GetResult<Prisma.$ReturnOrderPayload, S>

  type ReturnOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnOrderCountAggregateInputType | true
    }

  export interface ReturnOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnOrder'], meta: { name: 'ReturnOrder' } }
    /**
     * Find zero or one ReturnOrder that matches the filter.
     * @param {ReturnOrderFindUniqueArgs} args - Arguments to find a ReturnOrder
     * @example
     * // Get one ReturnOrder
     * const returnOrder = await prisma.returnOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnOrderFindUniqueArgs>(args: SelectSubset<T, ReturnOrderFindUniqueArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnOrderFindUniqueOrThrowArgs} args - Arguments to find a ReturnOrder
     * @example
     * // Get one ReturnOrder
     * const returnOrder = await prisma.returnOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderFindFirstArgs} args - Arguments to find a ReturnOrder
     * @example
     * // Get one ReturnOrder
     * const returnOrder = await prisma.returnOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnOrderFindFirstArgs>(args?: SelectSubset<T, ReturnOrderFindFirstArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderFindFirstOrThrowArgs} args - Arguments to find a ReturnOrder
     * @example
     * // Get one ReturnOrder
     * const returnOrder = await prisma.returnOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnOrders
     * const returnOrders = await prisma.returnOrder.findMany()
     * 
     * // Get first 10 ReturnOrders
     * const returnOrders = await prisma.returnOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnOrderWithIdOnly = await prisma.returnOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnOrderFindManyArgs>(args?: SelectSubset<T, ReturnOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnOrder.
     * @param {ReturnOrderCreateArgs} args - Arguments to create a ReturnOrder.
     * @example
     * // Create one ReturnOrder
     * const ReturnOrder = await prisma.returnOrder.create({
     *   data: {
     *     // ... data to create a ReturnOrder
     *   }
     * })
     * 
     */
    create<T extends ReturnOrderCreateArgs>(args: SelectSubset<T, ReturnOrderCreateArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnOrders.
     * @param {ReturnOrderCreateManyArgs} args - Arguments to create many ReturnOrders.
     * @example
     * // Create many ReturnOrders
     * const returnOrder = await prisma.returnOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnOrderCreateManyArgs>(args?: SelectSubset<T, ReturnOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnOrders and returns the data saved in the database.
     * @param {ReturnOrderCreateManyAndReturnArgs} args - Arguments to create many ReturnOrders.
     * @example
     * // Create many ReturnOrders
     * const returnOrder = await prisma.returnOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnOrders and only return the `id`
     * const returnOrderWithIdOnly = await prisma.returnOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReturnOrder.
     * @param {ReturnOrderDeleteArgs} args - Arguments to delete one ReturnOrder.
     * @example
     * // Delete one ReturnOrder
     * const ReturnOrder = await prisma.returnOrder.delete({
     *   where: {
     *     // ... filter to delete one ReturnOrder
     *   }
     * })
     * 
     */
    delete<T extends ReturnOrderDeleteArgs>(args: SelectSubset<T, ReturnOrderDeleteArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnOrder.
     * @param {ReturnOrderUpdateArgs} args - Arguments to update one ReturnOrder.
     * @example
     * // Update one ReturnOrder
     * const returnOrder = await prisma.returnOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnOrderUpdateArgs>(args: SelectSubset<T, ReturnOrderUpdateArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnOrders.
     * @param {ReturnOrderDeleteManyArgs} args - Arguments to filter ReturnOrders to delete.
     * @example
     * // Delete a few ReturnOrders
     * const { count } = await prisma.returnOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnOrderDeleteManyArgs>(args?: SelectSubset<T, ReturnOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnOrders
     * const returnOrder = await prisma.returnOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnOrderUpdateManyArgs>(args: SelectSubset<T, ReturnOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnOrders and returns the data updated in the database.
     * @param {ReturnOrderUpdateManyAndReturnArgs} args - Arguments to update many ReturnOrders.
     * @example
     * // Update many ReturnOrders
     * const returnOrder = await prisma.returnOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReturnOrders and only return the `id`
     * const returnOrderWithIdOnly = await prisma.returnOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReturnOrder.
     * @param {ReturnOrderUpsertArgs} args - Arguments to update or create a ReturnOrder.
     * @example
     * // Update or create a ReturnOrder
     * const returnOrder = await prisma.returnOrder.upsert({
     *   create: {
     *     // ... data to create a ReturnOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnOrder we want to update
     *   }
     * })
     */
    upsert<T extends ReturnOrderUpsertArgs>(args: SelectSubset<T, ReturnOrderUpsertArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderCountArgs} args - Arguments to filter ReturnOrders to count.
     * @example
     * // Count the number of ReturnOrders
     * const count = await prisma.returnOrder.count({
     *   where: {
     *     // ... the filter for the ReturnOrders we want to count
     *   }
     * })
    **/
    count<T extends ReturnOrderCountArgs>(
      args?: Subset<T, ReturnOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnOrderAggregateArgs>(args: Subset<T, ReturnOrderAggregateArgs>): Prisma.PrismaPromise<GetReturnOrderAggregateType<T>>

    /**
     * Group by ReturnOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnOrderGroupByArgs['orderBy'] }
        : { orderBy?: ReturnOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnOrder model
   */
  readonly fields: ReturnOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalOrder<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends ReturnOrder$customerArgs<ExtArgs> = {}>(args?: Subset<T, ReturnOrder$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends ReturnOrder$linesArgs<ExtArgs> = {}>(args?: Subset<T, ReturnOrder$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnOrder model
   */
  interface ReturnOrderFieldRefs {
    readonly id: FieldRef<"ReturnOrder", 'String'>
    readonly returnNumber: FieldRef<"ReturnOrder", 'String'>
    readonly originalOrderId: FieldRef<"ReturnOrder", 'String'>
    readonly customerId: FieldRef<"ReturnOrder", 'String'>
    readonly locationId: FieldRef<"ReturnOrder", 'String'>
    readonly reason: FieldRef<"ReturnOrder", 'ReturnReason'>
    readonly notes: FieldRef<"ReturnOrder", 'String'>
    readonly subtotal: FieldRef<"ReturnOrder", 'Float'>
    readonly taxAmount: FieldRef<"ReturnOrder", 'Float'>
    readonly total: FieldRef<"ReturnOrder", 'Float'>
    readonly refundMethod: FieldRef<"ReturnOrder", 'RefundMethod'>
    readonly refundAmount: FieldRef<"ReturnOrder", 'Float'>
    readonly status: FieldRef<"ReturnOrder", 'ReturnStatus'>
    readonly processedBy: FieldRef<"ReturnOrder", 'String'>
    readonly processedAt: FieldRef<"ReturnOrder", 'DateTime'>
    readonly syncVersion: FieldRef<"ReturnOrder", 'Int'>
    readonly lastSyncedAt: FieldRef<"ReturnOrder", 'DateTime'>
    readonly isDirty: FieldRef<"ReturnOrder", 'Boolean'>
    readonly syncAttempts: FieldRef<"ReturnOrder", 'Int'>
    readonly createdAt: FieldRef<"ReturnOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"ReturnOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnOrder findUnique
   */
  export type ReturnOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrder to fetch.
     */
    where: ReturnOrderWhereUniqueInput
  }

  /**
   * ReturnOrder findUniqueOrThrow
   */
  export type ReturnOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrder to fetch.
     */
    where: ReturnOrderWhereUniqueInput
  }

  /**
   * ReturnOrder findFirst
   */
  export type ReturnOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrder to fetch.
     */
    where?: ReturnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrders to fetch.
     */
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnOrders.
     */
    cursor?: ReturnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnOrders.
     */
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * ReturnOrder findFirstOrThrow
   */
  export type ReturnOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrder to fetch.
     */
    where?: ReturnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrders to fetch.
     */
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnOrders.
     */
    cursor?: ReturnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnOrders.
     */
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * ReturnOrder findMany
   */
  export type ReturnOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrders to fetch.
     */
    where?: ReturnOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrders to fetch.
     */
    orderBy?: ReturnOrderOrderByWithRelationInput | ReturnOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnOrders.
     */
    cursor?: ReturnOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrders.
     */
    skip?: number
    distinct?: ReturnOrderScalarFieldEnum | ReturnOrderScalarFieldEnum[]
  }

  /**
   * ReturnOrder create
   */
  export type ReturnOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnOrder.
     */
    data: XOR<ReturnOrderCreateInput, ReturnOrderUncheckedCreateInput>
  }

  /**
   * ReturnOrder createMany
   */
  export type ReturnOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnOrders.
     */
    data: ReturnOrderCreateManyInput | ReturnOrderCreateManyInput[]
  }

  /**
   * ReturnOrder createManyAndReturn
   */
  export type ReturnOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ReturnOrders.
     */
    data: ReturnOrderCreateManyInput | ReturnOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnOrder update
   */
  export type ReturnOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnOrder.
     */
    data: XOR<ReturnOrderUpdateInput, ReturnOrderUncheckedUpdateInput>
    /**
     * Choose, which ReturnOrder to update.
     */
    where: ReturnOrderWhereUniqueInput
  }

  /**
   * ReturnOrder updateMany
   */
  export type ReturnOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnOrders.
     */
    data: XOR<ReturnOrderUpdateManyMutationInput, ReturnOrderUncheckedUpdateManyInput>
    /**
     * Filter which ReturnOrders to update
     */
    where?: ReturnOrderWhereInput
    /**
     * Limit how many ReturnOrders to update.
     */
    limit?: number
  }

  /**
   * ReturnOrder updateManyAndReturn
   */
  export type ReturnOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * The data used to update ReturnOrders.
     */
    data: XOR<ReturnOrderUpdateManyMutationInput, ReturnOrderUncheckedUpdateManyInput>
    /**
     * Filter which ReturnOrders to update
     */
    where?: ReturnOrderWhereInput
    /**
     * Limit how many ReturnOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnOrder upsert
   */
  export type ReturnOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnOrder to update in case it exists.
     */
    where: ReturnOrderWhereUniqueInput
    /**
     * In case the ReturnOrder found by the `where` argument doesn't exist, create a new ReturnOrder with this data.
     */
    create: XOR<ReturnOrderCreateInput, ReturnOrderUncheckedCreateInput>
    /**
     * In case the ReturnOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnOrderUpdateInput, ReturnOrderUncheckedUpdateInput>
  }

  /**
   * ReturnOrder delete
   */
  export type ReturnOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
    /**
     * Filter which ReturnOrder to delete.
     */
    where: ReturnOrderWhereUniqueInput
  }

  /**
   * ReturnOrder deleteMany
   */
  export type ReturnOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnOrders to delete
     */
    where?: ReturnOrderWhereInput
    /**
     * Limit how many ReturnOrders to delete.
     */
    limit?: number
  }

  /**
   * ReturnOrder.customer
   */
  export type ReturnOrder$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * ReturnOrder.lines
   */
  export type ReturnOrder$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    where?: ReturnOrderLineWhereInput
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    cursor?: ReturnOrderLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReturnOrderLineScalarFieldEnum | ReturnOrderLineScalarFieldEnum[]
  }

  /**
   * ReturnOrder without action
   */
  export type ReturnOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrder
     */
    select?: ReturnOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrder
     */
    omit?: ReturnOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderInclude<ExtArgs> | null
  }


  /**
   * Model ReturnOrderLine
   */

  export type AggregateReturnOrderLine = {
    _count: ReturnOrderLineCountAggregateOutputType | null
    _avg: ReturnOrderLineAvgAggregateOutputType | null
    _sum: ReturnOrderLineSumAggregateOutputType | null
    _min: ReturnOrderLineMinAggregateOutputType | null
    _max: ReturnOrderLineMaxAggregateOutputType | null
  }

  export type ReturnOrderLineAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    lineTotal: number | null
  }

  export type ReturnOrderLineSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    lineTotal: number | null
  }

  export type ReturnOrderLineMinAggregateOutputType = {
    id: string | null
    returnOrderId: string | null
    variantId: string | null
    originalLineId: string | null
    quantity: number | null
    unitPrice: number | null
    lineTotal: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReturnOrderLineMaxAggregateOutputType = {
    id: string | null
    returnOrderId: string | null
    variantId: string | null
    originalLineId: string | null
    quantity: number | null
    unitPrice: number | null
    lineTotal: number | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReturnOrderLineCountAggregateOutputType = {
    id: number
    returnOrderId: number
    variantId: number
    originalLineId: number
    quantity: number
    unitPrice: number
    lineTotal: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReturnOrderLineAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type ReturnOrderLineSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    lineTotal?: true
  }

  export type ReturnOrderLineMinAggregateInputType = {
    id?: true
    returnOrderId?: true
    variantId?: true
    originalLineId?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
    reason?: true
    createdAt?: true
  }

  export type ReturnOrderLineMaxAggregateInputType = {
    id?: true
    returnOrderId?: true
    variantId?: true
    originalLineId?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
    reason?: true
    createdAt?: true
  }

  export type ReturnOrderLineCountAggregateInputType = {
    id?: true
    returnOrderId?: true
    variantId?: true
    originalLineId?: true
    quantity?: true
    unitPrice?: true
    lineTotal?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReturnOrderLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnOrderLine to aggregate.
     */
    where?: ReturnOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrderLines to fetch.
     */
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReturnOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReturnOrderLines
    **/
    _count?: true | ReturnOrderLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReturnOrderLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReturnOrderLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReturnOrderLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReturnOrderLineMaxAggregateInputType
  }

  export type GetReturnOrderLineAggregateType<T extends ReturnOrderLineAggregateArgs> = {
        [P in keyof T & keyof AggregateReturnOrderLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReturnOrderLine[P]>
      : GetScalarType<T[P], AggregateReturnOrderLine[P]>
  }




  export type ReturnOrderLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReturnOrderLineWhereInput
    orderBy?: ReturnOrderLineOrderByWithAggregationInput | ReturnOrderLineOrderByWithAggregationInput[]
    by: ReturnOrderLineScalarFieldEnum[] | ReturnOrderLineScalarFieldEnum
    having?: ReturnOrderLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReturnOrderLineCountAggregateInputType | true
    _avg?: ReturnOrderLineAvgAggregateInputType
    _sum?: ReturnOrderLineSumAggregateInputType
    _min?: ReturnOrderLineMinAggregateInputType
    _max?: ReturnOrderLineMaxAggregateInputType
  }

  export type ReturnOrderLineGroupByOutputType = {
    id: string
    returnOrderId: string
    variantId: string
    originalLineId: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason: string | null
    createdAt: Date
    _count: ReturnOrderLineCountAggregateOutputType | null
    _avg: ReturnOrderLineAvgAggregateOutputType | null
    _sum: ReturnOrderLineSumAggregateOutputType | null
    _min: ReturnOrderLineMinAggregateOutputType | null
    _max: ReturnOrderLineMaxAggregateOutputType | null
  }

  type GetReturnOrderLineGroupByPayload<T extends ReturnOrderLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReturnOrderLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReturnOrderLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReturnOrderLineGroupByOutputType[P]>
            : GetScalarType<T[P], ReturnOrderLineGroupByOutputType[P]>
        }
      >
    >


  export type ReturnOrderLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnOrderId?: boolean
    variantId?: boolean
    originalLineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    reason?: boolean
    createdAt?: boolean
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrderLine"]>

  export type ReturnOrderLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnOrderId?: boolean
    variantId?: boolean
    originalLineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    reason?: boolean
    createdAt?: boolean
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrderLine"]>

  export type ReturnOrderLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    returnOrderId?: boolean
    variantId?: boolean
    originalLineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    reason?: boolean
    createdAt?: boolean
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["returnOrderLine"]>

  export type ReturnOrderLineSelectScalar = {
    id?: boolean
    returnOrderId?: boolean
    variantId?: boolean
    originalLineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    lineTotal?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReturnOrderLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "returnOrderId" | "variantId" | "originalLineId" | "quantity" | "unitPrice" | "lineTotal" | "reason" | "createdAt", ExtArgs["result"]["returnOrderLine"]>
  export type ReturnOrderLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type ReturnOrderLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }
  export type ReturnOrderLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    returnOrder?: boolean | ReturnOrderDefaultArgs<ExtArgs>
    variant?: boolean | ProductVariantDefaultArgs<ExtArgs>
  }

  export type $ReturnOrderLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReturnOrderLine"
    objects: {
      returnOrder: Prisma.$ReturnOrderPayload<ExtArgs>
      variant: Prisma.$ProductVariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      returnOrderId: string
      variantId: string
      originalLineId: string | null
      quantity: number
      unitPrice: number
      lineTotal: number
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["returnOrderLine"]>
    composites: {}
  }

  type ReturnOrderLineGetPayload<S extends boolean | null | undefined | ReturnOrderLineDefaultArgs> = $Result.GetResult<Prisma.$ReturnOrderLinePayload, S>

  type ReturnOrderLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReturnOrderLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReturnOrderLineCountAggregateInputType | true
    }

  export interface ReturnOrderLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReturnOrderLine'], meta: { name: 'ReturnOrderLine' } }
    /**
     * Find zero or one ReturnOrderLine that matches the filter.
     * @param {ReturnOrderLineFindUniqueArgs} args - Arguments to find a ReturnOrderLine
     * @example
     * // Get one ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReturnOrderLineFindUniqueArgs>(args: SelectSubset<T, ReturnOrderLineFindUniqueArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReturnOrderLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReturnOrderLineFindUniqueOrThrowArgs} args - Arguments to find a ReturnOrderLine
     * @example
     * // Get one ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReturnOrderLineFindUniqueOrThrowArgs>(args: SelectSubset<T, ReturnOrderLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnOrderLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineFindFirstArgs} args - Arguments to find a ReturnOrderLine
     * @example
     * // Get one ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReturnOrderLineFindFirstArgs>(args?: SelectSubset<T, ReturnOrderLineFindFirstArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReturnOrderLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineFindFirstOrThrowArgs} args - Arguments to find a ReturnOrderLine
     * @example
     * // Get one ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReturnOrderLineFindFirstOrThrowArgs>(args?: SelectSubset<T, ReturnOrderLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReturnOrderLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReturnOrderLines
     * const returnOrderLines = await prisma.returnOrderLine.findMany()
     * 
     * // Get first 10 ReturnOrderLines
     * const returnOrderLines = await prisma.returnOrderLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const returnOrderLineWithIdOnly = await prisma.returnOrderLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReturnOrderLineFindManyArgs>(args?: SelectSubset<T, ReturnOrderLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReturnOrderLine.
     * @param {ReturnOrderLineCreateArgs} args - Arguments to create a ReturnOrderLine.
     * @example
     * // Create one ReturnOrderLine
     * const ReturnOrderLine = await prisma.returnOrderLine.create({
     *   data: {
     *     // ... data to create a ReturnOrderLine
     *   }
     * })
     * 
     */
    create<T extends ReturnOrderLineCreateArgs>(args: SelectSubset<T, ReturnOrderLineCreateArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReturnOrderLines.
     * @param {ReturnOrderLineCreateManyArgs} args - Arguments to create many ReturnOrderLines.
     * @example
     * // Create many ReturnOrderLines
     * const returnOrderLine = await prisma.returnOrderLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReturnOrderLineCreateManyArgs>(args?: SelectSubset<T, ReturnOrderLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReturnOrderLines and returns the data saved in the database.
     * @param {ReturnOrderLineCreateManyAndReturnArgs} args - Arguments to create many ReturnOrderLines.
     * @example
     * // Create many ReturnOrderLines
     * const returnOrderLine = await prisma.returnOrderLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReturnOrderLines and only return the `id`
     * const returnOrderLineWithIdOnly = await prisma.returnOrderLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReturnOrderLineCreateManyAndReturnArgs>(args?: SelectSubset<T, ReturnOrderLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReturnOrderLine.
     * @param {ReturnOrderLineDeleteArgs} args - Arguments to delete one ReturnOrderLine.
     * @example
     * // Delete one ReturnOrderLine
     * const ReturnOrderLine = await prisma.returnOrderLine.delete({
     *   where: {
     *     // ... filter to delete one ReturnOrderLine
     *   }
     * })
     * 
     */
    delete<T extends ReturnOrderLineDeleteArgs>(args: SelectSubset<T, ReturnOrderLineDeleteArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReturnOrderLine.
     * @param {ReturnOrderLineUpdateArgs} args - Arguments to update one ReturnOrderLine.
     * @example
     * // Update one ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReturnOrderLineUpdateArgs>(args: SelectSubset<T, ReturnOrderLineUpdateArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReturnOrderLines.
     * @param {ReturnOrderLineDeleteManyArgs} args - Arguments to filter ReturnOrderLines to delete.
     * @example
     * // Delete a few ReturnOrderLines
     * const { count } = await prisma.returnOrderLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReturnOrderLineDeleteManyArgs>(args?: SelectSubset<T, ReturnOrderLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReturnOrderLines
     * const returnOrderLine = await prisma.returnOrderLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReturnOrderLineUpdateManyArgs>(args: SelectSubset<T, ReturnOrderLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReturnOrderLines and returns the data updated in the database.
     * @param {ReturnOrderLineUpdateManyAndReturnArgs} args - Arguments to update many ReturnOrderLines.
     * @example
     * // Update many ReturnOrderLines
     * const returnOrderLine = await prisma.returnOrderLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReturnOrderLines and only return the `id`
     * const returnOrderLineWithIdOnly = await prisma.returnOrderLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReturnOrderLineUpdateManyAndReturnArgs>(args: SelectSubset<T, ReturnOrderLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReturnOrderLine.
     * @param {ReturnOrderLineUpsertArgs} args - Arguments to update or create a ReturnOrderLine.
     * @example
     * // Update or create a ReturnOrderLine
     * const returnOrderLine = await prisma.returnOrderLine.upsert({
     *   create: {
     *     // ... data to create a ReturnOrderLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReturnOrderLine we want to update
     *   }
     * })
     */
    upsert<T extends ReturnOrderLineUpsertArgs>(args: SelectSubset<T, ReturnOrderLineUpsertArgs<ExtArgs>>): Prisma__ReturnOrderLineClient<$Result.GetResult<Prisma.$ReturnOrderLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReturnOrderLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineCountArgs} args - Arguments to filter ReturnOrderLines to count.
     * @example
     * // Count the number of ReturnOrderLines
     * const count = await prisma.returnOrderLine.count({
     *   where: {
     *     // ... the filter for the ReturnOrderLines we want to count
     *   }
     * })
    **/
    count<T extends ReturnOrderLineCountArgs>(
      args?: Subset<T, ReturnOrderLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReturnOrderLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReturnOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReturnOrderLineAggregateArgs>(args: Subset<T, ReturnOrderLineAggregateArgs>): Prisma.PrismaPromise<GetReturnOrderLineAggregateType<T>>

    /**
     * Group by ReturnOrderLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReturnOrderLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReturnOrderLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReturnOrderLineGroupByArgs['orderBy'] }
        : { orderBy?: ReturnOrderLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReturnOrderLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReturnOrderLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReturnOrderLine model
   */
  readonly fields: ReturnOrderLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReturnOrderLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReturnOrderLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    returnOrder<T extends ReturnOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReturnOrderDefaultArgs<ExtArgs>>): Prisma__ReturnOrderClient<$Result.GetResult<Prisma.$ReturnOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends ProductVariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductVariantDefaultArgs<ExtArgs>>): Prisma__ProductVariantClient<$Result.GetResult<Prisma.$ProductVariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReturnOrderLine model
   */
  interface ReturnOrderLineFieldRefs {
    readonly id: FieldRef<"ReturnOrderLine", 'String'>
    readonly returnOrderId: FieldRef<"ReturnOrderLine", 'String'>
    readonly variantId: FieldRef<"ReturnOrderLine", 'String'>
    readonly originalLineId: FieldRef<"ReturnOrderLine", 'String'>
    readonly quantity: FieldRef<"ReturnOrderLine", 'Int'>
    readonly unitPrice: FieldRef<"ReturnOrderLine", 'Float'>
    readonly lineTotal: FieldRef<"ReturnOrderLine", 'Float'>
    readonly reason: FieldRef<"ReturnOrderLine", 'String'>
    readonly createdAt: FieldRef<"ReturnOrderLine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReturnOrderLine findUnique
   */
  export type ReturnOrderLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrderLine to fetch.
     */
    where: ReturnOrderLineWhereUniqueInput
  }

  /**
   * ReturnOrderLine findUniqueOrThrow
   */
  export type ReturnOrderLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrderLine to fetch.
     */
    where: ReturnOrderLineWhereUniqueInput
  }

  /**
   * ReturnOrderLine findFirst
   */
  export type ReturnOrderLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrderLine to fetch.
     */
    where?: ReturnOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrderLines to fetch.
     */
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnOrderLines.
     */
    cursor?: ReturnOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnOrderLines.
     */
    distinct?: ReturnOrderLineScalarFieldEnum | ReturnOrderLineScalarFieldEnum[]
  }

  /**
   * ReturnOrderLine findFirstOrThrow
   */
  export type ReturnOrderLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrderLine to fetch.
     */
    where?: ReturnOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrderLines to fetch.
     */
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReturnOrderLines.
     */
    cursor?: ReturnOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrderLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReturnOrderLines.
     */
    distinct?: ReturnOrderLineScalarFieldEnum | ReturnOrderLineScalarFieldEnum[]
  }

  /**
   * ReturnOrderLine findMany
   */
  export type ReturnOrderLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter, which ReturnOrderLines to fetch.
     */
    where?: ReturnOrderLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReturnOrderLines to fetch.
     */
    orderBy?: ReturnOrderLineOrderByWithRelationInput | ReturnOrderLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReturnOrderLines.
     */
    cursor?: ReturnOrderLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReturnOrderLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReturnOrderLines.
     */
    skip?: number
    distinct?: ReturnOrderLineScalarFieldEnum | ReturnOrderLineScalarFieldEnum[]
  }

  /**
   * ReturnOrderLine create
   */
  export type ReturnOrderLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to create a ReturnOrderLine.
     */
    data: XOR<ReturnOrderLineCreateInput, ReturnOrderLineUncheckedCreateInput>
  }

  /**
   * ReturnOrderLine createMany
   */
  export type ReturnOrderLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReturnOrderLines.
     */
    data: ReturnOrderLineCreateManyInput | ReturnOrderLineCreateManyInput[]
  }

  /**
   * ReturnOrderLine createManyAndReturn
   */
  export type ReturnOrderLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * The data used to create many ReturnOrderLines.
     */
    data: ReturnOrderLineCreateManyInput | ReturnOrderLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnOrderLine update
   */
  export type ReturnOrderLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * The data needed to update a ReturnOrderLine.
     */
    data: XOR<ReturnOrderLineUpdateInput, ReturnOrderLineUncheckedUpdateInput>
    /**
     * Choose, which ReturnOrderLine to update.
     */
    where: ReturnOrderLineWhereUniqueInput
  }

  /**
   * ReturnOrderLine updateMany
   */
  export type ReturnOrderLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReturnOrderLines.
     */
    data: XOR<ReturnOrderLineUpdateManyMutationInput, ReturnOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which ReturnOrderLines to update
     */
    where?: ReturnOrderLineWhereInput
    /**
     * Limit how many ReturnOrderLines to update.
     */
    limit?: number
  }

  /**
   * ReturnOrderLine updateManyAndReturn
   */
  export type ReturnOrderLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * The data used to update ReturnOrderLines.
     */
    data: XOR<ReturnOrderLineUpdateManyMutationInput, ReturnOrderLineUncheckedUpdateManyInput>
    /**
     * Filter which ReturnOrderLines to update
     */
    where?: ReturnOrderLineWhereInput
    /**
     * Limit how many ReturnOrderLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReturnOrderLine upsert
   */
  export type ReturnOrderLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * The filter to search for the ReturnOrderLine to update in case it exists.
     */
    where: ReturnOrderLineWhereUniqueInput
    /**
     * In case the ReturnOrderLine found by the `where` argument doesn't exist, create a new ReturnOrderLine with this data.
     */
    create: XOR<ReturnOrderLineCreateInput, ReturnOrderLineUncheckedCreateInput>
    /**
     * In case the ReturnOrderLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReturnOrderLineUpdateInput, ReturnOrderLineUncheckedUpdateInput>
  }

  /**
   * ReturnOrderLine delete
   */
  export type ReturnOrderLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
    /**
     * Filter which ReturnOrderLine to delete.
     */
    where: ReturnOrderLineWhereUniqueInput
  }

  /**
   * ReturnOrderLine deleteMany
   */
  export type ReturnOrderLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReturnOrderLines to delete
     */
    where?: ReturnOrderLineWhereInput
    /**
     * Limit how many ReturnOrderLines to delete.
     */
    limit?: number
  }

  /**
   * ReturnOrderLine without action
   */
  export type ReturnOrderLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReturnOrderLine
     */
    select?: ReturnOrderLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReturnOrderLine
     */
    omit?: ReturnOrderLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReturnOrderLineInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeOrder
   */

  export type AggregateExchangeOrder = {
    _count: ExchangeOrderCountAggregateOutputType | null
    _avg: ExchangeOrderAvgAggregateOutputType | null
    _sum: ExchangeOrderSumAggregateOutputType | null
    _min: ExchangeOrderMinAggregateOutputType | null
    _max: ExchangeOrderMaxAggregateOutputType | null
  }

  export type ExchangeOrderAvgAggregateOutputType = {
    priceDifference: number | null
    additionalPayment: number | null
    refundAmount: number | null
    syncVersion: number | null
  }

  export type ExchangeOrderSumAggregateOutputType = {
    priceDifference: number | null
    additionalPayment: number | null
    refundAmount: number | null
    syncVersion: number | null
  }

  export type ExchangeOrderMinAggregateOutputType = {
    id: string | null
    exchangeNumber: string | null
    originalOrderId: string | null
    newOrderId: string | null
    priceDifference: number | null
    additionalPayment: number | null
    refundAmount: number | null
    processedBy: string | null
    processedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ExchangeOrderMaxAggregateOutputType = {
    id: string | null
    exchangeNumber: string | null
    originalOrderId: string | null
    newOrderId: string | null
    priceDifference: number | null
    additionalPayment: number | null
    refundAmount: number | null
    processedBy: string | null
    processedAt: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ExchangeOrderCountAggregateOutputType = {
    id: number
    exchangeNumber: number
    originalOrderId: number
    newOrderId: number
    priceDifference: number
    additionalPayment: number
    refundAmount: number
    processedBy: number
    processedAt: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    _all: number
  }


  export type ExchangeOrderAvgAggregateInputType = {
    priceDifference?: true
    additionalPayment?: true
    refundAmount?: true
    syncVersion?: true
  }

  export type ExchangeOrderSumAggregateInputType = {
    priceDifference?: true
    additionalPayment?: true
    refundAmount?: true
    syncVersion?: true
  }

  export type ExchangeOrderMinAggregateInputType = {
    id?: true
    exchangeNumber?: true
    originalOrderId?: true
    newOrderId?: true
    priceDifference?: true
    additionalPayment?: true
    refundAmount?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ExchangeOrderMaxAggregateInputType = {
    id?: true
    exchangeNumber?: true
    originalOrderId?: true
    newOrderId?: true
    priceDifference?: true
    additionalPayment?: true
    refundAmount?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ExchangeOrderCountAggregateInputType = {
    id?: true
    exchangeNumber?: true
    originalOrderId?: true
    newOrderId?: true
    priceDifference?: true
    additionalPayment?: true
    refundAmount?: true
    processedBy?: true
    processedAt?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    _all?: true
  }

  export type ExchangeOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeOrder to aggregate.
     */
    where?: ExchangeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeOrders to fetch.
     */
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeOrders
    **/
    _count?: true | ExchangeOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeOrderMaxAggregateInputType
  }

  export type GetExchangeOrderAggregateType<T extends ExchangeOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeOrder[P]>
      : GetScalarType<T[P], AggregateExchangeOrder[P]>
  }




  export type ExchangeOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeOrderWhereInput
    orderBy?: ExchangeOrderOrderByWithAggregationInput | ExchangeOrderOrderByWithAggregationInput[]
    by: ExchangeOrderScalarFieldEnum[] | ExchangeOrderScalarFieldEnum
    having?: ExchangeOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeOrderCountAggregateInputType | true
    _avg?: ExchangeOrderAvgAggregateInputType
    _sum?: ExchangeOrderSumAggregateInputType
    _min?: ExchangeOrderMinAggregateInputType
    _max?: ExchangeOrderMaxAggregateInputType
  }

  export type ExchangeOrderGroupByOutputType = {
    id: string
    exchangeNumber: string
    originalOrderId: string
    newOrderId: string
    priceDifference: number
    additionalPayment: number
    refundAmount: number
    processedBy: string | null
    processedAt: Date
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    _count: ExchangeOrderCountAggregateOutputType | null
    _avg: ExchangeOrderAvgAggregateOutputType | null
    _sum: ExchangeOrderSumAggregateOutputType | null
    _min: ExchangeOrderMinAggregateOutputType | null
    _max: ExchangeOrderMaxAggregateOutputType | null
  }

  type GetExchangeOrderGroupByPayload<T extends ExchangeOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeOrderGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNumber?: boolean
    originalOrderId?: boolean
    newOrderId?: boolean
    priceDifference?: boolean
    additionalPayment?: boolean
    refundAmount?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeOrder"]>

  export type ExchangeOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNumber?: boolean
    originalOrderId?: boolean
    newOrderId?: boolean
    priceDifference?: boolean
    additionalPayment?: boolean
    refundAmount?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeOrder"]>

  export type ExchangeOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    exchangeNumber?: boolean
    originalOrderId?: boolean
    newOrderId?: boolean
    priceDifference?: boolean
    additionalPayment?: boolean
    refundAmount?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangeOrder"]>

  export type ExchangeOrderSelectScalar = {
    id?: boolean
    exchangeNumber?: boolean
    originalOrderId?: boolean
    newOrderId?: boolean
    priceDifference?: boolean
    additionalPayment?: boolean
    refundAmount?: boolean
    processedBy?: boolean
    processedAt?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
  }

  export type ExchangeOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "exchangeNumber" | "originalOrderId" | "newOrderId" | "priceDifference" | "additionalPayment" | "refundAmount" | "processedBy" | "processedAt" | "syncVersion" | "lastSyncedAt" | "isDirty", ExtArgs["result"]["exchangeOrder"]>
  export type ExchangeOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type ExchangeOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type ExchangeOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
    newOrder?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }

  export type $ExchangeOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeOrder"
    objects: {
      originalOrder: Prisma.$SaleOrderPayload<ExtArgs>
      newOrder: Prisma.$SaleOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      exchangeNumber: string
      originalOrderId: string
      newOrderId: string
      priceDifference: number
      additionalPayment: number
      refundAmount: number
      processedBy: string | null
      processedAt: Date
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
    }, ExtArgs["result"]["exchangeOrder"]>
    composites: {}
  }

  type ExchangeOrderGetPayload<S extends boolean | null | undefined | ExchangeOrderDefaultArgs> = $Result.GetResult<Prisma.$ExchangeOrderPayload, S>

  type ExchangeOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExchangeOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangeOrderCountAggregateInputType | true
    }

  export interface ExchangeOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeOrder'], meta: { name: 'ExchangeOrder' } }
    /**
     * Find zero or one ExchangeOrder that matches the filter.
     * @param {ExchangeOrderFindUniqueArgs} args - Arguments to find a ExchangeOrder
     * @example
     * // Get one ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeOrderFindUniqueArgs>(args: SelectSubset<T, ExchangeOrderFindUniqueArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExchangeOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExchangeOrderFindUniqueOrThrowArgs} args - Arguments to find a ExchangeOrder
     * @example
     * // Get one ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderFindFirstArgs} args - Arguments to find a ExchangeOrder
     * @example
     * // Get one ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeOrderFindFirstArgs>(args?: SelectSubset<T, ExchangeOrderFindFirstArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExchangeOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderFindFirstOrThrowArgs} args - Arguments to find a ExchangeOrder
     * @example
     * // Get one ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExchangeOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeOrders
     * const exchangeOrders = await prisma.exchangeOrder.findMany()
     * 
     * // Get first 10 ExchangeOrders
     * const exchangeOrders = await prisma.exchangeOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeOrderWithIdOnly = await prisma.exchangeOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeOrderFindManyArgs>(args?: SelectSubset<T, ExchangeOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExchangeOrder.
     * @param {ExchangeOrderCreateArgs} args - Arguments to create a ExchangeOrder.
     * @example
     * // Create one ExchangeOrder
     * const ExchangeOrder = await prisma.exchangeOrder.create({
     *   data: {
     *     // ... data to create a ExchangeOrder
     *   }
     * })
     * 
     */
    create<T extends ExchangeOrderCreateArgs>(args: SelectSubset<T, ExchangeOrderCreateArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExchangeOrders.
     * @param {ExchangeOrderCreateManyArgs} args - Arguments to create many ExchangeOrders.
     * @example
     * // Create many ExchangeOrders
     * const exchangeOrder = await prisma.exchangeOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeOrderCreateManyArgs>(args?: SelectSubset<T, ExchangeOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeOrders and returns the data saved in the database.
     * @param {ExchangeOrderCreateManyAndReturnArgs} args - Arguments to create many ExchangeOrders.
     * @example
     * // Create many ExchangeOrders
     * const exchangeOrder = await prisma.exchangeOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeOrders and only return the `id`
     * const exchangeOrderWithIdOnly = await prisma.exchangeOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExchangeOrder.
     * @param {ExchangeOrderDeleteArgs} args - Arguments to delete one ExchangeOrder.
     * @example
     * // Delete one ExchangeOrder
     * const ExchangeOrder = await prisma.exchangeOrder.delete({
     *   where: {
     *     // ... filter to delete one ExchangeOrder
     *   }
     * })
     * 
     */
    delete<T extends ExchangeOrderDeleteArgs>(args: SelectSubset<T, ExchangeOrderDeleteArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExchangeOrder.
     * @param {ExchangeOrderUpdateArgs} args - Arguments to update one ExchangeOrder.
     * @example
     * // Update one ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeOrderUpdateArgs>(args: SelectSubset<T, ExchangeOrderUpdateArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExchangeOrders.
     * @param {ExchangeOrderDeleteManyArgs} args - Arguments to filter ExchangeOrders to delete.
     * @example
     * // Delete a few ExchangeOrders
     * const { count } = await prisma.exchangeOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeOrderDeleteManyArgs>(args?: SelectSubset<T, ExchangeOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeOrders
     * const exchangeOrder = await prisma.exchangeOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeOrderUpdateManyArgs>(args: SelectSubset<T, ExchangeOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeOrders and returns the data updated in the database.
     * @param {ExchangeOrderUpdateManyAndReturnArgs} args - Arguments to update many ExchangeOrders.
     * @example
     * // Update many ExchangeOrders
     * const exchangeOrder = await prisma.exchangeOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExchangeOrders and only return the `id`
     * const exchangeOrderWithIdOnly = await prisma.exchangeOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExchangeOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ExchangeOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExchangeOrder.
     * @param {ExchangeOrderUpsertArgs} args - Arguments to update or create a ExchangeOrder.
     * @example
     * // Update or create a ExchangeOrder
     * const exchangeOrder = await prisma.exchangeOrder.upsert({
     *   create: {
     *     // ... data to create a ExchangeOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeOrder we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeOrderUpsertArgs>(args: SelectSubset<T, ExchangeOrderUpsertArgs<ExtArgs>>): Prisma__ExchangeOrderClient<$Result.GetResult<Prisma.$ExchangeOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExchangeOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderCountArgs} args - Arguments to filter ExchangeOrders to count.
     * @example
     * // Count the number of ExchangeOrders
     * const count = await prisma.exchangeOrder.count({
     *   where: {
     *     // ... the filter for the ExchangeOrders we want to count
     *   }
     * })
    **/
    count<T extends ExchangeOrderCountArgs>(
      args?: Subset<T, ExchangeOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeOrderAggregateArgs>(args: Subset<T, ExchangeOrderAggregateArgs>): Prisma.PrismaPromise<GetExchangeOrderAggregateType<T>>

    /**
     * Group by ExchangeOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeOrderGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeOrder model
   */
  readonly fields: ExchangeOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalOrder<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    newOrder<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeOrder model
   */
  interface ExchangeOrderFieldRefs {
    readonly id: FieldRef<"ExchangeOrder", 'String'>
    readonly exchangeNumber: FieldRef<"ExchangeOrder", 'String'>
    readonly originalOrderId: FieldRef<"ExchangeOrder", 'String'>
    readonly newOrderId: FieldRef<"ExchangeOrder", 'String'>
    readonly priceDifference: FieldRef<"ExchangeOrder", 'Float'>
    readonly additionalPayment: FieldRef<"ExchangeOrder", 'Float'>
    readonly refundAmount: FieldRef<"ExchangeOrder", 'Float'>
    readonly processedBy: FieldRef<"ExchangeOrder", 'String'>
    readonly processedAt: FieldRef<"ExchangeOrder", 'DateTime'>
    readonly syncVersion: FieldRef<"ExchangeOrder", 'Int'>
    readonly lastSyncedAt: FieldRef<"ExchangeOrder", 'DateTime'>
    readonly isDirty: FieldRef<"ExchangeOrder", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeOrder findUnique
   */
  export type ExchangeOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeOrder to fetch.
     */
    where: ExchangeOrderWhereUniqueInput
  }

  /**
   * ExchangeOrder findUniqueOrThrow
   */
  export type ExchangeOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeOrder to fetch.
     */
    where: ExchangeOrderWhereUniqueInput
  }

  /**
   * ExchangeOrder findFirst
   */
  export type ExchangeOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeOrder to fetch.
     */
    where?: ExchangeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeOrders to fetch.
     */
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeOrders.
     */
    cursor?: ExchangeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeOrders.
     */
    distinct?: ExchangeOrderScalarFieldEnum | ExchangeOrderScalarFieldEnum[]
  }

  /**
   * ExchangeOrder findFirstOrThrow
   */
  export type ExchangeOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeOrder to fetch.
     */
    where?: ExchangeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeOrders to fetch.
     */
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeOrders.
     */
    cursor?: ExchangeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeOrders.
     */
    distinct?: ExchangeOrderScalarFieldEnum | ExchangeOrderScalarFieldEnum[]
  }

  /**
   * ExchangeOrder findMany
   */
  export type ExchangeOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter, which ExchangeOrders to fetch.
     */
    where?: ExchangeOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeOrders to fetch.
     */
    orderBy?: ExchangeOrderOrderByWithRelationInput | ExchangeOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeOrders.
     */
    cursor?: ExchangeOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeOrders.
     */
    skip?: number
    distinct?: ExchangeOrderScalarFieldEnum | ExchangeOrderScalarFieldEnum[]
  }

  /**
   * ExchangeOrder create
   */
  export type ExchangeOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ExchangeOrder.
     */
    data: XOR<ExchangeOrderCreateInput, ExchangeOrderUncheckedCreateInput>
  }

  /**
   * ExchangeOrder createMany
   */
  export type ExchangeOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeOrders.
     */
    data: ExchangeOrderCreateManyInput | ExchangeOrderCreateManyInput[]
  }

  /**
   * ExchangeOrder createManyAndReturn
   */
  export type ExchangeOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ExchangeOrders.
     */
    data: ExchangeOrderCreateManyInput | ExchangeOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeOrder update
   */
  export type ExchangeOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ExchangeOrder.
     */
    data: XOR<ExchangeOrderUpdateInput, ExchangeOrderUncheckedUpdateInput>
    /**
     * Choose, which ExchangeOrder to update.
     */
    where: ExchangeOrderWhereUniqueInput
  }

  /**
   * ExchangeOrder updateMany
   */
  export type ExchangeOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeOrders.
     */
    data: XOR<ExchangeOrderUpdateManyMutationInput, ExchangeOrderUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeOrders to update
     */
    where?: ExchangeOrderWhereInput
    /**
     * Limit how many ExchangeOrders to update.
     */
    limit?: number
  }

  /**
   * ExchangeOrder updateManyAndReturn
   */
  export type ExchangeOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * The data used to update ExchangeOrders.
     */
    data: XOR<ExchangeOrderUpdateManyMutationInput, ExchangeOrderUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeOrders to update
     */
    where?: ExchangeOrderWhereInput
    /**
     * Limit how many ExchangeOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExchangeOrder upsert
   */
  export type ExchangeOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ExchangeOrder to update in case it exists.
     */
    where: ExchangeOrderWhereUniqueInput
    /**
     * In case the ExchangeOrder found by the `where` argument doesn't exist, create a new ExchangeOrder with this data.
     */
    create: XOR<ExchangeOrderCreateInput, ExchangeOrderUncheckedCreateInput>
    /**
     * In case the ExchangeOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeOrderUpdateInput, ExchangeOrderUncheckedUpdateInput>
  }

  /**
   * ExchangeOrder delete
   */
  export type ExchangeOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
    /**
     * Filter which ExchangeOrder to delete.
     */
    where: ExchangeOrderWhereUniqueInput
  }

  /**
   * ExchangeOrder deleteMany
   */
  export type ExchangeOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeOrders to delete
     */
    where?: ExchangeOrderWhereInput
    /**
     * Limit how many ExchangeOrders to delete.
     */
    limit?: number
  }

  /**
   * ExchangeOrder without action
   */
  export type ExchangeOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeOrder
     */
    select?: ExchangeOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExchangeOrder
     */
    omit?: ExchangeOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExchangeOrderInclude<ExtArgs> | null
  }


  /**
   * Model ParkedOrder
   */

  export type AggregateParkedOrder = {
    _count: ParkedOrderCountAggregateOutputType | null
    _avg: ParkedOrderAvgAggregateOutputType | null
    _sum: ParkedOrderSumAggregateOutputType | null
    _min: ParkedOrderMinAggregateOutputType | null
    _max: ParkedOrderMaxAggregateOutputType | null
  }

  export type ParkedOrderAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type ParkedOrderSumAggregateOutputType = {
    syncVersion: number | null
  }

  export type ParkedOrderMinAggregateOutputType = {
    id: string | null
    parkNumber: string | null
    orderId: string | null
    customerId: string | null
    parkedBy: string | null
    parkedAt: Date | null
    expiryDate: Date | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ParkedOrderMaxAggregateOutputType = {
    id: string | null
    parkNumber: string | null
    orderId: string | null
    customerId: string | null
    parkedBy: string | null
    parkedAt: Date | null
    expiryDate: Date | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ParkedOrderCountAggregateOutputType = {
    id: number
    parkNumber: number
    orderId: number
    customerId: number
    parkedBy: number
    parkedAt: number
    expiryDate: number
    notes: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    _all: number
  }


  export type ParkedOrderAvgAggregateInputType = {
    syncVersion?: true
  }

  export type ParkedOrderSumAggregateInputType = {
    syncVersion?: true
  }

  export type ParkedOrderMinAggregateInputType = {
    id?: true
    parkNumber?: true
    orderId?: true
    customerId?: true
    parkedBy?: true
    parkedAt?: true
    expiryDate?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ParkedOrderMaxAggregateInputType = {
    id?: true
    parkNumber?: true
    orderId?: true
    customerId?: true
    parkedBy?: true
    parkedAt?: true
    expiryDate?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ParkedOrderCountAggregateInputType = {
    id?: true
    parkNumber?: true
    orderId?: true
    customerId?: true
    parkedBy?: true
    parkedAt?: true
    expiryDate?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    _all?: true
  }

  export type ParkedOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkedOrder to aggregate.
     */
    where?: ParkedOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkedOrders to fetch.
     */
    orderBy?: ParkedOrderOrderByWithRelationInput | ParkedOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParkedOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkedOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkedOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParkedOrders
    **/
    _count?: true | ParkedOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParkedOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParkedOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParkedOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParkedOrderMaxAggregateInputType
  }

  export type GetParkedOrderAggregateType<T extends ParkedOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateParkedOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParkedOrder[P]>
      : GetScalarType<T[P], AggregateParkedOrder[P]>
  }




  export type ParkedOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParkedOrderWhereInput
    orderBy?: ParkedOrderOrderByWithAggregationInput | ParkedOrderOrderByWithAggregationInput[]
    by: ParkedOrderScalarFieldEnum[] | ParkedOrderScalarFieldEnum
    having?: ParkedOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParkedOrderCountAggregateInputType | true
    _avg?: ParkedOrderAvgAggregateInputType
    _sum?: ParkedOrderSumAggregateInputType
    _min?: ParkedOrderMinAggregateInputType
    _max?: ParkedOrderMaxAggregateInputType
  }

  export type ParkedOrderGroupByOutputType = {
    id: string
    parkNumber: string
    orderId: string
    customerId: string | null
    parkedBy: string | null
    parkedAt: Date
    expiryDate: Date | null
    notes: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    _count: ParkedOrderCountAggregateOutputType | null
    _avg: ParkedOrderAvgAggregateOutputType | null
    _sum: ParkedOrderSumAggregateOutputType | null
    _min: ParkedOrderMinAggregateOutputType | null
    _max: ParkedOrderMaxAggregateOutputType | null
  }

  type GetParkedOrderGroupByPayload<T extends ParkedOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParkedOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParkedOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParkedOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ParkedOrderGroupByOutputType[P]>
        }
      >
    >


  export type ParkedOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parkNumber?: boolean
    orderId?: boolean
    customerId?: boolean
    parkedBy?: boolean
    parkedAt?: boolean
    expiryDate?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkedOrder"]>

  export type ParkedOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parkNumber?: boolean
    orderId?: boolean
    customerId?: boolean
    parkedBy?: boolean
    parkedAt?: boolean
    expiryDate?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkedOrder"]>

  export type ParkedOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parkNumber?: boolean
    orderId?: boolean
    customerId?: boolean
    parkedBy?: boolean
    parkedAt?: boolean
    expiryDate?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parkedOrder"]>

  export type ParkedOrderSelectScalar = {
    id?: boolean
    parkNumber?: boolean
    orderId?: boolean
    customerId?: boolean
    parkedBy?: boolean
    parkedAt?: boolean
    expiryDate?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
  }

  export type ParkedOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parkNumber" | "orderId" | "customerId" | "parkedBy" | "parkedAt" | "expiryDate" | "notes" | "syncVersion" | "lastSyncedAt" | "isDirty", ExtArgs["result"]["parkedOrder"]>
  export type ParkedOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type ParkedOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }
  export type ParkedOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | SaleOrderDefaultArgs<ExtArgs>
  }

  export type $ParkedOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParkedOrder"
    objects: {
      order: Prisma.$SaleOrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parkNumber: string
      orderId: string
      customerId: string | null
      parkedBy: string | null
      parkedAt: Date
      expiryDate: Date | null
      notes: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
    }, ExtArgs["result"]["parkedOrder"]>
    composites: {}
  }

  type ParkedOrderGetPayload<S extends boolean | null | undefined | ParkedOrderDefaultArgs> = $Result.GetResult<Prisma.$ParkedOrderPayload, S>

  type ParkedOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParkedOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParkedOrderCountAggregateInputType | true
    }

  export interface ParkedOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParkedOrder'], meta: { name: 'ParkedOrder' } }
    /**
     * Find zero or one ParkedOrder that matches the filter.
     * @param {ParkedOrderFindUniqueArgs} args - Arguments to find a ParkedOrder
     * @example
     * // Get one ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParkedOrderFindUniqueArgs>(args: SelectSubset<T, ParkedOrderFindUniqueArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ParkedOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParkedOrderFindUniqueOrThrowArgs} args - Arguments to find a ParkedOrder
     * @example
     * // Get one ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParkedOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ParkedOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkedOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderFindFirstArgs} args - Arguments to find a ParkedOrder
     * @example
     * // Get one ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParkedOrderFindFirstArgs>(args?: SelectSubset<T, ParkedOrderFindFirstArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ParkedOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderFindFirstOrThrowArgs} args - Arguments to find a ParkedOrder
     * @example
     * // Get one ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParkedOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ParkedOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ParkedOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParkedOrders
     * const parkedOrders = await prisma.parkedOrder.findMany()
     * 
     * // Get first 10 ParkedOrders
     * const parkedOrders = await prisma.parkedOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parkedOrderWithIdOnly = await prisma.parkedOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParkedOrderFindManyArgs>(args?: SelectSubset<T, ParkedOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ParkedOrder.
     * @param {ParkedOrderCreateArgs} args - Arguments to create a ParkedOrder.
     * @example
     * // Create one ParkedOrder
     * const ParkedOrder = await prisma.parkedOrder.create({
     *   data: {
     *     // ... data to create a ParkedOrder
     *   }
     * })
     * 
     */
    create<T extends ParkedOrderCreateArgs>(args: SelectSubset<T, ParkedOrderCreateArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ParkedOrders.
     * @param {ParkedOrderCreateManyArgs} args - Arguments to create many ParkedOrders.
     * @example
     * // Create many ParkedOrders
     * const parkedOrder = await prisma.parkedOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParkedOrderCreateManyArgs>(args?: SelectSubset<T, ParkedOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParkedOrders and returns the data saved in the database.
     * @param {ParkedOrderCreateManyAndReturnArgs} args - Arguments to create many ParkedOrders.
     * @example
     * // Create many ParkedOrders
     * const parkedOrder = await prisma.parkedOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParkedOrders and only return the `id`
     * const parkedOrderWithIdOnly = await prisma.parkedOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParkedOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ParkedOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ParkedOrder.
     * @param {ParkedOrderDeleteArgs} args - Arguments to delete one ParkedOrder.
     * @example
     * // Delete one ParkedOrder
     * const ParkedOrder = await prisma.parkedOrder.delete({
     *   where: {
     *     // ... filter to delete one ParkedOrder
     *   }
     * })
     * 
     */
    delete<T extends ParkedOrderDeleteArgs>(args: SelectSubset<T, ParkedOrderDeleteArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ParkedOrder.
     * @param {ParkedOrderUpdateArgs} args - Arguments to update one ParkedOrder.
     * @example
     * // Update one ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParkedOrderUpdateArgs>(args: SelectSubset<T, ParkedOrderUpdateArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ParkedOrders.
     * @param {ParkedOrderDeleteManyArgs} args - Arguments to filter ParkedOrders to delete.
     * @example
     * // Delete a few ParkedOrders
     * const { count } = await prisma.parkedOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParkedOrderDeleteManyArgs>(args?: SelectSubset<T, ParkedOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkedOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParkedOrders
     * const parkedOrder = await prisma.parkedOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParkedOrderUpdateManyArgs>(args: SelectSubset<T, ParkedOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParkedOrders and returns the data updated in the database.
     * @param {ParkedOrderUpdateManyAndReturnArgs} args - Arguments to update many ParkedOrders.
     * @example
     * // Update many ParkedOrders
     * const parkedOrder = await prisma.parkedOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ParkedOrders and only return the `id`
     * const parkedOrderWithIdOnly = await prisma.parkedOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParkedOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ParkedOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ParkedOrder.
     * @param {ParkedOrderUpsertArgs} args - Arguments to update or create a ParkedOrder.
     * @example
     * // Update or create a ParkedOrder
     * const parkedOrder = await prisma.parkedOrder.upsert({
     *   create: {
     *     // ... data to create a ParkedOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParkedOrder we want to update
     *   }
     * })
     */
    upsert<T extends ParkedOrderUpsertArgs>(args: SelectSubset<T, ParkedOrderUpsertArgs<ExtArgs>>): Prisma__ParkedOrderClient<$Result.GetResult<Prisma.$ParkedOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ParkedOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderCountArgs} args - Arguments to filter ParkedOrders to count.
     * @example
     * // Count the number of ParkedOrders
     * const count = await prisma.parkedOrder.count({
     *   where: {
     *     // ... the filter for the ParkedOrders we want to count
     *   }
     * })
    **/
    count<T extends ParkedOrderCountArgs>(
      args?: Subset<T, ParkedOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParkedOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParkedOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParkedOrderAggregateArgs>(args: Subset<T, ParkedOrderAggregateArgs>): Prisma.PrismaPromise<GetParkedOrderAggregateType<T>>

    /**
     * Group by ParkedOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParkedOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParkedOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParkedOrderGroupByArgs['orderBy'] }
        : { orderBy?: ParkedOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParkedOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParkedOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParkedOrder model
   */
  readonly fields: ParkedOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParkedOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParkedOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends SaleOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleOrderDefaultArgs<ExtArgs>>): Prisma__SaleOrderClient<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParkedOrder model
   */
  interface ParkedOrderFieldRefs {
    readonly id: FieldRef<"ParkedOrder", 'String'>
    readonly parkNumber: FieldRef<"ParkedOrder", 'String'>
    readonly orderId: FieldRef<"ParkedOrder", 'String'>
    readonly customerId: FieldRef<"ParkedOrder", 'String'>
    readonly parkedBy: FieldRef<"ParkedOrder", 'String'>
    readonly parkedAt: FieldRef<"ParkedOrder", 'DateTime'>
    readonly expiryDate: FieldRef<"ParkedOrder", 'DateTime'>
    readonly notes: FieldRef<"ParkedOrder", 'String'>
    readonly syncVersion: FieldRef<"ParkedOrder", 'Int'>
    readonly lastSyncedAt: FieldRef<"ParkedOrder", 'DateTime'>
    readonly isDirty: FieldRef<"ParkedOrder", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ParkedOrder findUnique
   */
  export type ParkedOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter, which ParkedOrder to fetch.
     */
    where: ParkedOrderWhereUniqueInput
  }

  /**
   * ParkedOrder findUniqueOrThrow
   */
  export type ParkedOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter, which ParkedOrder to fetch.
     */
    where: ParkedOrderWhereUniqueInput
  }

  /**
   * ParkedOrder findFirst
   */
  export type ParkedOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter, which ParkedOrder to fetch.
     */
    where?: ParkedOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkedOrders to fetch.
     */
    orderBy?: ParkedOrderOrderByWithRelationInput | ParkedOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkedOrders.
     */
    cursor?: ParkedOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkedOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkedOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkedOrders.
     */
    distinct?: ParkedOrderScalarFieldEnum | ParkedOrderScalarFieldEnum[]
  }

  /**
   * ParkedOrder findFirstOrThrow
   */
  export type ParkedOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter, which ParkedOrder to fetch.
     */
    where?: ParkedOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkedOrders to fetch.
     */
    orderBy?: ParkedOrderOrderByWithRelationInput | ParkedOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParkedOrders.
     */
    cursor?: ParkedOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkedOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkedOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParkedOrders.
     */
    distinct?: ParkedOrderScalarFieldEnum | ParkedOrderScalarFieldEnum[]
  }

  /**
   * ParkedOrder findMany
   */
  export type ParkedOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter, which ParkedOrders to fetch.
     */
    where?: ParkedOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParkedOrders to fetch.
     */
    orderBy?: ParkedOrderOrderByWithRelationInput | ParkedOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParkedOrders.
     */
    cursor?: ParkedOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParkedOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParkedOrders.
     */
    skip?: number
    distinct?: ParkedOrderScalarFieldEnum | ParkedOrderScalarFieldEnum[]
  }

  /**
   * ParkedOrder create
   */
  export type ParkedOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ParkedOrder.
     */
    data: XOR<ParkedOrderCreateInput, ParkedOrderUncheckedCreateInput>
  }

  /**
   * ParkedOrder createMany
   */
  export type ParkedOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParkedOrders.
     */
    data: ParkedOrderCreateManyInput | ParkedOrderCreateManyInput[]
  }

  /**
   * ParkedOrder createManyAndReturn
   */
  export type ParkedOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ParkedOrders.
     */
    data: ParkedOrderCreateManyInput | ParkedOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkedOrder update
   */
  export type ParkedOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ParkedOrder.
     */
    data: XOR<ParkedOrderUpdateInput, ParkedOrderUncheckedUpdateInput>
    /**
     * Choose, which ParkedOrder to update.
     */
    where: ParkedOrderWhereUniqueInput
  }

  /**
   * ParkedOrder updateMany
   */
  export type ParkedOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParkedOrders.
     */
    data: XOR<ParkedOrderUpdateManyMutationInput, ParkedOrderUncheckedUpdateManyInput>
    /**
     * Filter which ParkedOrders to update
     */
    where?: ParkedOrderWhereInput
    /**
     * Limit how many ParkedOrders to update.
     */
    limit?: number
  }

  /**
   * ParkedOrder updateManyAndReturn
   */
  export type ParkedOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * The data used to update ParkedOrders.
     */
    data: XOR<ParkedOrderUpdateManyMutationInput, ParkedOrderUncheckedUpdateManyInput>
    /**
     * Filter which ParkedOrders to update
     */
    where?: ParkedOrderWhereInput
    /**
     * Limit how many ParkedOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParkedOrder upsert
   */
  export type ParkedOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ParkedOrder to update in case it exists.
     */
    where: ParkedOrderWhereUniqueInput
    /**
     * In case the ParkedOrder found by the `where` argument doesn't exist, create a new ParkedOrder with this data.
     */
    create: XOR<ParkedOrderCreateInput, ParkedOrderUncheckedCreateInput>
    /**
     * In case the ParkedOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParkedOrderUpdateInput, ParkedOrderUncheckedUpdateInput>
  }

  /**
   * ParkedOrder delete
   */
  export type ParkedOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
    /**
     * Filter which ParkedOrder to delete.
     */
    where: ParkedOrderWhereUniqueInput
  }

  /**
   * ParkedOrder deleteMany
   */
  export type ParkedOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParkedOrders to delete
     */
    where?: ParkedOrderWhereInput
    /**
     * Limit how many ParkedOrders to delete.
     */
    limit?: number
  }

  /**
   * ParkedOrder without action
   */
  export type ParkedOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParkedOrder
     */
    select?: ParkedOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ParkedOrder
     */
    omit?: ParkedOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParkedOrderInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    openingCash: number | null
    closingCash: number | null
    expectedCash: number | null
    cashDifference: number | null
    totalSales: number | null
    totalRefunds: number | null
    totalTransactions: number | null
    syncVersion: number | null
  }

  export type ShiftSumAggregateOutputType = {
    openingCash: number | null
    closingCash: number | null
    expectedCash: number | null
    cashDifference: number | null
    totalSales: number | null
    totalRefunds: number | null
    totalTransactions: number | null
    syncVersion: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    locationId: string | null
    terminalId: string | null
    userId: string | null
    shiftNumber: string | null
    registerId: string | null
    openingCash: number | null
    closingCash: number | null
    expectedCash: number | null
    cashDifference: number | null
    totalSales: number | null
    totalRefunds: number | null
    totalTransactions: number | null
    openedAt: Date | null
    closedAt: Date | null
    status: $Enums.ShiftStatus | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    locationId: string | null
    terminalId: string | null
    userId: string | null
    shiftNumber: string | null
    registerId: string | null
    openingCash: number | null
    closingCash: number | null
    expectedCash: number | null
    cashDifference: number | null
    totalSales: number | null
    totalRefunds: number | null
    totalTransactions: number | null
    openedAt: Date | null
    closedAt: Date | null
    status: $Enums.ShiftStatus | null
    notes: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    locationId: number
    terminalId: number
    userId: number
    shiftNumber: number
    registerId: number
    openingCash: number
    closingCash: number
    expectedCash: number
    cashDifference: number
    totalSales: number
    totalRefunds: number
    totalTransactions: number
    openedAt: number
    closedAt: number
    status: number
    notes: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    openingCash?: true
    closingCash?: true
    expectedCash?: true
    cashDifference?: true
    totalSales?: true
    totalRefunds?: true
    totalTransactions?: true
    syncVersion?: true
  }

  export type ShiftSumAggregateInputType = {
    openingCash?: true
    closingCash?: true
    expectedCash?: true
    cashDifference?: true
    totalSales?: true
    totalRefunds?: true
    totalTransactions?: true
    syncVersion?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    userId?: true
    shiftNumber?: true
    registerId?: true
    openingCash?: true
    closingCash?: true
    expectedCash?: true
    cashDifference?: true
    totalSales?: true
    totalRefunds?: true
    totalTransactions?: true
    openedAt?: true
    closedAt?: true
    status?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    userId?: true
    shiftNumber?: true
    registerId?: true
    openingCash?: true
    closingCash?: true
    expectedCash?: true
    cashDifference?: true
    totalSales?: true
    totalRefunds?: true
    totalTransactions?: true
    openedAt?: true
    closedAt?: true
    status?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    locationId?: true
    terminalId?: true
    userId?: true
    shiftNumber?: true
    registerId?: true
    openingCash?: true
    closingCash?: true
    expectedCash?: true
    cashDifference?: true
    totalSales?: true
    totalRefunds?: true
    totalTransactions?: true
    openedAt?: true
    closedAt?: true
    status?: true
    notes?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    locationId: string
    terminalId: string | null
    userId: string
    shiftNumber: string
    registerId: string | null
    openingCash: number
    closingCash: number | null
    expectedCash: number | null
    cashDifference: number | null
    totalSales: number
    totalRefunds: number
    totalTransactions: number
    openedAt: Date
    closedAt: Date | null
    status: $Enums.ShiftStatus
    notes: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    userId?: boolean
    shiftNumber?: boolean
    registerId?: boolean
    openingCash?: boolean
    closingCash?: boolean
    expectedCash?: boolean
    cashDifference?: boolean
    totalSales?: boolean
    totalRefunds?: boolean
    totalTransactions?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    saleOrders?: boolean | Shift$saleOrdersArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    userId?: boolean
    shiftNumber?: boolean
    registerId?: boolean
    openingCash?: boolean
    closingCash?: boolean
    expectedCash?: boolean
    cashDifference?: boolean
    totalSales?: boolean
    totalRefunds?: boolean
    totalTransactions?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    userId?: boolean
    shiftNumber?: boolean
    registerId?: boolean
    openingCash?: boolean
    closingCash?: boolean
    expectedCash?: boolean
    cashDifference?: boolean
    totalSales?: boolean
    totalRefunds?: boolean
    totalTransactions?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    locationId?: boolean
    terminalId?: boolean
    userId?: boolean
    shiftNumber?: boolean
    registerId?: boolean
    openingCash?: boolean
    closingCash?: boolean
    expectedCash?: boolean
    cashDifference?: boolean
    totalSales?: boolean
    totalRefunds?: boolean
    totalTransactions?: boolean
    openedAt?: boolean
    closedAt?: boolean
    status?: boolean
    notes?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "locationId" | "terminalId" | "userId" | "shiftNumber" | "registerId" | "openingCash" | "closingCash" | "expectedCash" | "cashDifference" | "totalSales" | "totalRefunds" | "totalTransactions" | "openedAt" | "closedAt" | "status" | "notes" | "syncVersion" | "lastSyncedAt" | "isDirty", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
    saleOrders?: boolean | Shift$saleOrdersArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    location?: boolean | LocationDefaultArgs<ExtArgs>
    terminal?: boolean | Shift$terminalArgs<ExtArgs>
    user?: boolean | LocalUserDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      location: Prisma.$LocationPayload<ExtArgs>
      terminal: Prisma.$TerminalPayload<ExtArgs> | null
      user: Prisma.$LocalUserPayload<ExtArgs>
      saleOrders: Prisma.$SaleOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      locationId: string
      terminalId: string | null
      userId: string
      shiftNumber: string
      registerId: string | null
      openingCash: number
      closingCash: number | null
      expectedCash: number | null
      cashDifference: number | null
      totalSales: number
      totalRefunds: number
      totalTransactions: number
      openedAt: Date
      closedAt: Date | null
      status: $Enums.ShiftStatus
      notes: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    terminal<T extends Shift$terminalArgs<ExtArgs> = {}>(args?: Subset<T, Shift$terminalArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends LocalUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocalUserDefaultArgs<ExtArgs>>): Prisma__LocalUserClient<$Result.GetResult<Prisma.$LocalUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    saleOrders<T extends Shift$saleOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Shift$saleOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly locationId: FieldRef<"Shift", 'String'>
    readonly terminalId: FieldRef<"Shift", 'String'>
    readonly userId: FieldRef<"Shift", 'String'>
    readonly shiftNumber: FieldRef<"Shift", 'String'>
    readonly registerId: FieldRef<"Shift", 'String'>
    readonly openingCash: FieldRef<"Shift", 'Float'>
    readonly closingCash: FieldRef<"Shift", 'Float'>
    readonly expectedCash: FieldRef<"Shift", 'Float'>
    readonly cashDifference: FieldRef<"Shift", 'Float'>
    readonly totalSales: FieldRef<"Shift", 'Float'>
    readonly totalRefunds: FieldRef<"Shift", 'Float'>
    readonly totalTransactions: FieldRef<"Shift", 'Int'>
    readonly openedAt: FieldRef<"Shift", 'DateTime'>
    readonly closedAt: FieldRef<"Shift", 'DateTime'>
    readonly status: FieldRef<"Shift", 'ShiftStatus'>
    readonly notes: FieldRef<"Shift", 'String'>
    readonly syncVersion: FieldRef<"Shift", 'Int'>
    readonly lastSyncedAt: FieldRef<"Shift", 'DateTime'>
    readonly isDirty: FieldRef<"Shift", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift.terminal
   */
  export type Shift$terminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Terminal
     */
    omit?: TerminalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    where?: TerminalWhereInput
  }

  /**
   * Shift.saleOrders
   */
  export type Shift$saleOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleOrder
     */
    select?: SaleOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleOrder
     */
    omit?: SaleOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleOrderInclude<ExtArgs> | null
    where?: SaleOrderWhereInput
    orderBy?: SaleOrderOrderByWithRelationInput | SaleOrderOrderByWithRelationInput[]
    cursor?: SaleOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleOrderScalarFieldEnum | SaleOrderScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model TaxCategory
   */

  export type AggregateTaxCategory = {
    _count: TaxCategoryCountAggregateOutputType | null
    _avg: TaxCategoryAvgAggregateOutputType | null
    _sum: TaxCategorySumAggregateOutputType | null
    _min: TaxCategoryMinAggregateOutputType | null
    _max: TaxCategoryMaxAggregateOutputType | null
  }

  export type TaxCategoryAvgAggregateOutputType = {
    syncVersion: number | null
  }

  export type TaxCategorySumAggregateOutputType = {
    syncVersion: number | null
  }

  export type TaxCategoryMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCategoryMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    description: string | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxCategoryCountAggregateOutputType = {
    id: number
    code: number
    name: number
    description: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxCategoryAvgAggregateInputType = {
    syncVersion?: true
  }

  export type TaxCategorySumAggregateInputType = {
    syncVersion?: true
  }

  export type TaxCategoryMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCategoryMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxCategoryCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    description?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCategory to aggregate.
     */
    where?: TaxCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCategories to fetch.
     */
    orderBy?: TaxCategoryOrderByWithRelationInput | TaxCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxCategories
    **/
    _count?: true | TaxCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxCategoryMaxAggregateInputType
  }

  export type GetTaxCategoryAggregateType<T extends TaxCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxCategory[P]>
      : GetScalarType<T[P], AggregateTaxCategory[P]>
  }




  export type TaxCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxCategoryWhereInput
    orderBy?: TaxCategoryOrderByWithAggregationInput | TaxCategoryOrderByWithAggregationInput[]
    by: TaxCategoryScalarFieldEnum[] | TaxCategoryScalarFieldEnum
    having?: TaxCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxCategoryCountAggregateInputType | true
    _avg?: TaxCategoryAvgAggregateInputType
    _sum?: TaxCategorySumAggregateInputType
    _min?: TaxCategoryMinAggregateInputType
    _max?: TaxCategoryMaxAggregateInputType
  }

  export type TaxCategoryGroupByOutputType = {
    id: string
    code: string
    name: string
    description: string | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaxCategoryCountAggregateOutputType | null
    _avg: TaxCategoryAvgAggregateOutputType | null
    _sum: TaxCategorySumAggregateOutputType | null
    _min: TaxCategoryMinAggregateOutputType | null
    _max: TaxCategoryMaxAggregateOutputType | null
  }

  type GetTaxCategoryGroupByPayload<T extends TaxCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TaxCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TaxCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | TaxCategory$productsArgs<ExtArgs>
    rates?: boolean | TaxCategory$ratesArgs<ExtArgs>
    _count?: boolean | TaxCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxCategory"]>

  export type TaxCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxCategory"]>

  export type TaxCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["taxCategory"]>

  export type TaxCategorySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    description?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "description" | "syncVersion" | "lastSyncedAt" | "isDirty" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["taxCategory"]>
  export type TaxCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | TaxCategory$productsArgs<ExtArgs>
    rates?: boolean | TaxCategory$ratesArgs<ExtArgs>
    _count?: boolean | TaxCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaxCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaxCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaxCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxCategory"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
      rates: Prisma.$TaxRatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      description: string | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxCategory"]>
    composites: {}
  }

  type TaxCategoryGetPayload<S extends boolean | null | undefined | TaxCategoryDefaultArgs> = $Result.GetResult<Prisma.$TaxCategoryPayload, S>

  type TaxCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxCategoryCountAggregateInputType | true
    }

  export interface TaxCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxCategory'], meta: { name: 'TaxCategory' } }
    /**
     * Find zero or one TaxCategory that matches the filter.
     * @param {TaxCategoryFindUniqueArgs} args - Arguments to find a TaxCategory
     * @example
     * // Get one TaxCategory
     * const taxCategory = await prisma.taxCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxCategoryFindUniqueArgs>(args: SelectSubset<T, TaxCategoryFindUniqueArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxCategoryFindUniqueOrThrowArgs} args - Arguments to find a TaxCategory
     * @example
     * // Get one TaxCategory
     * const taxCategory = await prisma.taxCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryFindFirstArgs} args - Arguments to find a TaxCategory
     * @example
     * // Get one TaxCategory
     * const taxCategory = await prisma.taxCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxCategoryFindFirstArgs>(args?: SelectSubset<T, TaxCategoryFindFirstArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryFindFirstOrThrowArgs} args - Arguments to find a TaxCategory
     * @example
     * // Get one TaxCategory
     * const taxCategory = await prisma.taxCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxCategories
     * const taxCategories = await prisma.taxCategory.findMany()
     * 
     * // Get first 10 TaxCategories
     * const taxCategories = await prisma.taxCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxCategoryWithIdOnly = await prisma.taxCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxCategoryFindManyArgs>(args?: SelectSubset<T, TaxCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxCategory.
     * @param {TaxCategoryCreateArgs} args - Arguments to create a TaxCategory.
     * @example
     * // Create one TaxCategory
     * const TaxCategory = await prisma.taxCategory.create({
     *   data: {
     *     // ... data to create a TaxCategory
     *   }
     * })
     * 
     */
    create<T extends TaxCategoryCreateArgs>(args: SelectSubset<T, TaxCategoryCreateArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxCategories.
     * @param {TaxCategoryCreateManyArgs} args - Arguments to create many TaxCategories.
     * @example
     * // Create many TaxCategories
     * const taxCategory = await prisma.taxCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxCategoryCreateManyArgs>(args?: SelectSubset<T, TaxCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxCategories and returns the data saved in the database.
     * @param {TaxCategoryCreateManyAndReturnArgs} args - Arguments to create many TaxCategories.
     * @example
     * // Create many TaxCategories
     * const taxCategory = await prisma.taxCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxCategories and only return the `id`
     * const taxCategoryWithIdOnly = await prisma.taxCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxCategory.
     * @param {TaxCategoryDeleteArgs} args - Arguments to delete one TaxCategory.
     * @example
     * // Delete one TaxCategory
     * const TaxCategory = await prisma.taxCategory.delete({
     *   where: {
     *     // ... filter to delete one TaxCategory
     *   }
     * })
     * 
     */
    delete<T extends TaxCategoryDeleteArgs>(args: SelectSubset<T, TaxCategoryDeleteArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxCategory.
     * @param {TaxCategoryUpdateArgs} args - Arguments to update one TaxCategory.
     * @example
     * // Update one TaxCategory
     * const taxCategory = await prisma.taxCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxCategoryUpdateArgs>(args: SelectSubset<T, TaxCategoryUpdateArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxCategories.
     * @param {TaxCategoryDeleteManyArgs} args - Arguments to filter TaxCategories to delete.
     * @example
     * // Delete a few TaxCategories
     * const { count } = await prisma.taxCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxCategoryDeleteManyArgs>(args?: SelectSubset<T, TaxCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxCategories
     * const taxCategory = await prisma.taxCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxCategoryUpdateManyArgs>(args: SelectSubset<T, TaxCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxCategories and returns the data updated in the database.
     * @param {TaxCategoryUpdateManyAndReturnArgs} args - Arguments to update many TaxCategories.
     * @example
     * // Update many TaxCategories
     * const taxCategory = await prisma.taxCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxCategories and only return the `id`
     * const taxCategoryWithIdOnly = await prisma.taxCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxCategory.
     * @param {TaxCategoryUpsertArgs} args - Arguments to update or create a TaxCategory.
     * @example
     * // Update or create a TaxCategory
     * const taxCategory = await prisma.taxCategory.upsert({
     *   create: {
     *     // ... data to create a TaxCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxCategory we want to update
     *   }
     * })
     */
    upsert<T extends TaxCategoryUpsertArgs>(args: SelectSubset<T, TaxCategoryUpsertArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryCountArgs} args - Arguments to filter TaxCategories to count.
     * @example
     * // Count the number of TaxCategories
     * const count = await prisma.taxCategory.count({
     *   where: {
     *     // ... the filter for the TaxCategories we want to count
     *   }
     * })
    **/
    count<T extends TaxCategoryCountArgs>(
      args?: Subset<T, TaxCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxCategoryAggregateArgs>(args: Subset<T, TaxCategoryAggregateArgs>): Prisma.PrismaPromise<GetTaxCategoryAggregateType<T>>

    /**
     * Group by TaxCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TaxCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxCategory model
   */
  readonly fields: TaxCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends TaxCategory$productsArgs<ExtArgs> = {}>(args?: Subset<T, TaxCategory$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rates<T extends TaxCategory$ratesArgs<ExtArgs> = {}>(args?: Subset<T, TaxCategory$ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxCategory model
   */
  interface TaxCategoryFieldRefs {
    readonly id: FieldRef<"TaxCategory", 'String'>
    readonly code: FieldRef<"TaxCategory", 'String'>
    readonly name: FieldRef<"TaxCategory", 'String'>
    readonly description: FieldRef<"TaxCategory", 'String'>
    readonly syncVersion: FieldRef<"TaxCategory", 'Int'>
    readonly lastSyncedAt: FieldRef<"TaxCategory", 'DateTime'>
    readonly isDirty: FieldRef<"TaxCategory", 'Boolean'>
    readonly isActive: FieldRef<"TaxCategory", 'Boolean'>
    readonly createdAt: FieldRef<"TaxCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxCategory findUnique
   */
  export type TaxCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TaxCategory to fetch.
     */
    where: TaxCategoryWhereUniqueInput
  }

  /**
   * TaxCategory findUniqueOrThrow
   */
  export type TaxCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TaxCategory to fetch.
     */
    where: TaxCategoryWhereUniqueInput
  }

  /**
   * TaxCategory findFirst
   */
  export type TaxCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TaxCategory to fetch.
     */
    where?: TaxCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCategories to fetch.
     */
    orderBy?: TaxCategoryOrderByWithRelationInput | TaxCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCategories.
     */
    cursor?: TaxCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCategories.
     */
    distinct?: TaxCategoryScalarFieldEnum | TaxCategoryScalarFieldEnum[]
  }

  /**
   * TaxCategory findFirstOrThrow
   */
  export type TaxCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TaxCategory to fetch.
     */
    where?: TaxCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCategories to fetch.
     */
    orderBy?: TaxCategoryOrderByWithRelationInput | TaxCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxCategories.
     */
    cursor?: TaxCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxCategories.
     */
    distinct?: TaxCategoryScalarFieldEnum | TaxCategoryScalarFieldEnum[]
  }

  /**
   * TaxCategory findMany
   */
  export type TaxCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TaxCategories to fetch.
     */
    where?: TaxCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxCategories to fetch.
     */
    orderBy?: TaxCategoryOrderByWithRelationInput | TaxCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxCategories.
     */
    cursor?: TaxCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxCategories.
     */
    skip?: number
    distinct?: TaxCategoryScalarFieldEnum | TaxCategoryScalarFieldEnum[]
  }

  /**
   * TaxCategory create
   */
  export type TaxCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxCategory.
     */
    data: XOR<TaxCategoryCreateInput, TaxCategoryUncheckedCreateInput>
  }

  /**
   * TaxCategory createMany
   */
  export type TaxCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxCategories.
     */
    data: TaxCategoryCreateManyInput | TaxCategoryCreateManyInput[]
  }

  /**
   * TaxCategory createManyAndReturn
   */
  export type TaxCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many TaxCategories.
     */
    data: TaxCategoryCreateManyInput | TaxCategoryCreateManyInput[]
  }

  /**
   * TaxCategory update
   */
  export type TaxCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxCategory.
     */
    data: XOR<TaxCategoryUpdateInput, TaxCategoryUncheckedUpdateInput>
    /**
     * Choose, which TaxCategory to update.
     */
    where: TaxCategoryWhereUniqueInput
  }

  /**
   * TaxCategory updateMany
   */
  export type TaxCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxCategories.
     */
    data: XOR<TaxCategoryUpdateManyMutationInput, TaxCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TaxCategories to update
     */
    where?: TaxCategoryWhereInput
    /**
     * Limit how many TaxCategories to update.
     */
    limit?: number
  }

  /**
   * TaxCategory updateManyAndReturn
   */
  export type TaxCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * The data used to update TaxCategories.
     */
    data: XOR<TaxCategoryUpdateManyMutationInput, TaxCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TaxCategories to update
     */
    where?: TaxCategoryWhereInput
    /**
     * Limit how many TaxCategories to update.
     */
    limit?: number
  }

  /**
   * TaxCategory upsert
   */
  export type TaxCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxCategory to update in case it exists.
     */
    where: TaxCategoryWhereUniqueInput
    /**
     * In case the TaxCategory found by the `where` argument doesn't exist, create a new TaxCategory with this data.
     */
    create: XOR<TaxCategoryCreateInput, TaxCategoryUncheckedCreateInput>
    /**
     * In case the TaxCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxCategoryUpdateInput, TaxCategoryUncheckedUpdateInput>
  }

  /**
   * TaxCategory delete
   */
  export type TaxCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
    /**
     * Filter which TaxCategory to delete.
     */
    where: TaxCategoryWhereUniqueInput
  }

  /**
   * TaxCategory deleteMany
   */
  export type TaxCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxCategories to delete
     */
    where?: TaxCategoryWhereInput
    /**
     * Limit how many TaxCategories to delete.
     */
    limit?: number
  }

  /**
   * TaxCategory.products
   */
  export type TaxCategory$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * TaxCategory.rates
   */
  export type TaxCategory$ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    where?: TaxRateWhereInput
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    cursor?: TaxRateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxCategory without action
   */
  export type TaxCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxCategory
     */
    select?: TaxCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxCategory
     */
    omit?: TaxCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxCategoryInclude<ExtArgs> | null
  }


  /**
   * Model TaxRate
   */

  export type AggregateTaxRate = {
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  export type TaxRateAvgAggregateOutputType = {
    rate: number | null
    syncVersion: number | null
  }

  export type TaxRateSumAggregateOutputType = {
    rate: number | null
    syncVersion: number | null
  }

  export type TaxRateMinAggregateOutputType = {
    id: string | null
    taxCategoryId: string | null
    name: string | null
    rate: number | null
    country: string | null
    state: string | null
    city: string | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateMaxAggregateOutputType = {
    id: string | null
    taxCategoryId: string | null
    name: string | null
    rate: number | null
    country: string | null
    state: string | null
    city: string | null
    isActive: boolean | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    syncVersion: number | null
    lastSyncedAt: Date | null
    isDirty: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaxRateCountAggregateOutputType = {
    id: number
    taxCategoryId: number
    name: number
    rate: number
    country: number
    state: number
    city: number
    isActive: number
    effectiveFrom: number
    effectiveTo: number
    syncVersion: number
    lastSyncedAt: number
    isDirty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaxRateAvgAggregateInputType = {
    rate?: true
    syncVersion?: true
  }

  export type TaxRateSumAggregateInputType = {
    rate?: true
    syncVersion?: true
  }

  export type TaxRateMinAggregateInputType = {
    id?: true
    taxCategoryId?: true
    name?: true
    rate?: true
    country?: true
    state?: true
    city?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateMaxAggregateInputType = {
    id?: true
    taxCategoryId?: true
    name?: true
    rate?: true
    country?: true
    state?: true
    city?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaxRateCountAggregateInputType = {
    id?: true
    taxCategoryId?: true
    name?: true
    rate?: true
    country?: true
    state?: true
    city?: true
    isActive?: true
    effectiveFrom?: true
    effectiveTo?: true
    syncVersion?: true
    lastSyncedAt?: true
    isDirty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaxRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRate to aggregate.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxRates
    **/
    _count?: true | TaxRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxRateMaxAggregateInputType
  }

  export type GetTaxRateAggregateType<T extends TaxRateAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxRate[P]>
      : GetScalarType<T[P], AggregateTaxRate[P]>
  }




  export type TaxRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxRateWhereInput
    orderBy?: TaxRateOrderByWithAggregationInput | TaxRateOrderByWithAggregationInput[]
    by: TaxRateScalarFieldEnum[] | TaxRateScalarFieldEnum
    having?: TaxRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxRateCountAggregateInputType | true
    _avg?: TaxRateAvgAggregateInputType
    _sum?: TaxRateSumAggregateInputType
    _min?: TaxRateMinAggregateInputType
    _max?: TaxRateMaxAggregateInputType
  }

  export type TaxRateGroupByOutputType = {
    id: string
    taxCategoryId: string
    name: string
    rate: number
    country: string | null
    state: string | null
    city: string | null
    isActive: boolean
    effectiveFrom: Date
    effectiveTo: Date | null
    syncVersion: number
    lastSyncedAt: Date | null
    isDirty: boolean
    createdAt: Date
    updatedAt: Date
    _count: TaxRateCountAggregateOutputType | null
    _avg: TaxRateAvgAggregateOutputType | null
    _sum: TaxRateSumAggregateOutputType | null
    _min: TaxRateMinAggregateOutputType | null
    _max: TaxRateMaxAggregateOutputType | null
  }

  type GetTaxRateGroupByPayload<T extends TaxRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
            : GetScalarType<T[P], TaxRateGroupByOutputType[P]>
        }
      >
    >


  export type TaxRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxCategoryId?: boolean
    name?: boolean
    rate?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxCategoryId?: boolean
    name?: boolean
    rate?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxCategoryId?: boolean
    name?: boolean
    rate?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxRate"]>

  export type TaxRateSelectScalar = {
    id?: boolean
    taxCategoryId?: boolean
    name?: boolean
    rate?: boolean
    country?: boolean
    state?: boolean
    city?: boolean
    isActive?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    syncVersion?: boolean
    lastSyncedAt?: boolean
    isDirty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaxRateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taxCategoryId" | "name" | "rate" | "country" | "state" | "city" | "isActive" | "effectiveFrom" | "effectiveTo" | "syncVersion" | "lastSyncedAt" | "isDirty" | "createdAt" | "updatedAt", ExtArgs["result"]["taxRate"]>
  export type TaxRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }
  export type TaxRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }
  export type TaxRateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taxCategory?: boolean | TaxCategoryDefaultArgs<ExtArgs>
  }

  export type $TaxRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxRate"
    objects: {
      taxCategory: Prisma.$TaxCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taxCategoryId: string
      name: string
      rate: number
      country: string | null
      state: string | null
      city: string | null
      isActive: boolean
      effectiveFrom: Date
      effectiveTo: Date | null
      syncVersion: number
      lastSyncedAt: Date | null
      isDirty: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["taxRate"]>
    composites: {}
  }

  type TaxRateGetPayload<S extends boolean | null | undefined | TaxRateDefaultArgs> = $Result.GetResult<Prisma.$TaxRatePayload, S>

  type TaxRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxRateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxRateCountAggregateInputType | true
    }

  export interface TaxRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxRate'], meta: { name: 'TaxRate' } }
    /**
     * Find zero or one TaxRate that matches the filter.
     * @param {TaxRateFindUniqueArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxRateFindUniqueArgs>(args: SelectSubset<T, TaxRateFindUniqueArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxRate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxRateFindUniqueOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxRateFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxRateFindFirstArgs>(args?: SelectSubset<T, TaxRateFindFirstArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindFirstOrThrowArgs} args - Arguments to find a TaxRate
     * @example
     * // Get one TaxRate
     * const taxRate = await prisma.taxRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxRateFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxRates
     * const taxRates = await prisma.taxRate.findMany()
     * 
     * // Get first 10 TaxRates
     * const taxRates = await prisma.taxRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxRateFindManyArgs>(args?: SelectSubset<T, TaxRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxRate.
     * @param {TaxRateCreateArgs} args - Arguments to create a TaxRate.
     * @example
     * // Create one TaxRate
     * const TaxRate = await prisma.taxRate.create({
     *   data: {
     *     // ... data to create a TaxRate
     *   }
     * })
     * 
     */
    create<T extends TaxRateCreateArgs>(args: SelectSubset<T, TaxRateCreateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxRates.
     * @param {TaxRateCreateManyArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxRateCreateManyArgs>(args?: SelectSubset<T, TaxRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxRates and returns the data saved in the database.
     * @param {TaxRateCreateManyAndReturnArgs} args - Arguments to create many TaxRates.
     * @example
     * // Create many TaxRates
     * const taxRate = await prisma.taxRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxRates and only return the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxRateCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxRate.
     * @param {TaxRateDeleteArgs} args - Arguments to delete one TaxRate.
     * @example
     * // Delete one TaxRate
     * const TaxRate = await prisma.taxRate.delete({
     *   where: {
     *     // ... filter to delete one TaxRate
     *   }
     * })
     * 
     */
    delete<T extends TaxRateDeleteArgs>(args: SelectSubset<T, TaxRateDeleteArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxRate.
     * @param {TaxRateUpdateArgs} args - Arguments to update one TaxRate.
     * @example
     * // Update one TaxRate
     * const taxRate = await prisma.taxRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxRateUpdateArgs>(args: SelectSubset<T, TaxRateUpdateArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxRates.
     * @param {TaxRateDeleteManyArgs} args - Arguments to filter TaxRates to delete.
     * @example
     * // Delete a few TaxRates
     * const { count } = await prisma.taxRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxRateDeleteManyArgs>(args?: SelectSubset<T, TaxRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxRates
     * const taxRate = await prisma.taxRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxRateUpdateManyArgs>(args: SelectSubset<T, TaxRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxRates and returns the data updated in the database.
     * @param {TaxRateUpdateManyAndReturnArgs} args - Arguments to update many TaxRates.
     * @example
     * // Update many TaxRates
     * const taxRate = await prisma.taxRate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxRates and only return the `id`
     * const taxRateWithIdOnly = await prisma.taxRate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxRateUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxRateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxRate.
     * @param {TaxRateUpsertArgs} args - Arguments to update or create a TaxRate.
     * @example
     * // Update or create a TaxRate
     * const taxRate = await prisma.taxRate.upsert({
     *   create: {
     *     // ... data to create a TaxRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxRate we want to update
     *   }
     * })
     */
    upsert<T extends TaxRateUpsertArgs>(args: SelectSubset<T, TaxRateUpsertArgs<ExtArgs>>): Prisma__TaxRateClient<$Result.GetResult<Prisma.$TaxRatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateCountArgs} args - Arguments to filter TaxRates to count.
     * @example
     * // Count the number of TaxRates
     * const count = await prisma.taxRate.count({
     *   where: {
     *     // ... the filter for the TaxRates we want to count
     *   }
     * })
    **/
    count<T extends TaxRateCountArgs>(
      args?: Subset<T, TaxRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxRateAggregateArgs>(args: Subset<T, TaxRateAggregateArgs>): Prisma.PrismaPromise<GetTaxRateAggregateType<T>>

    /**
     * Group by TaxRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxRateGroupByArgs['orderBy'] }
        : { orderBy?: TaxRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxRate model
   */
  readonly fields: TaxRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    taxCategory<T extends TaxCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaxCategoryDefaultArgs<ExtArgs>>): Prisma__TaxCategoryClient<$Result.GetResult<Prisma.$TaxCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxRate model
   */
  interface TaxRateFieldRefs {
    readonly id: FieldRef<"TaxRate", 'String'>
    readonly taxCategoryId: FieldRef<"TaxRate", 'String'>
    readonly name: FieldRef<"TaxRate", 'String'>
    readonly rate: FieldRef<"TaxRate", 'Float'>
    readonly country: FieldRef<"TaxRate", 'String'>
    readonly state: FieldRef<"TaxRate", 'String'>
    readonly city: FieldRef<"TaxRate", 'String'>
    readonly isActive: FieldRef<"TaxRate", 'Boolean'>
    readonly effectiveFrom: FieldRef<"TaxRate", 'DateTime'>
    readonly effectiveTo: FieldRef<"TaxRate", 'DateTime'>
    readonly syncVersion: FieldRef<"TaxRate", 'Int'>
    readonly lastSyncedAt: FieldRef<"TaxRate", 'DateTime'>
    readonly isDirty: FieldRef<"TaxRate", 'Boolean'>
    readonly createdAt: FieldRef<"TaxRate", 'DateTime'>
    readonly updatedAt: FieldRef<"TaxRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaxRate findUnique
   */
  export type TaxRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findUniqueOrThrow
   */
  export type TaxRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate findFirst
   */
  export type TaxRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findFirstOrThrow
   */
  export type TaxRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter, which TaxRate to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxRates.
     */
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate findMany
   */
  export type TaxRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter, which TaxRates to fetch.
     */
    where?: TaxRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxRates to fetch.
     */
    orderBy?: TaxRateOrderByWithRelationInput | TaxRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxRates.
     */
    cursor?: TaxRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxRates.
     */
    skip?: number
    distinct?: TaxRateScalarFieldEnum | TaxRateScalarFieldEnum[]
  }

  /**
   * TaxRate create
   */
  export type TaxRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxRate.
     */
    data: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
  }

  /**
   * TaxRate createMany
   */
  export type TaxRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
  }

  /**
   * TaxRate createManyAndReturn
   */
  export type TaxRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data used to create many TaxRates.
     */
    data: TaxRateCreateManyInput | TaxRateCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxRate update
   */
  export type TaxRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxRate.
     */
    data: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
    /**
     * Choose, which TaxRate to update.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate updateMany
   */
  export type TaxRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxRates.
     */
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyInput>
    /**
     * Filter which TaxRates to update
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to update.
     */
    limit?: number
  }

  /**
   * TaxRate updateManyAndReturn
   */
  export type TaxRateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * The data used to update TaxRates.
     */
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyInput>
    /**
     * Filter which TaxRates to update
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxRate upsert
   */
  export type TaxRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxRate to update in case it exists.
     */
    where: TaxRateWhereUniqueInput
    /**
     * In case the TaxRate found by the `where` argument doesn't exist, create a new TaxRate with this data.
     */
    create: XOR<TaxRateCreateInput, TaxRateUncheckedCreateInput>
    /**
     * In case the TaxRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxRateUpdateInput, TaxRateUncheckedUpdateInput>
  }

  /**
   * TaxRate delete
   */
  export type TaxRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
    /**
     * Filter which TaxRate to delete.
     */
    where: TaxRateWhereUniqueInput
  }

  /**
   * TaxRate deleteMany
   */
  export type TaxRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxRates to delete
     */
    where?: TaxRateWhereInput
    /**
     * Limit how many TaxRates to delete.
     */
    limit?: number
  }

  /**
   * TaxRate without action
   */
  export type TaxRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxRate
     */
    select?: TaxRateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxRate
     */
    omit?: TaxRateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxRateInclude<ExtArgs> | null
  }


  /**
   * Model LocalSettings
   */

  export type AggregateLocalSettings = {
    _count: LocalSettingsCountAggregateOutputType | null
    _min: LocalSettingsMinAggregateOutputType | null
    _max: LocalSettingsMaxAggregateOutputType | null
  }

  export type LocalSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    category: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocalSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    category: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocalSettingsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocalSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    category?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocalSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalSettings to aggregate.
     */
    where?: LocalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalSettings to fetch.
     */
    orderBy?: LocalSettingsOrderByWithRelationInput | LocalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocalSettings
    **/
    _count?: true | LocalSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocalSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocalSettingsMaxAggregateInputType
  }

  export type GetLocalSettingsAggregateType<T extends LocalSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocalSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocalSettings[P]>
      : GetScalarType<T[P], AggregateLocalSettings[P]>
  }




  export type LocalSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocalSettingsWhereInput
    orderBy?: LocalSettingsOrderByWithAggregationInput | LocalSettingsOrderByWithAggregationInput[]
    by: LocalSettingsScalarFieldEnum[] | LocalSettingsScalarFieldEnum
    having?: LocalSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocalSettingsCountAggregateInputType | true
    _min?: LocalSettingsMinAggregateInputType
    _max?: LocalSettingsMaxAggregateInputType
  }

  export type LocalSettingsGroupByOutputType = {
    id: string
    key: string
    value: string
    category: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: LocalSettingsCountAggregateOutputType | null
    _min: LocalSettingsMinAggregateOutputType | null
    _max: LocalSettingsMaxAggregateOutputType | null
  }

  type GetLocalSettingsGroupByPayload<T extends LocalSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocalSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocalSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocalSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], LocalSettingsGroupByOutputType[P]>
        }
      >
    >


  export type LocalSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localSettings"]>

  export type LocalSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localSettings"]>

  export type LocalSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["localSettings"]>

  export type LocalSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    category?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocalSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "category" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["localSettings"]>

  export type $LocalSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocalSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      category: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["localSettings"]>
    composites: {}
  }

  type LocalSettingsGetPayload<S extends boolean | null | undefined | LocalSettingsDefaultArgs> = $Result.GetResult<Prisma.$LocalSettingsPayload, S>

  type LocalSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocalSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocalSettingsCountAggregateInputType | true
    }

  export interface LocalSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocalSettings'], meta: { name: 'LocalSettings' } }
    /**
     * Find zero or one LocalSettings that matches the filter.
     * @param {LocalSettingsFindUniqueArgs} args - Arguments to find a LocalSettings
     * @example
     * // Get one LocalSettings
     * const localSettings = await prisma.localSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocalSettingsFindUniqueArgs>(args: SelectSubset<T, LocalSettingsFindUniqueArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocalSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocalSettingsFindUniqueOrThrowArgs} args - Arguments to find a LocalSettings
     * @example
     * // Get one LocalSettings
     * const localSettings = await prisma.localSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocalSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocalSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsFindFirstArgs} args - Arguments to find a LocalSettings
     * @example
     * // Get one LocalSettings
     * const localSettings = await prisma.localSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocalSettingsFindFirstArgs>(args?: SelectSubset<T, LocalSettingsFindFirstArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocalSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsFindFirstOrThrowArgs} args - Arguments to find a LocalSettings
     * @example
     * // Get one LocalSettings
     * const localSettings = await prisma.localSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocalSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocalSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocalSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocalSettings
     * const localSettings = await prisma.localSettings.findMany()
     * 
     * // Get first 10 LocalSettings
     * const localSettings = await prisma.localSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const localSettingsWithIdOnly = await prisma.localSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocalSettingsFindManyArgs>(args?: SelectSubset<T, LocalSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocalSettings.
     * @param {LocalSettingsCreateArgs} args - Arguments to create a LocalSettings.
     * @example
     * // Create one LocalSettings
     * const LocalSettings = await prisma.localSettings.create({
     *   data: {
     *     // ... data to create a LocalSettings
     *   }
     * })
     * 
     */
    create<T extends LocalSettingsCreateArgs>(args: SelectSubset<T, LocalSettingsCreateArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocalSettings.
     * @param {LocalSettingsCreateManyArgs} args - Arguments to create many LocalSettings.
     * @example
     * // Create many LocalSettings
     * const localSettings = await prisma.localSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocalSettingsCreateManyArgs>(args?: SelectSubset<T, LocalSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocalSettings and returns the data saved in the database.
     * @param {LocalSettingsCreateManyAndReturnArgs} args - Arguments to create many LocalSettings.
     * @example
     * // Create many LocalSettings
     * const localSettings = await prisma.localSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocalSettings and only return the `id`
     * const localSettingsWithIdOnly = await prisma.localSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocalSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, LocalSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocalSettings.
     * @param {LocalSettingsDeleteArgs} args - Arguments to delete one LocalSettings.
     * @example
     * // Delete one LocalSettings
     * const LocalSettings = await prisma.localSettings.delete({
     *   where: {
     *     // ... filter to delete one LocalSettings
     *   }
     * })
     * 
     */
    delete<T extends LocalSettingsDeleteArgs>(args: SelectSubset<T, LocalSettingsDeleteArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocalSettings.
     * @param {LocalSettingsUpdateArgs} args - Arguments to update one LocalSettings.
     * @example
     * // Update one LocalSettings
     * const localSettings = await prisma.localSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocalSettingsUpdateArgs>(args: SelectSubset<T, LocalSettingsUpdateArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocalSettings.
     * @param {LocalSettingsDeleteManyArgs} args - Arguments to filter LocalSettings to delete.
     * @example
     * // Delete a few LocalSettings
     * const { count } = await prisma.localSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocalSettingsDeleteManyArgs>(args?: SelectSubset<T, LocalSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocalSettings
     * const localSettings = await prisma.localSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocalSettingsUpdateManyArgs>(args: SelectSubset<T, LocalSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocalSettings and returns the data updated in the database.
     * @param {LocalSettingsUpdateManyAndReturnArgs} args - Arguments to update many LocalSettings.
     * @example
     * // Update many LocalSettings
     * const localSettings = await prisma.localSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocalSettings and only return the `id`
     * const localSettingsWithIdOnly = await prisma.localSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocalSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, LocalSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocalSettings.
     * @param {LocalSettingsUpsertArgs} args - Arguments to update or create a LocalSettings.
     * @example
     * // Update or create a LocalSettings
     * const localSettings = await prisma.localSettings.upsert({
     *   create: {
     *     // ... data to create a LocalSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocalSettings we want to update
     *   }
     * })
     */
    upsert<T extends LocalSettingsUpsertArgs>(args: SelectSubset<T, LocalSettingsUpsertArgs<ExtArgs>>): Prisma__LocalSettingsClient<$Result.GetResult<Prisma.$LocalSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsCountArgs} args - Arguments to filter LocalSettings to count.
     * @example
     * // Count the number of LocalSettings
     * const count = await prisma.localSettings.count({
     *   where: {
     *     // ... the filter for the LocalSettings we want to count
     *   }
     * })
    **/
    count<T extends LocalSettingsCountArgs>(
      args?: Subset<T, LocalSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocalSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocalSettingsAggregateArgs>(args: Subset<T, LocalSettingsAggregateArgs>): Prisma.PrismaPromise<GetLocalSettingsAggregateType<T>>

    /**
     * Group by LocalSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocalSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocalSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocalSettingsGroupByArgs['orderBy'] }
        : { orderBy?: LocalSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocalSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocalSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocalSettings model
   */
  readonly fields: LocalSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocalSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocalSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocalSettings model
   */
  interface LocalSettingsFieldRefs {
    readonly id: FieldRef<"LocalSettings", 'String'>
    readonly key: FieldRef<"LocalSettings", 'String'>
    readonly value: FieldRef<"LocalSettings", 'String'>
    readonly category: FieldRef<"LocalSettings", 'String'>
    readonly description: FieldRef<"LocalSettings", 'String'>
    readonly createdAt: FieldRef<"LocalSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"LocalSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocalSettings findUnique
   */
  export type LocalSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalSettings to fetch.
     */
    where: LocalSettingsWhereUniqueInput
  }

  /**
   * LocalSettings findUniqueOrThrow
   */
  export type LocalSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalSettings to fetch.
     */
    where: LocalSettingsWhereUniqueInput
  }

  /**
   * LocalSettings findFirst
   */
  export type LocalSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalSettings to fetch.
     */
    where?: LocalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalSettings to fetch.
     */
    orderBy?: LocalSettingsOrderByWithRelationInput | LocalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalSettings.
     */
    cursor?: LocalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalSettings.
     */
    distinct?: LocalSettingsScalarFieldEnum | LocalSettingsScalarFieldEnum[]
  }

  /**
   * LocalSettings findFirstOrThrow
   */
  export type LocalSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalSettings to fetch.
     */
    where?: LocalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalSettings to fetch.
     */
    orderBy?: LocalSettingsOrderByWithRelationInput | LocalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocalSettings.
     */
    cursor?: LocalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocalSettings.
     */
    distinct?: LocalSettingsScalarFieldEnum | LocalSettingsScalarFieldEnum[]
  }

  /**
   * LocalSettings findMany
   */
  export type LocalSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter, which LocalSettings to fetch.
     */
    where?: LocalSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocalSettings to fetch.
     */
    orderBy?: LocalSettingsOrderByWithRelationInput | LocalSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocalSettings.
     */
    cursor?: LocalSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocalSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocalSettings.
     */
    skip?: number
    distinct?: LocalSettingsScalarFieldEnum | LocalSettingsScalarFieldEnum[]
  }

  /**
   * LocalSettings create
   */
  export type LocalSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a LocalSettings.
     */
    data: XOR<LocalSettingsCreateInput, LocalSettingsUncheckedCreateInput>
  }

  /**
   * LocalSettings createMany
   */
  export type LocalSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocalSettings.
     */
    data: LocalSettingsCreateManyInput | LocalSettingsCreateManyInput[]
  }

  /**
   * LocalSettings createManyAndReturn
   */
  export type LocalSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many LocalSettings.
     */
    data: LocalSettingsCreateManyInput | LocalSettingsCreateManyInput[]
  }

  /**
   * LocalSettings update
   */
  export type LocalSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a LocalSettings.
     */
    data: XOR<LocalSettingsUpdateInput, LocalSettingsUncheckedUpdateInput>
    /**
     * Choose, which LocalSettings to update.
     */
    where: LocalSettingsWhereUniqueInput
  }

  /**
   * LocalSettings updateMany
   */
  export type LocalSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocalSettings.
     */
    data: XOR<LocalSettingsUpdateManyMutationInput, LocalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LocalSettings to update
     */
    where?: LocalSettingsWhereInput
    /**
     * Limit how many LocalSettings to update.
     */
    limit?: number
  }

  /**
   * LocalSettings updateManyAndReturn
   */
  export type LocalSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * The data used to update LocalSettings.
     */
    data: XOR<LocalSettingsUpdateManyMutationInput, LocalSettingsUncheckedUpdateManyInput>
    /**
     * Filter which LocalSettings to update
     */
    where?: LocalSettingsWhereInput
    /**
     * Limit how many LocalSettings to update.
     */
    limit?: number
  }

  /**
   * LocalSettings upsert
   */
  export type LocalSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the LocalSettings to update in case it exists.
     */
    where: LocalSettingsWhereUniqueInput
    /**
     * In case the LocalSettings found by the `where` argument doesn't exist, create a new LocalSettings with this data.
     */
    create: XOR<LocalSettingsCreateInput, LocalSettingsUncheckedCreateInput>
    /**
     * In case the LocalSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocalSettingsUpdateInput, LocalSettingsUncheckedUpdateInput>
  }

  /**
   * LocalSettings delete
   */
  export type LocalSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
    /**
     * Filter which LocalSettings to delete.
     */
    where: LocalSettingsWhereUniqueInput
  }

  /**
   * LocalSettings deleteMany
   */
  export type LocalSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocalSettings to delete
     */
    where?: LocalSettingsWhereInput
    /**
     * Limit how many LocalSettings to delete.
     */
    limit?: number
  }

  /**
   * LocalSettings without action
   */
  export type LocalSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocalSettings
     */
    select?: LocalSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocalSettings
     */
    omit?: LocalSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Cache
   */

  export type AggregateCache = {
    _count: CacheCountAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  export type CacheMinAggregateOutputType = {
    id: string | null
    key: string | null
    expiresAt: Date | null
    lastAccessed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheMaxAggregateOutputType = {
    id: string | null
    key: string | null
    expiresAt: Date | null
    lastAccessed: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CacheCountAggregateOutputType = {
    id: number
    key: number
    value: number
    expiresAt: number
    lastAccessed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CacheMinAggregateInputType = {
    id?: true
    key?: true
    expiresAt?: true
    lastAccessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheMaxAggregateInputType = {
    id?: true
    key?: true
    expiresAt?: true
    lastAccessed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CacheCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    expiresAt?: true
    lastAccessed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cache to aggregate.
     */
    where?: CacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caches to fetch.
     */
    orderBy?: CacheOrderByWithRelationInput | CacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Caches
    **/
    _count?: true | CacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheMaxAggregateInputType
  }

  export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache[P]>
      : GetScalarType<T[P], AggregateCache[P]>
  }




  export type CacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CacheWhereInput
    orderBy?: CacheOrderByWithAggregationInput | CacheOrderByWithAggregationInput[]
    by: CacheScalarFieldEnum[] | CacheScalarFieldEnum
    having?: CacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheCountAggregateInputType | true
    _min?: CacheMinAggregateInputType
    _max?: CacheMaxAggregateInputType
  }

  export type CacheGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    expiresAt: Date | null
    lastAccessed: Date
    createdAt: Date
    updatedAt: Date
    _count: CacheCountAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  type GetCacheGroupByPayload<T extends CacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheGroupByOutputType[P]>
            : GetScalarType<T[P], CacheGroupByOutputType[P]>
        }
      >
    >


  export type CacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type CacheSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type CacheSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cache"]>

  export type CacheSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    lastAccessed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "expiresAt" | "lastAccessed" | "createdAt" | "updatedAt", ExtArgs["result"]["cache"]>

  export type $CachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      expiresAt: Date | null
      lastAccessed: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cache"]>
    composites: {}
  }

  type CacheGetPayload<S extends boolean | null | undefined | CacheDefaultArgs> = $Result.GetResult<Prisma.$CachePayload, S>

  type CacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CacheCountAggregateInputType | true
    }

  export interface CacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cache'], meta: { name: 'Cache' } }
    /**
     * Find zero or one Cache that matches the filter.
     * @param {CacheFindUniqueArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CacheFindUniqueArgs>(args: SelectSubset<T, CacheFindUniqueArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CacheFindUniqueOrThrowArgs>(args: SelectSubset<T, CacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheFindFirstArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CacheFindFirstArgs>(args?: SelectSubset<T, CacheFindFirstArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheFindFirstOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CacheFindFirstOrThrowArgs>(args?: SelectSubset<T, CacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caches
     * const caches = await prisma.cache.findMany()
     * 
     * // Get first 10 Caches
     * const caches = await prisma.cache.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cacheWithIdOnly = await prisma.cache.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CacheFindManyArgs>(args?: SelectSubset<T, CacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache.
     * @param {CacheCreateArgs} args - Arguments to create a Cache.
     * @example
     * // Create one Cache
     * const Cache = await prisma.cache.create({
     *   data: {
     *     // ... data to create a Cache
     *   }
     * })
     * 
     */
    create<T extends CacheCreateArgs>(args: SelectSubset<T, CacheCreateArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caches.
     * @param {CacheCreateManyArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CacheCreateManyArgs>(args?: SelectSubset<T, CacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Caches and returns the data saved in the database.
     * @param {CacheCreateManyAndReturnArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Caches and only return the `id`
     * const cacheWithIdOnly = await prisma.cache.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CacheCreateManyAndReturnArgs>(args?: SelectSubset<T, CacheCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cache.
     * @param {CacheDeleteArgs} args - Arguments to delete one Cache.
     * @example
     * // Delete one Cache
     * const Cache = await prisma.cache.delete({
     *   where: {
     *     // ... filter to delete one Cache
     *   }
     * })
     * 
     */
    delete<T extends CacheDeleteArgs>(args: SelectSubset<T, CacheDeleteArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache.
     * @param {CacheUpdateArgs} args - Arguments to update one Cache.
     * @example
     * // Update one Cache
     * const cache = await prisma.cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CacheUpdateArgs>(args: SelectSubset<T, CacheUpdateArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caches.
     * @param {CacheDeleteManyArgs} args - Arguments to filter Caches to delete.
     * @example
     * // Delete a few Caches
     * const { count } = await prisma.cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CacheDeleteManyArgs>(args?: SelectSubset<T, CacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CacheUpdateManyArgs>(args: SelectSubset<T, CacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches and returns the data updated in the database.
     * @param {CacheUpdateManyAndReturnArgs} args - Arguments to update many Caches.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Caches and only return the `id`
     * const cacheWithIdOnly = await prisma.cache.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CacheUpdateManyAndReturnArgs>(args: SelectSubset<T, CacheUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cache.
     * @param {CacheUpsertArgs} args - Arguments to update or create a Cache.
     * @example
     * // Update or create a Cache
     * const cache = await prisma.cache.upsert({
     *   create: {
     *     // ... data to create a Cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache we want to update
     *   }
     * })
     */
    upsert<T extends CacheUpsertArgs>(args: SelectSubset<T, CacheUpsertArgs<ExtArgs>>): Prisma__CacheClient<$Result.GetResult<Prisma.$CachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheCountArgs} args - Arguments to filter Caches to count.
     * @example
     * // Count the number of Caches
     * const count = await prisma.cache.count({
     *   where: {
     *     // ... the filter for the Caches we want to count
     *   }
     * })
    **/
    count<T extends CacheCountArgs>(
      args?: Subset<T, CacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheAggregateArgs>(args: Subset<T, CacheAggregateArgs>): Prisma.PrismaPromise<GetCacheAggregateType<T>>

    /**
     * Group by Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CacheGroupByArgs['orderBy'] }
        : { orderBy?: CacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cache model
   */
  readonly fields: CacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cache model
   */
  interface CacheFieldRefs {
    readonly id: FieldRef<"Cache", 'String'>
    readonly key: FieldRef<"Cache", 'String'>
    readonly value: FieldRef<"Cache", 'Json'>
    readonly expiresAt: FieldRef<"Cache", 'DateTime'>
    readonly lastAccessed: FieldRef<"Cache", 'DateTime'>
    readonly createdAt: FieldRef<"Cache", 'DateTime'>
    readonly updatedAt: FieldRef<"Cache", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cache findUnique
   */
  export type CacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter, which Cache to fetch.
     */
    where: CacheWhereUniqueInput
  }

  /**
   * Cache findUniqueOrThrow
   */
  export type CacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter, which Cache to fetch.
     */
    where: CacheWhereUniqueInput
  }

  /**
   * Cache findFirst
   */
  export type CacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter, which Cache to fetch.
     */
    where?: CacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caches to fetch.
     */
    orderBy?: CacheOrderByWithRelationInput | CacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caches.
     */
    cursor?: CacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * Cache findFirstOrThrow
   */
  export type CacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter, which Cache to fetch.
     */
    where?: CacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caches to fetch.
     */
    orderBy?: CacheOrderByWithRelationInput | CacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Caches.
     */
    cursor?: CacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * Cache findMany
   */
  export type CacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter, which Caches to fetch.
     */
    where?: CacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Caches to fetch.
     */
    orderBy?: CacheOrderByWithRelationInput | CacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Caches.
     */
    cursor?: CacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Caches.
     */
    skip?: number
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * Cache create
   */
  export type CacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * The data needed to create a Cache.
     */
    data: XOR<CacheCreateInput, CacheUncheckedCreateInput>
  }

  /**
   * Cache createMany
   */
  export type CacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Caches.
     */
    data: CacheCreateManyInput | CacheCreateManyInput[]
  }

  /**
   * Cache createManyAndReturn
   */
  export type CacheCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * The data used to create many Caches.
     */
    data: CacheCreateManyInput | CacheCreateManyInput[]
  }

  /**
   * Cache update
   */
  export type CacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * The data needed to update a Cache.
     */
    data: XOR<CacheUpdateInput, CacheUncheckedUpdateInput>
    /**
     * Choose, which Cache to update.
     */
    where: CacheWhereUniqueInput
  }

  /**
   * Cache updateMany
   */
  export type CacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Caches.
     */
    data: XOR<CacheUpdateManyMutationInput, CacheUncheckedUpdateManyInput>
    /**
     * Filter which Caches to update
     */
    where?: CacheWhereInput
    /**
     * Limit how many Caches to update.
     */
    limit?: number
  }

  /**
   * Cache updateManyAndReturn
   */
  export type CacheUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * The data used to update Caches.
     */
    data: XOR<CacheUpdateManyMutationInput, CacheUncheckedUpdateManyInput>
    /**
     * Filter which Caches to update
     */
    where?: CacheWhereInput
    /**
     * Limit how many Caches to update.
     */
    limit?: number
  }

  /**
   * Cache upsert
   */
  export type CacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * The filter to search for the Cache to update in case it exists.
     */
    where: CacheWhereUniqueInput
    /**
     * In case the Cache found by the `where` argument doesn't exist, create a new Cache with this data.
     */
    create: XOR<CacheCreateInput, CacheUncheckedCreateInput>
    /**
     * In case the Cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CacheUpdateInput, CacheUncheckedUpdateInput>
  }

  /**
   * Cache delete
   */
  export type CacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
    /**
     * Filter which Cache to delete.
     */
    where: CacheWhereUniqueInput
  }

  /**
   * Cache deleteMany
   */
  export type CacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Caches to delete
     */
    where?: CacheWhereInput
    /**
     * Limit how many Caches to delete.
     */
    limit?: number
  }

  /**
   * Cache without action
   */
  export type CacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cache
     */
    select?: CacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cache
     */
    omit?: CacheOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TerminalScalarFieldEnum: {
    id: 'id',
    terminalCode: 'terminalCode',
    terminalName: 'terminalName',
    macAddress: 'macAddress',
    centralTerminalId: 'centralTerminalId',
    centralStoreId: 'centralStoreId',
    centralBranchId: 'centralBranchId',
    centralLocationId: 'centralLocationId',
    apiKey: 'apiKey',
    sessionToken: 'sessionToken',
    sessionExpiry: 'sessionExpiry',
    storeName: 'storeName',
    branchName: 'branchName',
    locationName: 'locationName',
    features: 'features',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    currentShiftId: 'currentShiftId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerminalScalarFieldEnum = (typeof TerminalScalarFieldEnum)[keyof typeof TerminalScalarFieldEnum]


  export const TerminalSessionScalarFieldEnum: {
    id: 'id',
    terminalId: 'terminalId',
    sessionToken: 'sessionToken',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    lastActivityAt: 'lastActivityAt',
    ipAddress: 'ipAddress',
    isActive: 'isActive'
  };

  export type TerminalSessionScalarFieldEnum = (typeof TerminalSessionScalarFieldEnum)[keyof typeof TerminalSessionScalarFieldEnum]


  export const OperationModeScalarFieldEnum: {
    id: 'id',
    terminalId: 'terminalId',
    currentMode: 'currentMode',
    lastModeChange: 'lastModeChange',
    lastOnlineCheck: 'lastOnlineCheck',
    centralBaseURL: 'centralBaseURL',
    syncEndpoint: 'syncEndpoint',
    heartbeatInterval: 'heartbeatInterval',
    maxOfflineHours: 'maxOfflineHours',
    offlineSince: 'offlineSince'
  };

  export type OperationModeScalarFieldEnum = (typeof OperationModeScalarFieldEnum)[keyof typeof OperationModeScalarFieldEnum]


  export const ConnectionLogScalarFieldEnum: {
    id: 'id',
    terminalId: 'terminalId',
    mode: 'mode',
    timestamp: 'timestamp',
    durationMs: 'durationMs',
    errorMessage: 'errorMessage',
    success: 'success'
  };

  export type ConnectionLogScalarFieldEnum = (typeof ConnectionLogScalarFieldEnum)[keyof typeof ConnectionLogScalarFieldEnum]


  export const LocalUserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    pinCode: 'pinCode',
    role: 'role',
    permissions: 'permissions',
    centralUserId: 'centralUserId',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    loginAttempts: 'loginAttempts',
    lockedUntil: 'lockedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalUserScalarFieldEnum = (typeof LocalUserScalarFieldEnum)[keyof typeof LocalUserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    terminalId: 'terminalId',
    sessionToken: 'sessionToken',
    startedAt: 'startedAt',
    expiresAt: 'expiresAt',
    lastActivityAt: 'lastActivityAt',
    isActive: 'isActive'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const OutboxScalarFieldEnum: {
    id: 'id',
    terminalId: 'terminalId',
    entityType: 'entityType',
    entityId: 'entityId',
    operation: 'operation',
    data: 'data',
    createdInMode: 'createdInMode',
    shiftId: 'shiftId',
    userId: 'userId',
    syncPriority: 'syncPriority',
    attemptCount: 'attemptCount',
    maxAttempts: 'maxAttempts',
    lastAttemptAt: 'lastAttemptAt',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    localTimestamp: 'localTimestamp',
    syncVersion: 'syncVersion'
  };

  export type OutboxScalarFieldEnum = (typeof OutboxScalarFieldEnum)[keyof typeof OutboxScalarFieldEnum]


  export const SyncHistoryScalarFieldEnum: {
    id: 'id',
    terminalId: 'terminalId',
    syncType: 'syncType',
    direction: 'direction',
    entitiesProcessed: 'entitiesProcessed',
    successCount: 'successCount',
    failureCount: 'failureCount',
    conflictsFound: 'conflictsFound',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    durationMs: 'durationMs',
    success: 'success',
    errorMessage: 'errorMessage'
  };

  export type SyncHistoryScalarFieldEnum = (typeof SyncHistoryScalarFieldEnum)[keyof typeof SyncHistoryScalarFieldEnum]


  export const StoreScalarFieldEnum: {
    id: 'id',
    storeCode: 'storeCode',
    storeName: 'storeName',
    legalName: 'legalName',
    email: 'email',
    phone: 'phone',
    addressLine1: 'addressLine1',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    timezone: 'timezone',
    defaultCurrency: 'defaultCurrency',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    type: 'type',
    address: 'address',
    phone: 'phone',
    centralLocationId: 'centralLocationId',
    centralBranchId: 'centralBranchId',
    timezone: 'timezone',
    taxRate: 'taxRate',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    type: 'type',
    categoryId: 'categoryId',
    brandId: 'brandId',
    taxCategoryId: 'taxCategoryId',
    imageUrl: 'imageUrl',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductVariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    name: 'name',
    cost: 'cost',
    price: 'price',
    compareAtPrice: 'compareAtPrice',
    trackInventory: 'trackInventory',
    barcode: 'barcode',
    upc: 'upc',
    ean: 'ean',
    color: 'color',
    size: 'size',
    material: 'material',
    style: 'style',
    weight: 'weight',
    weightUnit: 'weightUnit',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductVariantScalarFieldEnum = (typeof ProductVariantScalarFieldEnum)[keyof typeof ProductVariantScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    imageUrl: 'imageUrl',
    parentId: 'parentId',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    logoUrl: 'logoUrl',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    code: 'code',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    type: 'type',
    groupId: 'groupId',
    loyaltyPoints: 'loyaltyPoints',
    totalSpent: 'totalSpent',
    totalOrders: 'totalOrders',
    creditLimit: 'creditLimit',
    currentBalance: 'currentBalance',
    allowMarketing: 'allowMarketing',
    notes: 'notes',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerGroupScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    discountPercent: 'discountPercent',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerGroupScalarFieldEnum = (typeof CustomerGroupScalarFieldEnum)[keyof typeof CustomerGroupScalarFieldEnum]


  export const CustomerAddressScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    type: 'type',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country',
    isDefault: 'isDefault',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerAddressScalarFieldEnum = (typeof CustomerAddressScalarFieldEnum)[keyof typeof CustomerAddressScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    locationId: 'locationId',
    quantityOnHand: 'quantityOnHand',
    quantityReserved: 'quantityReserved',
    quantityAvailable: 'quantityAvailable',
    reorderPoint: 'reorderPoint',
    reorderQuantity: 'reorderQuantity',
    lastCountedAt: 'lastCountedAt',
    lastReceivedAt: 'lastReceivedAt',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    pendingSync: 'pendingSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const StockAdjustmentScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    adjustmentType: 'adjustmentType',
    reason: 'reason',
    referenceNumber: 'referenceNumber',
    notes: 'notes',
    adjustedBy: 'adjustedBy',
    adjustedAt: 'adjustedAt',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    createdAt: 'createdAt'
  };

  export type StockAdjustmentScalarFieldEnum = (typeof StockAdjustmentScalarFieldEnum)[keyof typeof StockAdjustmentScalarFieldEnum]


  export const StockAdjustmentLineScalarFieldEnum: {
    id: 'id',
    adjustmentId: 'adjustmentId',
    variantId: 'variantId',
    quantityBefore: 'quantityBefore',
    quantityAfter: 'quantityAfter',
    quantityChange: 'quantityChange'
  };

  export type StockAdjustmentLineScalarFieldEnum = (typeof StockAdjustmentLineScalarFieldEnum)[keyof typeof StockAdjustmentLineScalarFieldEnum]


  export const StockTransferScalarFieldEnum: {
    id: 'id',
    fromLocationId: 'fromLocationId',
    toLocationId: 'toLocationId',
    transferNumber: 'transferNumber',
    status: 'status',
    transferDate: 'transferDate',
    notes: 'notes',
    createdBy: 'createdBy',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StockTransferScalarFieldEnum = (typeof StockTransferScalarFieldEnum)[keyof typeof StockTransferScalarFieldEnum]


  export const StockTransferLineScalarFieldEnum: {
    id: 'id',
    transferId: 'transferId',
    variantId: 'variantId',
    quantity: 'quantity',
    received: 'received'
  };

  export type StockTransferLineScalarFieldEnum = (typeof StockTransferLineScalarFieldEnum)[keyof typeof StockTransferLineScalarFieldEnum]


  export const SaleOrderScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    terminalId: 'terminalId',
    orderNumber: 'orderNumber',
    type: 'type',
    status: 'status',
    source: 'source',
    customerId: 'customerId',
    shiftId: 'shiftId',
    userId: 'userId',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    total: 'total',
    completedAt: 'completedAt',
    voidedAt: 'voidedAt',
    voidReason: 'voidReason',
    receiptPrinted: 'receiptPrinted',
    receiptEmailed: 'receiptEmailed',
    receiptPrintedAt: 'receiptPrintedAt',
    receiptEmailedAt: 'receiptEmailedAt',
    receiptNumber: 'receiptNumber',
    discountReason: 'discountReason',
    notes: 'notes',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    syncPriority: 'syncPriority',
    syncAttempts: 'syncAttempts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleOrderScalarFieldEnum = (typeof SaleOrderScalarFieldEnum)[keyof typeof SaleOrderScalarFieldEnum]


  export const SaleOrderLineScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    variantId: 'variantId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    discountAmount: 'discountAmount',
    taxAmount: 'taxAmount',
    lineTotal: 'lineTotal',
    notes: 'notes',
    syncVersion: 'syncVersion',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleOrderLineScalarFieldEnum = (typeof SaleOrderLineScalarFieldEnum)[keyof typeof SaleOrderLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    method: 'method',
    amount: 'amount',
    currency: 'currency',
    reference: 'reference',
    cardLast4: 'cardLast4',
    cardBrand: 'cardBrand',
    authCode: 'authCode',
    status: 'status',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    syncPriority: 'syncPriority',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    type: 'type',
    name: 'name',
    code: 'code',
    amount: 'amount',
    percent: 'percent',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    createdAt: 'createdAt'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const ReturnOrderScalarFieldEnum: {
    id: 'id',
    returnNumber: 'returnNumber',
    originalOrderId: 'originalOrderId',
    customerId: 'customerId',
    locationId: 'locationId',
    reason: 'reason',
    notes: 'notes',
    subtotal: 'subtotal',
    taxAmount: 'taxAmount',
    total: 'total',
    refundMethod: 'refundMethod',
    refundAmount: 'refundAmount',
    status: 'status',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    syncAttempts: 'syncAttempts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReturnOrderScalarFieldEnum = (typeof ReturnOrderScalarFieldEnum)[keyof typeof ReturnOrderScalarFieldEnum]


  export const ReturnOrderLineScalarFieldEnum: {
    id: 'id',
    returnOrderId: 'returnOrderId',
    variantId: 'variantId',
    originalLineId: 'originalLineId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    lineTotal: 'lineTotal',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReturnOrderLineScalarFieldEnum = (typeof ReturnOrderLineScalarFieldEnum)[keyof typeof ReturnOrderLineScalarFieldEnum]


  export const ExchangeOrderScalarFieldEnum: {
    id: 'id',
    exchangeNumber: 'exchangeNumber',
    originalOrderId: 'originalOrderId',
    newOrderId: 'newOrderId',
    priceDifference: 'priceDifference',
    additionalPayment: 'additionalPayment',
    refundAmount: 'refundAmount',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty'
  };

  export type ExchangeOrderScalarFieldEnum = (typeof ExchangeOrderScalarFieldEnum)[keyof typeof ExchangeOrderScalarFieldEnum]


  export const ParkedOrderScalarFieldEnum: {
    id: 'id',
    parkNumber: 'parkNumber',
    orderId: 'orderId',
    customerId: 'customerId',
    parkedBy: 'parkedBy',
    parkedAt: 'parkedAt',
    expiryDate: 'expiryDate',
    notes: 'notes',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty'
  };

  export type ParkedOrderScalarFieldEnum = (typeof ParkedOrderScalarFieldEnum)[keyof typeof ParkedOrderScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    locationId: 'locationId',
    terminalId: 'terminalId',
    userId: 'userId',
    shiftNumber: 'shiftNumber',
    registerId: 'registerId',
    openingCash: 'openingCash',
    closingCash: 'closingCash',
    expectedCash: 'expectedCash',
    cashDifference: 'cashDifference',
    totalSales: 'totalSales',
    totalRefunds: 'totalRefunds',
    totalTransactions: 'totalTransactions',
    openedAt: 'openedAt',
    closedAt: 'closedAt',
    status: 'status',
    notes: 'notes',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const TaxCategoryScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    description: 'description',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxCategoryScalarFieldEnum = (typeof TaxCategoryScalarFieldEnum)[keyof typeof TaxCategoryScalarFieldEnum]


  export const TaxRateScalarFieldEnum: {
    id: 'id',
    taxCategoryId: 'taxCategoryId',
    name: 'name',
    rate: 'rate',
    country: 'country',
    state: 'state',
    city: 'city',
    isActive: 'isActive',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    syncVersion: 'syncVersion',
    lastSyncedAt: 'lastSyncedAt',
    isDirty: 'isDirty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaxRateScalarFieldEnum = (typeof TaxRateScalarFieldEnum)[keyof typeof TaxRateScalarFieldEnum]


  export const LocalSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    category: 'category',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocalSettingsScalarFieldEnum = (typeof LocalSettingsScalarFieldEnum)[keyof typeof LocalSettingsScalarFieldEnum]


  export const CacheScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    expiresAt: 'expiresAt',
    lastAccessed: 'lastAccessed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'OperationModeType'
   */
  export type EnumOperationModeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperationModeType'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'SyncOperation'
   */
  export type EnumSyncOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncOperation'>
    


  /**
   * Reference to a field of type 'SyncType'
   */
  export type EnumSyncTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncType'>
    


  /**
   * Reference to a field of type 'SyncDirection'
   */
  export type EnumSyncDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SyncDirection'>
    


  /**
   * Reference to a field of type 'LocationType'
   */
  export type EnumLocationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LocationType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'ProductType'
   */
  export type EnumProductTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductType'>
    


  /**
   * Reference to a field of type 'CustomerType'
   */
  export type EnumCustomerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerType'>
    


  /**
   * Reference to a field of type 'AddressType'
   */
  export type EnumAddressTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AddressType'>
    


  /**
   * Reference to a field of type 'StockAdjustmentType'
   */
  export type EnumStockAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StockAdjustmentType'>
    


  /**
   * Reference to a field of type 'TransferStatus'
   */
  export type EnumTransferStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransferStatus'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderSource'
   */
  export type EnumOrderSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderSource'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'ReturnReason'
   */
  export type EnumReturnReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnReason'>
    


  /**
   * Reference to a field of type 'RefundMethod'
   */
  export type EnumRefundMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundMethod'>
    


  /**
   * Reference to a field of type 'ReturnStatus'
   */
  export type EnumReturnStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReturnStatus'>
    


  /**
   * Reference to a field of type 'ShiftStatus'
   */
  export type EnumShiftStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShiftStatus'>
    
  /**
   * Deep Input Types
   */


  export type TerminalWhereInput = {
    AND?: TerminalWhereInput | TerminalWhereInput[]
    OR?: TerminalWhereInput[]
    NOT?: TerminalWhereInput | TerminalWhereInput[]
    id?: StringFilter<"Terminal"> | string
    terminalCode?: StringFilter<"Terminal"> | string
    terminalName?: StringFilter<"Terminal"> | string
    macAddress?: StringFilter<"Terminal"> | string
    centralTerminalId?: StringFilter<"Terminal"> | string
    centralStoreId?: StringFilter<"Terminal"> | string
    centralBranchId?: StringFilter<"Terminal"> | string
    centralLocationId?: StringNullableFilter<"Terminal"> | string | null
    apiKey?: StringFilter<"Terminal"> | string
    sessionToken?: StringNullableFilter<"Terminal"> | string | null
    sessionExpiry?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    storeName?: StringNullableFilter<"Terminal"> | string | null
    branchName?: StringNullableFilter<"Terminal"> | string | null
    locationName?: StringNullableFilter<"Terminal"> | string | null
    features?: JsonFilter<"Terminal">
    isActive?: BoolFilter<"Terminal"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    currentShiftId?: StringNullableFilter<"Terminal"> | string | null
    createdAt?: DateTimeFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeFilter<"Terminal"> | Date | string
    sessions?: TerminalSessionListRelationFilter
    operationModes?: OperationModeListRelationFilter
    connectionLogs?: ConnectionLogListRelationFilter
    userSessions?: UserSessionListRelationFilter
    outboxes?: OutboxListRelationFilter
    syncHistories?: SyncHistoryListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    shifts?: ShiftListRelationFilter
  }

  export type TerminalOrderByWithRelationInput = {
    id?: SortOrder
    terminalCode?: SortOrder
    terminalName?: SortOrder
    macAddress?: SortOrder
    centralTerminalId?: SortOrder
    centralStoreId?: SortOrder
    centralBranchId?: SortOrder
    centralLocationId?: SortOrderInput | SortOrder
    apiKey?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    sessionExpiry?: SortOrderInput | SortOrder
    storeName?: SortOrderInput | SortOrder
    branchName?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    features?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    currentShiftId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: TerminalSessionOrderByRelationAggregateInput
    operationModes?: OperationModeOrderByRelationAggregateInput
    connectionLogs?: ConnectionLogOrderByRelationAggregateInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    outboxes?: OutboxOrderByRelationAggregateInput
    syncHistories?: SyncHistoryOrderByRelationAggregateInput
    saleOrders?: SaleOrderOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
  }

  export type TerminalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    terminalCode?: string
    macAddress?: string
    AND?: TerminalWhereInput | TerminalWhereInput[]
    OR?: TerminalWhereInput[]
    NOT?: TerminalWhereInput | TerminalWhereInput[]
    terminalName?: StringFilter<"Terminal"> | string
    centralTerminalId?: StringFilter<"Terminal"> | string
    centralStoreId?: StringFilter<"Terminal"> | string
    centralBranchId?: StringFilter<"Terminal"> | string
    centralLocationId?: StringNullableFilter<"Terminal"> | string | null
    apiKey?: StringFilter<"Terminal"> | string
    sessionToken?: StringNullableFilter<"Terminal"> | string | null
    sessionExpiry?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    storeName?: StringNullableFilter<"Terminal"> | string | null
    branchName?: StringNullableFilter<"Terminal"> | string | null
    locationName?: StringNullableFilter<"Terminal"> | string | null
    features?: JsonFilter<"Terminal">
    isActive?: BoolFilter<"Terminal"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    currentShiftId?: StringNullableFilter<"Terminal"> | string | null
    createdAt?: DateTimeFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeFilter<"Terminal"> | Date | string
    sessions?: TerminalSessionListRelationFilter
    operationModes?: OperationModeListRelationFilter
    connectionLogs?: ConnectionLogListRelationFilter
    userSessions?: UserSessionListRelationFilter
    outboxes?: OutboxListRelationFilter
    syncHistories?: SyncHistoryListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    shifts?: ShiftListRelationFilter
  }, "id" | "terminalCode" | "macAddress">

  export type TerminalOrderByWithAggregationInput = {
    id?: SortOrder
    terminalCode?: SortOrder
    terminalName?: SortOrder
    macAddress?: SortOrder
    centralTerminalId?: SortOrder
    centralStoreId?: SortOrder
    centralBranchId?: SortOrder
    centralLocationId?: SortOrderInput | SortOrder
    apiKey?: SortOrder
    sessionToken?: SortOrderInput | SortOrder
    sessionExpiry?: SortOrderInput | SortOrder
    storeName?: SortOrderInput | SortOrder
    branchName?: SortOrderInput | SortOrder
    locationName?: SortOrderInput | SortOrder
    features?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    currentShiftId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerminalCountOrderByAggregateInput
    _max?: TerminalMaxOrderByAggregateInput
    _min?: TerminalMinOrderByAggregateInput
  }

  export type TerminalScalarWhereWithAggregatesInput = {
    AND?: TerminalScalarWhereWithAggregatesInput | TerminalScalarWhereWithAggregatesInput[]
    OR?: TerminalScalarWhereWithAggregatesInput[]
    NOT?: TerminalScalarWhereWithAggregatesInput | TerminalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Terminal"> | string
    terminalCode?: StringWithAggregatesFilter<"Terminal"> | string
    terminalName?: StringWithAggregatesFilter<"Terminal"> | string
    macAddress?: StringWithAggregatesFilter<"Terminal"> | string
    centralTerminalId?: StringWithAggregatesFilter<"Terminal"> | string
    centralStoreId?: StringWithAggregatesFilter<"Terminal"> | string
    centralBranchId?: StringWithAggregatesFilter<"Terminal"> | string
    centralLocationId?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    apiKey?: StringWithAggregatesFilter<"Terminal"> | string
    sessionToken?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    sessionExpiry?: DateTimeNullableWithAggregatesFilter<"Terminal"> | Date | string | null
    storeName?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    branchName?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    locationName?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    features?: JsonWithAggregatesFilter<"Terminal">
    isActive?: BoolWithAggregatesFilter<"Terminal"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"Terminal"> | Date | string | null
    currentShiftId?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Terminal"> | Date | string
  }

  export type TerminalSessionWhereInput = {
    AND?: TerminalSessionWhereInput | TerminalSessionWhereInput[]
    OR?: TerminalSessionWhereInput[]
    NOT?: TerminalSessionWhereInput | TerminalSessionWhereInput[]
    id?: StringFilter<"TerminalSession"> | string
    terminalId?: StringFilter<"TerminalSession"> | string
    sessionToken?: StringFilter<"TerminalSession"> | string
    startedAt?: DateTimeFilter<"TerminalSession"> | Date | string
    expiresAt?: DateTimeFilter<"TerminalSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"TerminalSession"> | Date | string
    ipAddress?: StringNullableFilter<"TerminalSession"> | string | null
    isActive?: BoolFilter<"TerminalSession"> | boolean
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type TerminalSessionOrderByWithRelationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    terminal?: TerminalOrderByWithRelationInput
  }

  export type TerminalSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: TerminalSessionWhereInput | TerminalSessionWhereInput[]
    OR?: TerminalSessionWhereInput[]
    NOT?: TerminalSessionWhereInput | TerminalSessionWhereInput[]
    terminalId?: StringFilter<"TerminalSession"> | string
    startedAt?: DateTimeFilter<"TerminalSession"> | Date | string
    expiresAt?: DateTimeFilter<"TerminalSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"TerminalSession"> | Date | string
    ipAddress?: StringNullableFilter<"TerminalSession"> | string | null
    isActive?: BoolFilter<"TerminalSession"> | boolean
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id" | "sessionToken">

  export type TerminalSessionOrderByWithAggregationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: TerminalSessionCountOrderByAggregateInput
    _max?: TerminalSessionMaxOrderByAggregateInput
    _min?: TerminalSessionMinOrderByAggregateInput
  }

  export type TerminalSessionScalarWhereWithAggregatesInput = {
    AND?: TerminalSessionScalarWhereWithAggregatesInput | TerminalSessionScalarWhereWithAggregatesInput[]
    OR?: TerminalSessionScalarWhereWithAggregatesInput[]
    NOT?: TerminalSessionScalarWhereWithAggregatesInput | TerminalSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TerminalSession"> | string
    terminalId?: StringWithAggregatesFilter<"TerminalSession"> | string
    sessionToken?: StringWithAggregatesFilter<"TerminalSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"TerminalSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"TerminalSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"TerminalSession"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"TerminalSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"TerminalSession"> | boolean
  }

  export type OperationModeWhereInput = {
    AND?: OperationModeWhereInput | OperationModeWhereInput[]
    OR?: OperationModeWhereInput[]
    NOT?: OperationModeWhereInput | OperationModeWhereInput[]
    id?: StringFilter<"OperationMode"> | string
    terminalId?: StringFilter<"OperationMode"> | string
    currentMode?: EnumOperationModeTypeFilter<"OperationMode"> | $Enums.OperationModeType
    lastModeChange?: DateTimeFilter<"OperationMode"> | Date | string
    lastOnlineCheck?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
    centralBaseURL?: StringFilter<"OperationMode"> | string
    syncEndpoint?: StringFilter<"OperationMode"> | string
    heartbeatInterval?: IntFilter<"OperationMode"> | number
    maxOfflineHours?: IntFilter<"OperationMode"> | number
    offlineSince?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type OperationModeOrderByWithRelationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    currentMode?: SortOrder
    lastModeChange?: SortOrder
    lastOnlineCheck?: SortOrderInput | SortOrder
    centralBaseURL?: SortOrder
    syncEndpoint?: SortOrder
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
    offlineSince?: SortOrderInput | SortOrder
    terminal?: TerminalOrderByWithRelationInput
  }

  export type OperationModeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    terminalId?: string
    AND?: OperationModeWhereInput | OperationModeWhereInput[]
    OR?: OperationModeWhereInput[]
    NOT?: OperationModeWhereInput | OperationModeWhereInput[]
    currentMode?: EnumOperationModeTypeFilter<"OperationMode"> | $Enums.OperationModeType
    lastModeChange?: DateTimeFilter<"OperationMode"> | Date | string
    lastOnlineCheck?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
    centralBaseURL?: StringFilter<"OperationMode"> | string
    syncEndpoint?: StringFilter<"OperationMode"> | string
    heartbeatInterval?: IntFilter<"OperationMode"> | number
    maxOfflineHours?: IntFilter<"OperationMode"> | number
    offlineSince?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id" | "terminalId">

  export type OperationModeOrderByWithAggregationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    currentMode?: SortOrder
    lastModeChange?: SortOrder
    lastOnlineCheck?: SortOrderInput | SortOrder
    centralBaseURL?: SortOrder
    syncEndpoint?: SortOrder
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
    offlineSince?: SortOrderInput | SortOrder
    _count?: OperationModeCountOrderByAggregateInput
    _avg?: OperationModeAvgOrderByAggregateInput
    _max?: OperationModeMaxOrderByAggregateInput
    _min?: OperationModeMinOrderByAggregateInput
    _sum?: OperationModeSumOrderByAggregateInput
  }

  export type OperationModeScalarWhereWithAggregatesInput = {
    AND?: OperationModeScalarWhereWithAggregatesInput | OperationModeScalarWhereWithAggregatesInput[]
    OR?: OperationModeScalarWhereWithAggregatesInput[]
    NOT?: OperationModeScalarWhereWithAggregatesInput | OperationModeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OperationMode"> | string
    terminalId?: StringWithAggregatesFilter<"OperationMode"> | string
    currentMode?: EnumOperationModeTypeWithAggregatesFilter<"OperationMode"> | $Enums.OperationModeType
    lastModeChange?: DateTimeWithAggregatesFilter<"OperationMode"> | Date | string
    lastOnlineCheck?: DateTimeNullableWithAggregatesFilter<"OperationMode"> | Date | string | null
    centralBaseURL?: StringWithAggregatesFilter<"OperationMode"> | string
    syncEndpoint?: StringWithAggregatesFilter<"OperationMode"> | string
    heartbeatInterval?: IntWithAggregatesFilter<"OperationMode"> | number
    maxOfflineHours?: IntWithAggregatesFilter<"OperationMode"> | number
    offlineSince?: DateTimeNullableWithAggregatesFilter<"OperationMode"> | Date | string | null
  }

  export type ConnectionLogWhereInput = {
    AND?: ConnectionLogWhereInput | ConnectionLogWhereInput[]
    OR?: ConnectionLogWhereInput[]
    NOT?: ConnectionLogWhereInput | ConnectionLogWhereInput[]
    id?: StringFilter<"ConnectionLog"> | string
    terminalId?: StringFilter<"ConnectionLog"> | string
    mode?: EnumOperationModeTypeFilter<"ConnectionLog"> | $Enums.OperationModeType
    timestamp?: DateTimeFilter<"ConnectionLog"> | Date | string
    durationMs?: IntNullableFilter<"ConnectionLog"> | number | null
    errorMessage?: StringNullableFilter<"ConnectionLog"> | string | null
    success?: BoolFilter<"ConnectionLog"> | boolean
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type ConnectionLogOrderByWithRelationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    mode?: SortOrder
    timestamp?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    success?: SortOrder
    terminal?: TerminalOrderByWithRelationInput
  }

  export type ConnectionLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConnectionLogWhereInput | ConnectionLogWhereInput[]
    OR?: ConnectionLogWhereInput[]
    NOT?: ConnectionLogWhereInput | ConnectionLogWhereInput[]
    terminalId?: StringFilter<"ConnectionLog"> | string
    mode?: EnumOperationModeTypeFilter<"ConnectionLog"> | $Enums.OperationModeType
    timestamp?: DateTimeFilter<"ConnectionLog"> | Date | string
    durationMs?: IntNullableFilter<"ConnectionLog"> | number | null
    errorMessage?: StringNullableFilter<"ConnectionLog"> | string | null
    success?: BoolFilter<"ConnectionLog"> | boolean
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id">

  export type ConnectionLogOrderByWithAggregationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    mode?: SortOrder
    timestamp?: SortOrder
    durationMs?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    success?: SortOrder
    _count?: ConnectionLogCountOrderByAggregateInput
    _avg?: ConnectionLogAvgOrderByAggregateInput
    _max?: ConnectionLogMaxOrderByAggregateInput
    _min?: ConnectionLogMinOrderByAggregateInput
    _sum?: ConnectionLogSumOrderByAggregateInput
  }

  export type ConnectionLogScalarWhereWithAggregatesInput = {
    AND?: ConnectionLogScalarWhereWithAggregatesInput | ConnectionLogScalarWhereWithAggregatesInput[]
    OR?: ConnectionLogScalarWhereWithAggregatesInput[]
    NOT?: ConnectionLogScalarWhereWithAggregatesInput | ConnectionLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConnectionLog"> | string
    terminalId?: StringWithAggregatesFilter<"ConnectionLog"> | string
    mode?: EnumOperationModeTypeWithAggregatesFilter<"ConnectionLog"> | $Enums.OperationModeType
    timestamp?: DateTimeWithAggregatesFilter<"ConnectionLog"> | Date | string
    durationMs?: IntNullableWithAggregatesFilter<"ConnectionLog"> | number | null
    errorMessage?: StringNullableWithAggregatesFilter<"ConnectionLog"> | string | null
    success?: BoolWithAggregatesFilter<"ConnectionLog"> | boolean
  }

  export type LocalUserWhereInput = {
    AND?: LocalUserWhereInput | LocalUserWhereInput[]
    OR?: LocalUserWhereInput[]
    NOT?: LocalUserWhereInput | LocalUserWhereInput[]
    id?: StringFilter<"LocalUser"> | string
    username?: StringFilter<"LocalUser"> | string
    email?: StringFilter<"LocalUser"> | string
    passwordHash?: StringFilter<"LocalUser"> | string
    firstName?: StringFilter<"LocalUser"> | string
    lastName?: StringFilter<"LocalUser"> | string
    pinCode?: StringNullableFilter<"LocalUser"> | string | null
    role?: EnumUserRoleFilter<"LocalUser"> | $Enums.UserRole
    permissions?: JsonFilter<"LocalUser">
    centralUserId?: StringNullableFilter<"LocalUser"> | string | null
    isActive?: BoolFilter<"LocalUser"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"LocalUser"> | Date | string | null
    loginAttempts?: IntFilter<"LocalUser"> | number
    lockedUntil?: DateTimeNullableFilter<"LocalUser"> | Date | string | null
    createdAt?: DateTimeFilter<"LocalUser"> | Date | string
    updatedAt?: DateTimeFilter<"LocalUser"> | Date | string
    shifts?: ShiftListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type LocalUserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    pinCode?: SortOrderInput | SortOrder
    role?: SortOrder
    permissions?: SortOrder
    centralUserId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shifts?: ShiftOrderByRelationAggregateInput
    saleOrders?: SaleOrderOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type LocalUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: LocalUserWhereInput | LocalUserWhereInput[]
    OR?: LocalUserWhereInput[]
    NOT?: LocalUserWhereInput | LocalUserWhereInput[]
    passwordHash?: StringFilter<"LocalUser"> | string
    firstName?: StringFilter<"LocalUser"> | string
    lastName?: StringFilter<"LocalUser"> | string
    pinCode?: StringNullableFilter<"LocalUser"> | string | null
    role?: EnumUserRoleFilter<"LocalUser"> | $Enums.UserRole
    permissions?: JsonFilter<"LocalUser">
    centralUserId?: StringNullableFilter<"LocalUser"> | string | null
    isActive?: BoolFilter<"LocalUser"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"LocalUser"> | Date | string | null
    loginAttempts?: IntFilter<"LocalUser"> | number
    lockedUntil?: DateTimeNullableFilter<"LocalUser"> | Date | string | null
    createdAt?: DateTimeFilter<"LocalUser"> | Date | string
    updatedAt?: DateTimeFilter<"LocalUser"> | Date | string
    shifts?: ShiftListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "username" | "email">

  export type LocalUserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    pinCode?: SortOrderInput | SortOrder
    role?: SortOrder
    permissions?: SortOrder
    centralUserId?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocalUserCountOrderByAggregateInput
    _avg?: LocalUserAvgOrderByAggregateInput
    _max?: LocalUserMaxOrderByAggregateInput
    _min?: LocalUserMinOrderByAggregateInput
    _sum?: LocalUserSumOrderByAggregateInput
  }

  export type LocalUserScalarWhereWithAggregatesInput = {
    AND?: LocalUserScalarWhereWithAggregatesInput | LocalUserScalarWhereWithAggregatesInput[]
    OR?: LocalUserScalarWhereWithAggregatesInput[]
    NOT?: LocalUserScalarWhereWithAggregatesInput | LocalUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocalUser"> | string
    username?: StringWithAggregatesFilter<"LocalUser"> | string
    email?: StringWithAggregatesFilter<"LocalUser"> | string
    passwordHash?: StringWithAggregatesFilter<"LocalUser"> | string
    firstName?: StringWithAggregatesFilter<"LocalUser"> | string
    lastName?: StringWithAggregatesFilter<"LocalUser"> | string
    pinCode?: StringNullableWithAggregatesFilter<"LocalUser"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"LocalUser"> | $Enums.UserRole
    permissions?: JsonWithAggregatesFilter<"LocalUser">
    centralUserId?: StringNullableWithAggregatesFilter<"LocalUser"> | string | null
    isActive?: BoolWithAggregatesFilter<"LocalUser"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"LocalUser"> | Date | string | null
    loginAttempts?: IntWithAggregatesFilter<"LocalUser"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"LocalUser"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocalUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocalUser"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    terminalId?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    startedAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
    user?: XOR<LocalUserScalarRelationFilter, LocalUserWhereInput>
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    user?: LocalUserOrderByWithRelationInput
    terminal?: TerminalOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    terminalId?: StringFilter<"UserSession"> | string
    startedAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
    user?: XOR<LocalUserScalarRelationFilter, LocalUserWhereInput>
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id" | "sessionToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    terminalId?: StringWithAggregatesFilter<"UserSession"> | string
    sessionToken?: StringWithAggregatesFilter<"UserSession"> | string
    startedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
  }

  export type OutboxWhereInput = {
    AND?: OutboxWhereInput | OutboxWhereInput[]
    OR?: OutboxWhereInput[]
    NOT?: OutboxWhereInput | OutboxWhereInput[]
    id?: StringFilter<"Outbox"> | string
    terminalId?: StringFilter<"Outbox"> | string
    entityType?: StringFilter<"Outbox"> | string
    entityId?: StringFilter<"Outbox"> | string
    operation?: EnumSyncOperationFilter<"Outbox"> | $Enums.SyncOperation
    data?: JsonFilter<"Outbox">
    createdInMode?: EnumOperationModeTypeFilter<"Outbox"> | $Enums.OperationModeType
    shiftId?: StringNullableFilter<"Outbox"> | string | null
    userId?: StringNullableFilter<"Outbox"> | string | null
    syncPriority?: IntFilter<"Outbox"> | number
    attemptCount?: IntFilter<"Outbox"> | number
    maxAttempts?: IntFilter<"Outbox"> | number
    lastAttemptAt?: DateTimeNullableFilter<"Outbox"> | Date | string | null
    errorMessage?: StringNullableFilter<"Outbox"> | string | null
    createdAt?: DateTimeFilter<"Outbox"> | Date | string
    localTimestamp?: DateTimeFilter<"Outbox"> | Date | string
    syncVersion?: IntFilter<"Outbox"> | number
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type OutboxOrderByWithRelationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    data?: SortOrder
    createdInMode?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    localTimestamp?: SortOrder
    syncVersion?: SortOrder
    terminal?: TerminalOrderByWithRelationInput
  }

  export type OutboxWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OutboxWhereInput | OutboxWhereInput[]
    OR?: OutboxWhereInput[]
    NOT?: OutboxWhereInput | OutboxWhereInput[]
    terminalId?: StringFilter<"Outbox"> | string
    entityType?: StringFilter<"Outbox"> | string
    entityId?: StringFilter<"Outbox"> | string
    operation?: EnumSyncOperationFilter<"Outbox"> | $Enums.SyncOperation
    data?: JsonFilter<"Outbox">
    createdInMode?: EnumOperationModeTypeFilter<"Outbox"> | $Enums.OperationModeType
    shiftId?: StringNullableFilter<"Outbox"> | string | null
    userId?: StringNullableFilter<"Outbox"> | string | null
    syncPriority?: IntFilter<"Outbox"> | number
    attemptCount?: IntFilter<"Outbox"> | number
    maxAttempts?: IntFilter<"Outbox"> | number
    lastAttemptAt?: DateTimeNullableFilter<"Outbox"> | Date | string | null
    errorMessage?: StringNullableFilter<"Outbox"> | string | null
    createdAt?: DateTimeFilter<"Outbox"> | Date | string
    localTimestamp?: DateTimeFilter<"Outbox"> | Date | string
    syncVersion?: IntFilter<"Outbox"> | number
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id">

  export type OutboxOrderByWithAggregationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    data?: SortOrder
    createdInMode?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    localTimestamp?: SortOrder
    syncVersion?: SortOrder
    _count?: OutboxCountOrderByAggregateInput
    _avg?: OutboxAvgOrderByAggregateInput
    _max?: OutboxMaxOrderByAggregateInput
    _min?: OutboxMinOrderByAggregateInput
    _sum?: OutboxSumOrderByAggregateInput
  }

  export type OutboxScalarWhereWithAggregatesInput = {
    AND?: OutboxScalarWhereWithAggregatesInput | OutboxScalarWhereWithAggregatesInput[]
    OR?: OutboxScalarWhereWithAggregatesInput[]
    NOT?: OutboxScalarWhereWithAggregatesInput | OutboxScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Outbox"> | string
    terminalId?: StringWithAggregatesFilter<"Outbox"> | string
    entityType?: StringWithAggregatesFilter<"Outbox"> | string
    entityId?: StringWithAggregatesFilter<"Outbox"> | string
    operation?: EnumSyncOperationWithAggregatesFilter<"Outbox"> | $Enums.SyncOperation
    data?: JsonWithAggregatesFilter<"Outbox">
    createdInMode?: EnumOperationModeTypeWithAggregatesFilter<"Outbox"> | $Enums.OperationModeType
    shiftId?: StringNullableWithAggregatesFilter<"Outbox"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Outbox"> | string | null
    syncPriority?: IntWithAggregatesFilter<"Outbox"> | number
    attemptCount?: IntWithAggregatesFilter<"Outbox"> | number
    maxAttempts?: IntWithAggregatesFilter<"Outbox"> | number
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"Outbox"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Outbox"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Outbox"> | Date | string
    localTimestamp?: DateTimeWithAggregatesFilter<"Outbox"> | Date | string
    syncVersion?: IntWithAggregatesFilter<"Outbox"> | number
  }

  export type SyncHistoryWhereInput = {
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    id?: StringFilter<"SyncHistory"> | string
    terminalId?: StringFilter<"SyncHistory"> | string
    syncType?: EnumSyncTypeFilter<"SyncHistory"> | $Enums.SyncType
    direction?: EnumSyncDirectionFilter<"SyncHistory"> | $Enums.SyncDirection
    entitiesProcessed?: IntFilter<"SyncHistory"> | number
    successCount?: IntFilter<"SyncHistory"> | number
    failureCount?: IntFilter<"SyncHistory"> | number
    conflictsFound?: IntFilter<"SyncHistory"> | number
    startedAt?: DateTimeFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncHistory"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncHistory"> | number | null
    success?: BoolFilter<"SyncHistory"> | boolean
    errorMessage?: StringNullableFilter<"SyncHistory"> | string | null
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }

  export type SyncHistoryOrderByWithRelationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    syncType?: SortOrder
    direction?: SortOrder
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    terminal?: TerminalOrderByWithRelationInput
  }

  export type SyncHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    OR?: SyncHistoryWhereInput[]
    NOT?: SyncHistoryWhereInput | SyncHistoryWhereInput[]
    terminalId?: StringFilter<"SyncHistory"> | string
    syncType?: EnumSyncTypeFilter<"SyncHistory"> | $Enums.SyncType
    direction?: EnumSyncDirectionFilter<"SyncHistory"> | $Enums.SyncDirection
    entitiesProcessed?: IntFilter<"SyncHistory"> | number
    successCount?: IntFilter<"SyncHistory"> | number
    failureCount?: IntFilter<"SyncHistory"> | number
    conflictsFound?: IntFilter<"SyncHistory"> | number
    startedAt?: DateTimeFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncHistory"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncHistory"> | number | null
    success?: BoolFilter<"SyncHistory"> | boolean
    errorMessage?: StringNullableFilter<"SyncHistory"> | string | null
    terminal?: XOR<TerminalScalarRelationFilter, TerminalWhereInput>
  }, "id">

  export type SyncHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    terminalId?: SortOrder
    syncType?: SortOrder
    direction?: SortOrder
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    _count?: SyncHistoryCountOrderByAggregateInput
    _avg?: SyncHistoryAvgOrderByAggregateInput
    _max?: SyncHistoryMaxOrderByAggregateInput
    _min?: SyncHistoryMinOrderByAggregateInput
    _sum?: SyncHistorySumOrderByAggregateInput
  }

  export type SyncHistoryScalarWhereWithAggregatesInput = {
    AND?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    OR?: SyncHistoryScalarWhereWithAggregatesInput[]
    NOT?: SyncHistoryScalarWhereWithAggregatesInput | SyncHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SyncHistory"> | string
    terminalId?: StringWithAggregatesFilter<"SyncHistory"> | string
    syncType?: EnumSyncTypeWithAggregatesFilter<"SyncHistory"> | $Enums.SyncType
    direction?: EnumSyncDirectionWithAggregatesFilter<"SyncHistory"> | $Enums.SyncDirection
    entitiesProcessed?: IntWithAggregatesFilter<"SyncHistory"> | number
    successCount?: IntWithAggregatesFilter<"SyncHistory"> | number
    failureCount?: IntWithAggregatesFilter<"SyncHistory"> | number
    conflictsFound?: IntWithAggregatesFilter<"SyncHistory"> | number
    startedAt?: DateTimeWithAggregatesFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"SyncHistory"> | Date | string | null
    durationMs?: IntNullableWithAggregatesFilter<"SyncHistory"> | number | null
    success?: BoolWithAggregatesFilter<"SyncHistory"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"SyncHistory"> | string | null
  }

  export type StoreWhereInput = {
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    id?: StringFilter<"Store"> | string
    storeCode?: StringFilter<"Store"> | string
    storeName?: StringFilter<"Store"> | string
    legalName?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    addressLine1?: StringNullableFilter<"Store"> | string | null
    city?: StringNullableFilter<"Store"> | string | null
    state?: StringNullableFilter<"Store"> | string | null
    zipCode?: StringNullableFilter<"Store"> | string | null
    timezone?: StringFilter<"Store"> | string
    defaultCurrency?: StringFilter<"Store"> | string
    syncVersion?: IntFilter<"Store"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Store"> | Date | string | null
    isDirty?: BoolFilter<"Store"> | boolean
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
  }

  export type StoreOrderByWithRelationInput = {
    id?: SortOrder
    storeCode?: SortOrder
    storeName?: SortOrder
    legalName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    timezone?: SortOrder
    defaultCurrency?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    storeCode?: string
    AND?: StoreWhereInput | StoreWhereInput[]
    OR?: StoreWhereInput[]
    NOT?: StoreWhereInput | StoreWhereInput[]
    storeName?: StringFilter<"Store"> | string
    legalName?: StringNullableFilter<"Store"> | string | null
    email?: StringNullableFilter<"Store"> | string | null
    phone?: StringNullableFilter<"Store"> | string | null
    addressLine1?: StringNullableFilter<"Store"> | string | null
    city?: StringNullableFilter<"Store"> | string | null
    state?: StringNullableFilter<"Store"> | string | null
    zipCode?: StringNullableFilter<"Store"> | string | null
    timezone?: StringFilter<"Store"> | string
    defaultCurrency?: StringFilter<"Store"> | string
    syncVersion?: IntFilter<"Store"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Store"> | Date | string | null
    isDirty?: BoolFilter<"Store"> | boolean
    isActive?: BoolFilter<"Store"> | boolean
    createdAt?: DateTimeFilter<"Store"> | Date | string
    updatedAt?: DateTimeFilter<"Store"> | Date | string
  }, "id" | "storeCode">

  export type StoreOrderByWithAggregationInput = {
    id?: SortOrder
    storeCode?: SortOrder
    storeName?: SortOrder
    legalName?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrderInput | SortOrder
    timezone?: SortOrder
    defaultCurrency?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StoreCountOrderByAggregateInput
    _avg?: StoreAvgOrderByAggregateInput
    _max?: StoreMaxOrderByAggregateInput
    _min?: StoreMinOrderByAggregateInput
    _sum?: StoreSumOrderByAggregateInput
  }

  export type StoreScalarWhereWithAggregatesInput = {
    AND?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    OR?: StoreScalarWhereWithAggregatesInput[]
    NOT?: StoreScalarWhereWithAggregatesInput | StoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Store"> | string
    storeCode?: StringWithAggregatesFilter<"Store"> | string
    storeName?: StringWithAggregatesFilter<"Store"> | string
    legalName?: StringNullableWithAggregatesFilter<"Store"> | string | null
    email?: StringNullableWithAggregatesFilter<"Store"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Store"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Store"> | string | null
    city?: StringNullableWithAggregatesFilter<"Store"> | string | null
    state?: StringNullableWithAggregatesFilter<"Store"> | string | null
    zipCode?: StringNullableWithAggregatesFilter<"Store"> | string | null
    timezone?: StringWithAggregatesFilter<"Store"> | string
    defaultCurrency?: StringWithAggregatesFilter<"Store"> | string
    syncVersion?: IntWithAggregatesFilter<"Store"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Store"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Store"> | boolean
    isActive?: BoolWithAggregatesFilter<"Store"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Store"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    code?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    centralLocationId?: StringNullableFilter<"Location"> | string | null
    centralBranchId?: StringNullableFilter<"Location"> | string | null
    timezone?: StringFilter<"Location"> | string
    taxRate?: FloatFilter<"Location"> | number
    syncVersion?: IntFilter<"Location"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Location"> | Date | string | null
    isDirty?: BoolFilter<"Location"> | boolean
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    saleOrders?: SaleOrderListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    shifts?: ShiftListRelationFilter
    stockAdjustments?: StockAdjustmentListRelationFilter
    stockTransfersFrom?: StockTransferListRelationFilter
    stockTransfersTo?: StockTransferListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    centralLocationId?: SortOrderInput | SortOrder
    centralBranchId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    taxRate?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    saleOrders?: SaleOrderOrderByRelationAggregateInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    shifts?: ShiftOrderByRelationAggregateInput
    stockAdjustments?: StockAdjustmentOrderByRelationAggregateInput
    stockTransfersFrom?: StockTransferOrderByRelationAggregateInput
    stockTransfersTo?: StockTransferOrderByRelationAggregateInput
    returnOrders?: ReturnOrderOrderByRelationAggregateInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    type?: EnumLocationTypeFilter<"Location"> | $Enums.LocationType
    address?: StringNullableFilter<"Location"> | string | null
    phone?: StringNullableFilter<"Location"> | string | null
    centralLocationId?: StringNullableFilter<"Location"> | string | null
    centralBranchId?: StringNullableFilter<"Location"> | string | null
    timezone?: StringFilter<"Location"> | string
    taxRate?: FloatFilter<"Location"> | number
    syncVersion?: IntFilter<"Location"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Location"> | Date | string | null
    isDirty?: BoolFilter<"Location"> | boolean
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    saleOrders?: SaleOrderListRelationFilter
    inventoryItems?: InventoryItemListRelationFilter
    shifts?: ShiftListRelationFilter
    stockAdjustments?: StockAdjustmentListRelationFilter
    stockTransfersFrom?: StockTransferListRelationFilter
    stockTransfersTo?: StockTransferListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
  }, "id" | "code">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    centralLocationId?: SortOrderInput | SortOrder
    centralBranchId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    taxRate?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _avg?: LocationAvgOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
    _sum?: LocationSumOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    code?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    type?: EnumLocationTypeWithAggregatesFilter<"Location"> | $Enums.LocationType
    address?: StringNullableWithAggregatesFilter<"Location"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Location"> | string | null
    centralLocationId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    centralBranchId?: StringNullableWithAggregatesFilter<"Location"> | string | null
    timezone?: StringWithAggregatesFilter<"Location"> | string
    taxRate?: FloatWithAggregatesFilter<"Location"> | number
    syncVersion?: IntWithAggregatesFilter<"Location"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Location"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Location"> | boolean
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: StringNullableFilter<"Product"> | string | null
    brandId?: StringNullableFilter<"Product"> | string | null
    taxCategoryId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    syncVersion?: IntFilter<"Product"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    isDirty?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    taxCategory?: XOR<TaxCategoryNullableScalarRelationFilter, TaxCategoryWhereInput> | null
    variants?: ProductVariantListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    taxCategoryId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    taxCategory?: TaxCategoryOrderByWithRelationInput
    variants?: ProductVariantOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: StringNullableFilter<"Product"> | string | null
    brandId?: StringNullableFilter<"Product"> | string | null
    taxCategoryId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    syncVersion?: IntFilter<"Product"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    isDirty?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    taxCategory?: XOR<TaxCategoryNullableScalarRelationFilter, TaxCategoryWhereInput> | null
    variants?: ProductVariantListRelationFilter
  }, "id" | "code">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    brandId?: SortOrderInput | SortOrder
    taxCategoryId?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    code?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    type?: EnumProductTypeWithAggregatesFilter<"Product"> | $Enums.ProductType
    categoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    brandId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    taxCategoryId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    syncVersion?: IntWithAggregatesFilter<"Product"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Product"> | boolean
    isActive?: BoolWithAggregatesFilter<"Product"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductVariantWhereInput = {
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    name?: StringNullableFilter<"ProductVariant"> | string | null
    cost?: FloatFilter<"ProductVariant"> | number
    price?: FloatFilter<"ProductVariant"> | number
    compareAtPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    trackInventory?: BoolFilter<"ProductVariant"> | boolean
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    upc?: StringNullableFilter<"ProductVariant"> | string | null
    ean?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    style?: StringNullableFilter<"ProductVariant"> | string | null
    weight?: FloatNullableFilter<"ProductVariant"> | number | null
    weightUnit?: StringNullableFilter<"ProductVariant"> | string | null
    syncVersion?: IntFilter<"ProductVariant"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ProductVariant"> | Date | string | null
    isDirty?: BoolFilter<"ProductVariant"> | boolean
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
    saleOrderLines?: SaleOrderLineListRelationFilter
    returnOrderLines?: ReturnOrderLineListRelationFilter
    stockAdjustmentLines?: StockAdjustmentLineListRelationFilter
    stockTransferLines?: StockTransferLineListRelationFilter
  }

  export type ProductVariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrderInput | SortOrder
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrderInput | SortOrder
    trackInventory?: SortOrder
    barcode?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    ean?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    inventoryItems?: InventoryItemOrderByRelationAggregateInput
    saleOrderLines?: SaleOrderLineOrderByRelationAggregateInput
    returnOrderLines?: ReturnOrderLineOrderByRelationAggregateInput
    stockAdjustmentLines?: StockAdjustmentLineOrderByRelationAggregateInput
    stockTransferLines?: StockTransferLineOrderByRelationAggregateInput
  }

  export type ProductVariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    barcode?: string
    AND?: ProductVariantWhereInput | ProductVariantWhereInput[]
    OR?: ProductVariantWhereInput[]
    NOT?: ProductVariantWhereInput | ProductVariantWhereInput[]
    productId?: StringFilter<"ProductVariant"> | string
    name?: StringNullableFilter<"ProductVariant"> | string | null
    cost?: FloatFilter<"ProductVariant"> | number
    price?: FloatFilter<"ProductVariant"> | number
    compareAtPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    trackInventory?: BoolFilter<"ProductVariant"> | boolean
    upc?: StringNullableFilter<"ProductVariant"> | string | null
    ean?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    style?: StringNullableFilter<"ProductVariant"> | string | null
    weight?: FloatNullableFilter<"ProductVariant"> | number | null
    weightUnit?: StringNullableFilter<"ProductVariant"> | string | null
    syncVersion?: IntFilter<"ProductVariant"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ProductVariant"> | Date | string | null
    isDirty?: BoolFilter<"ProductVariant"> | boolean
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    inventoryItems?: InventoryItemListRelationFilter
    saleOrderLines?: SaleOrderLineListRelationFilter
    returnOrderLines?: ReturnOrderLineListRelationFilter
    stockAdjustmentLines?: StockAdjustmentLineListRelationFilter
    stockTransferLines?: StockTransferLineListRelationFilter
  }, "id" | "sku" | "barcode">

  export type ProductVariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrderInput | SortOrder
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrderInput | SortOrder
    trackInventory?: SortOrder
    barcode?: SortOrderInput | SortOrder
    upc?: SortOrderInput | SortOrder
    ean?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    material?: SortOrderInput | SortOrder
    style?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    weightUnit?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductVariantCountOrderByAggregateInput
    _avg?: ProductVariantAvgOrderByAggregateInput
    _max?: ProductVariantMaxOrderByAggregateInput
    _min?: ProductVariantMinOrderByAggregateInput
    _sum?: ProductVariantSumOrderByAggregateInput
  }

  export type ProductVariantScalarWhereWithAggregatesInput = {
    AND?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    OR?: ProductVariantScalarWhereWithAggregatesInput[]
    NOT?: ProductVariantScalarWhereWithAggregatesInput | ProductVariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductVariant"> | string
    productId?: StringWithAggregatesFilter<"ProductVariant"> | string
    sku?: StringWithAggregatesFilter<"ProductVariant"> | string
    name?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    cost?: FloatWithAggregatesFilter<"ProductVariant"> | number
    price?: FloatWithAggregatesFilter<"ProductVariant"> | number
    compareAtPrice?: FloatNullableWithAggregatesFilter<"ProductVariant"> | number | null
    trackInventory?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    barcode?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    upc?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    ean?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    color?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    size?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    material?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    style?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    weight?: FloatNullableWithAggregatesFilter<"ProductVariant"> | number | null
    weightUnit?: StringNullableWithAggregatesFilter<"ProductVariant"> | string | null
    syncVersion?: IntWithAggregatesFilter<"ProductVariant"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"ProductVariant"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    isActive?: BoolWithAggregatesFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProductVariant"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    code?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    syncVersion?: IntFilter<"Category"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    isDirty?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parent?: CategoryOrderByWithRelationInput
    children?: CategoryOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    syncVersion?: IntFilter<"Category"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    isDirty?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    parent?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    children?: CategoryListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "code">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    code?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Category"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Category"> | string | null
    syncVersion?: IntWithAggregatesFilter<"Category"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Category"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Category"> | boolean
    isActive?: BoolWithAggregatesFilter<"Category"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    code?: StringFilter<"Brand"> | string
    name?: StringFilter<"Brand"> | string
    description?: StringNullableFilter<"Brand"> | string | null
    logoUrl?: StringNullableFilter<"Brand"> | string | null
    syncVersion?: IntFilter<"Brand"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    isDirty?: BoolFilter<"Brand"> | boolean
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    products?: ProductListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    name?: StringFilter<"Brand"> | string
    description?: StringNullableFilter<"Brand"> | string | null
    logoUrl?: StringNullableFilter<"Brand"> | string | null
    syncVersion?: IntFilter<"Brand"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Brand"> | Date | string | null
    isDirty?: BoolFilter<"Brand"> | boolean
    isActive?: BoolFilter<"Brand"> | boolean
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    products?: ProductListRelationFilter
  }, "id" | "code">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _avg?: BrandAvgOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
    _sum?: BrandSumOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    code?: StringWithAggregatesFilter<"Brand"> | string
    name?: StringWithAggregatesFilter<"Brand"> | string
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    syncVersion?: IntWithAggregatesFilter<"Brand"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Brand"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Brand"> | boolean
    isActive?: BoolWithAggregatesFilter<"Brand"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    gender?: StringNullableFilter<"Customer"> | string | null
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    groupId?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: FloatFilter<"Customer"> | number
    totalOrders?: IntFilter<"Customer"> | number
    creditLimit?: FloatNullableFilter<"Customer"> | number | null
    currentBalance?: FloatFilter<"Customer"> | number
    allowMarketing?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    syncVersion?: IntFilter<"Customer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isDirty?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    group?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    addresses?: CustomerAddressListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    type?: SortOrder
    groupId?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    currentBalance?: SortOrder
    allowMarketing?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    group?: CustomerGroupOrderByWithRelationInput
    addresses?: CustomerAddressOrderByRelationAggregateInput
    saleOrders?: SaleOrderOrderByRelationAggregateInput
    returnOrders?: ReturnOrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    email?: string
    phone?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    gender?: StringNullableFilter<"Customer"> | string | null
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    groupId?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: FloatFilter<"Customer"> | number
    totalOrders?: IntFilter<"Customer"> | number
    creditLimit?: FloatNullableFilter<"Customer"> | number | null
    currentBalance?: FloatFilter<"Customer"> | number
    allowMarketing?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    syncVersion?: IntFilter<"Customer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isDirty?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    group?: XOR<CustomerGroupNullableScalarRelationFilter, CustomerGroupWhereInput> | null
    addresses?: CustomerAddressListRelationFilter
    saleOrders?: SaleOrderListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
  }, "id" | "code" | "email" | "phone">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    type?: SortOrder
    groupId?: SortOrderInput | SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrderInput | SortOrder
    currentBalance?: SortOrder
    allowMarketing?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    code?: StringWithAggregatesFilter<"Customer"> | string
    firstName?: StringWithAggregatesFilter<"Customer"> | string
    lastName?: StringWithAggregatesFilter<"Customer"> | string
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    type?: EnumCustomerTypeWithAggregatesFilter<"Customer"> | $Enums.CustomerType
    groupId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    loyaltyPoints?: IntWithAggregatesFilter<"Customer"> | number
    totalSpent?: FloatWithAggregatesFilter<"Customer"> | number
    totalOrders?: IntWithAggregatesFilter<"Customer"> | number
    creditLimit?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    currentBalance?: FloatWithAggregatesFilter<"Customer"> | number
    allowMarketing?: BoolWithAggregatesFilter<"Customer"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    syncVersion?: IntWithAggregatesFilter<"Customer"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Customer"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Customer"> | boolean
    isActive?: BoolWithAggregatesFilter<"Customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type CustomerGroupWhereInput = {
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    id?: StringFilter<"CustomerGroup"> | string
    code?: StringFilter<"CustomerGroup"> | string
    name?: StringFilter<"CustomerGroup"> | string
    description?: StringNullableFilter<"CustomerGroup"> | string | null
    discountPercent?: FloatFilter<"CustomerGroup"> | number
    syncVersion?: IntFilter<"CustomerGroup"> | number
    lastSyncedAt?: DateTimeNullableFilter<"CustomerGroup"> | Date | string | null
    isDirty?: BoolFilter<"CustomerGroup"> | boolean
    isActive?: BoolFilter<"CustomerGroup"> | boolean
    createdAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    customers?: CustomerListRelationFilter
  }

  export type CustomerGroupOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customers?: CustomerOrderByRelationAggregateInput
  }

  export type CustomerGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    OR?: CustomerGroupWhereInput[]
    NOT?: CustomerGroupWhereInput | CustomerGroupWhereInput[]
    name?: StringFilter<"CustomerGroup"> | string
    description?: StringNullableFilter<"CustomerGroup"> | string | null
    discountPercent?: FloatFilter<"CustomerGroup"> | number
    syncVersion?: IntFilter<"CustomerGroup"> | number
    lastSyncedAt?: DateTimeNullableFilter<"CustomerGroup"> | Date | string | null
    isDirty?: BoolFilter<"CustomerGroup"> | boolean
    isActive?: BoolFilter<"CustomerGroup"> | boolean
    createdAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerGroup"> | Date | string
    customers?: CustomerListRelationFilter
  }, "id" | "code">

  export type CustomerGroupOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    discountPercent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerGroupCountOrderByAggregateInput
    _avg?: CustomerGroupAvgOrderByAggregateInput
    _max?: CustomerGroupMaxOrderByAggregateInput
    _min?: CustomerGroupMinOrderByAggregateInput
    _sum?: CustomerGroupSumOrderByAggregateInput
  }

  export type CustomerGroupScalarWhereWithAggregatesInput = {
    AND?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    OR?: CustomerGroupScalarWhereWithAggregatesInput[]
    NOT?: CustomerGroupScalarWhereWithAggregatesInput | CustomerGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerGroup"> | string
    code?: StringWithAggregatesFilter<"CustomerGroup"> | string
    name?: StringWithAggregatesFilter<"CustomerGroup"> | string
    description?: StringNullableWithAggregatesFilter<"CustomerGroup"> | string | null
    discountPercent?: FloatWithAggregatesFilter<"CustomerGroup"> | number
    syncVersion?: IntWithAggregatesFilter<"CustomerGroup"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"CustomerGroup"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"CustomerGroup"> | boolean
    isActive?: BoolWithAggregatesFilter<"CustomerGroup"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerGroup"> | Date | string
  }

  export type CustomerAddressWhereInput = {
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    zipCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }

  export type CustomerAddressOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: CustomerOrderByWithRelationInput
  }

  export type CustomerAddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    OR?: CustomerAddressWhereInput[]
    NOT?: CustomerAddressWhereInput | CustomerAddressWhereInput[]
    customerId?: StringFilter<"CustomerAddress"> | string
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    zipCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, CustomerWhereInput>
  }, "id">

  export type CustomerAddressOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrderInput | SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerAddressCountOrderByAggregateInput
    _max?: CustomerAddressMaxOrderByAggregateInput
    _min?: CustomerAddressMinOrderByAggregateInput
  }

  export type CustomerAddressScalarWhereWithAggregatesInput = {
    AND?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    OR?: CustomerAddressScalarWhereWithAggregatesInput[]
    NOT?: CustomerAddressScalarWhereWithAggregatesInput | CustomerAddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CustomerAddress"> | string
    customerId?: StringWithAggregatesFilter<"CustomerAddress"> | string
    type?: EnumAddressTypeWithAggregatesFilter<"CustomerAddress"> | $Enums.AddressType
    addressLine1?: StringWithAggregatesFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    city?: StringWithAggregatesFilter<"CustomerAddress"> | string
    state?: StringNullableWithAggregatesFilter<"CustomerAddress"> | string | null
    zipCode?: StringWithAggregatesFilter<"CustomerAddress"> | string
    country?: StringWithAggregatesFilter<"CustomerAddress"> | string
    isDefault?: BoolWithAggregatesFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerAddress"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    variantId?: StringFilter<"InventoryItem"> | string
    locationId?: StringFilter<"InventoryItem"> | string
    quantityOnHand?: IntFilter<"InventoryItem"> | number
    quantityReserved?: IntFilter<"InventoryItem"> | number
    quantityAvailable?: IntFilter<"InventoryItem"> | number
    reorderPoint?: IntNullableFilter<"InventoryItem"> | number | null
    reorderQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    lastReceivedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    syncVersion?: IntFilter<"InventoryItem"> | number
    lastSyncedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    isDirty?: BoolFilter<"InventoryItem"> | boolean
    pendingSync?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    locationId?: SortOrder
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrderInput | SortOrder
    reorderQuantity?: SortOrderInput | SortOrder
    lastCountedAt?: SortOrderInput | SortOrder
    lastReceivedAt?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    pendingSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    variant?: ProductVariantOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variantId_locationId?: InventoryItemVariantIdLocationIdCompoundUniqueInput
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    variantId?: StringFilter<"InventoryItem"> | string
    locationId?: StringFilter<"InventoryItem"> | string
    quantityOnHand?: IntFilter<"InventoryItem"> | number
    quantityReserved?: IntFilter<"InventoryItem"> | number
    quantityAvailable?: IntFilter<"InventoryItem"> | number
    reorderPoint?: IntNullableFilter<"InventoryItem"> | number | null
    reorderQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    lastReceivedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    syncVersion?: IntFilter<"InventoryItem"> | number
    lastSyncedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    isDirty?: BoolFilter<"InventoryItem"> | boolean
    pendingSync?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id" | "variantId_locationId">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    locationId?: SortOrder
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrderInput | SortOrder
    reorderQuantity?: SortOrderInput | SortOrder
    lastCountedAt?: SortOrderInput | SortOrder
    lastReceivedAt?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    pendingSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    variantId?: StringWithAggregatesFilter<"InventoryItem"> | string
    locationId?: StringWithAggregatesFilter<"InventoryItem"> | string
    quantityOnHand?: IntWithAggregatesFilter<"InventoryItem"> | number
    quantityReserved?: IntWithAggregatesFilter<"InventoryItem"> | number
    quantityAvailable?: IntWithAggregatesFilter<"InventoryItem"> | number
    reorderPoint?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    reorderQuantity?: IntNullableWithAggregatesFilter<"InventoryItem"> | number | null
    lastCountedAt?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    lastReceivedAt?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    syncVersion?: IntWithAggregatesFilter<"InventoryItem"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"InventoryItem"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    pendingSync?: BoolWithAggregatesFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type StockAdjustmentWhereInput = {
    AND?: StockAdjustmentWhereInput | StockAdjustmentWhereInput[]
    OR?: StockAdjustmentWhereInput[]
    NOT?: StockAdjustmentWhereInput | StockAdjustmentWhereInput[]
    id?: StringFilter<"StockAdjustment"> | string
    locationId?: StringFilter<"StockAdjustment"> | string
    adjustmentType?: EnumStockAdjustmentTypeFilter<"StockAdjustment"> | $Enums.StockAdjustmentType
    reason?: StringNullableFilter<"StockAdjustment"> | string | null
    referenceNumber?: StringNullableFilter<"StockAdjustment"> | string | null
    notes?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedBy?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedAt?: DateTimeFilter<"StockAdjustment"> | Date | string
    syncVersion?: IntFilter<"StockAdjustment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockAdjustment"> | Date | string | null
    isDirty?: BoolFilter<"StockAdjustment"> | boolean
    createdAt?: DateTimeFilter<"StockAdjustment"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lineItems?: StockAdjustmentLineListRelationFilter
  }

  export type StockAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    adjustmentType?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adjustedBy?: SortOrderInput | SortOrder
    adjustedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    lineItems?: StockAdjustmentLineOrderByRelationAggregateInput
  }

  export type StockAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: StockAdjustmentWhereInput | StockAdjustmentWhereInput[]
    OR?: StockAdjustmentWhereInput[]
    NOT?: StockAdjustmentWhereInput | StockAdjustmentWhereInput[]
    locationId?: StringFilter<"StockAdjustment"> | string
    adjustmentType?: EnumStockAdjustmentTypeFilter<"StockAdjustment"> | $Enums.StockAdjustmentType
    reason?: StringNullableFilter<"StockAdjustment"> | string | null
    notes?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedBy?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedAt?: DateTimeFilter<"StockAdjustment"> | Date | string
    syncVersion?: IntFilter<"StockAdjustment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockAdjustment"> | Date | string | null
    isDirty?: BoolFilter<"StockAdjustment"> | boolean
    createdAt?: DateTimeFilter<"StockAdjustment"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lineItems?: StockAdjustmentLineListRelationFilter
  }, "id" | "referenceNumber">

  export type StockAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    adjustmentType?: SortOrder
    reason?: SortOrderInput | SortOrder
    referenceNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    adjustedBy?: SortOrderInput | SortOrder
    adjustedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    _count?: StockAdjustmentCountOrderByAggregateInput
    _avg?: StockAdjustmentAvgOrderByAggregateInput
    _max?: StockAdjustmentMaxOrderByAggregateInput
    _min?: StockAdjustmentMinOrderByAggregateInput
    _sum?: StockAdjustmentSumOrderByAggregateInput
  }

  export type StockAdjustmentScalarWhereWithAggregatesInput = {
    AND?: StockAdjustmentScalarWhereWithAggregatesInput | StockAdjustmentScalarWhereWithAggregatesInput[]
    OR?: StockAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: StockAdjustmentScalarWhereWithAggregatesInput | StockAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockAdjustment"> | string
    locationId?: StringWithAggregatesFilter<"StockAdjustment"> | string
    adjustmentType?: EnumStockAdjustmentTypeWithAggregatesFilter<"StockAdjustment"> | $Enums.StockAdjustmentType
    reason?: StringNullableWithAggregatesFilter<"StockAdjustment"> | string | null
    referenceNumber?: StringNullableWithAggregatesFilter<"StockAdjustment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"StockAdjustment"> | string | null
    adjustedBy?: StringNullableWithAggregatesFilter<"StockAdjustment"> | string | null
    adjustedAt?: DateTimeWithAggregatesFilter<"StockAdjustment"> | Date | string
    syncVersion?: IntWithAggregatesFilter<"StockAdjustment"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"StockAdjustment"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"StockAdjustment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StockAdjustment"> | Date | string
  }

  export type StockAdjustmentLineWhereInput = {
    AND?: StockAdjustmentLineWhereInput | StockAdjustmentLineWhereInput[]
    OR?: StockAdjustmentLineWhereInput[]
    NOT?: StockAdjustmentLineWhereInput | StockAdjustmentLineWhereInput[]
    id?: StringFilter<"StockAdjustmentLine"> | string
    adjustmentId?: StringFilter<"StockAdjustmentLine"> | string
    variantId?: StringFilter<"StockAdjustmentLine"> | string
    quantityBefore?: IntFilter<"StockAdjustmentLine"> | number
    quantityAfter?: IntFilter<"StockAdjustmentLine"> | number
    quantityChange?: IntFilter<"StockAdjustmentLine"> | number
    adjustment?: XOR<StockAdjustmentScalarRelationFilter, StockAdjustmentWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }

  export type StockAdjustmentLineOrderByWithRelationInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    variantId?: SortOrder
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
    adjustment?: StockAdjustmentOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type StockAdjustmentLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockAdjustmentLineWhereInput | StockAdjustmentLineWhereInput[]
    OR?: StockAdjustmentLineWhereInput[]
    NOT?: StockAdjustmentLineWhereInput | StockAdjustmentLineWhereInput[]
    adjustmentId?: StringFilter<"StockAdjustmentLine"> | string
    variantId?: StringFilter<"StockAdjustmentLine"> | string
    quantityBefore?: IntFilter<"StockAdjustmentLine"> | number
    quantityAfter?: IntFilter<"StockAdjustmentLine"> | number
    quantityChange?: IntFilter<"StockAdjustmentLine"> | number
    adjustment?: XOR<StockAdjustmentScalarRelationFilter, StockAdjustmentWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }, "id">

  export type StockAdjustmentLineOrderByWithAggregationInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    variantId?: SortOrder
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
    _count?: StockAdjustmentLineCountOrderByAggregateInput
    _avg?: StockAdjustmentLineAvgOrderByAggregateInput
    _max?: StockAdjustmentLineMaxOrderByAggregateInput
    _min?: StockAdjustmentLineMinOrderByAggregateInput
    _sum?: StockAdjustmentLineSumOrderByAggregateInput
  }

  export type StockAdjustmentLineScalarWhereWithAggregatesInput = {
    AND?: StockAdjustmentLineScalarWhereWithAggregatesInput | StockAdjustmentLineScalarWhereWithAggregatesInput[]
    OR?: StockAdjustmentLineScalarWhereWithAggregatesInput[]
    NOT?: StockAdjustmentLineScalarWhereWithAggregatesInput | StockAdjustmentLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockAdjustmentLine"> | string
    adjustmentId?: StringWithAggregatesFilter<"StockAdjustmentLine"> | string
    variantId?: StringWithAggregatesFilter<"StockAdjustmentLine"> | string
    quantityBefore?: IntWithAggregatesFilter<"StockAdjustmentLine"> | number
    quantityAfter?: IntWithAggregatesFilter<"StockAdjustmentLine"> | number
    quantityChange?: IntWithAggregatesFilter<"StockAdjustmentLine"> | number
  }

  export type StockTransferWhereInput = {
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    fromLocationId?: StringFilter<"StockTransfer"> | string
    toLocationId?: StringFilter<"StockTransfer"> | string
    transferNumber?: StringFilter<"StockTransfer"> | string
    status?: EnumTransferStatusFilter<"StockTransfer"> | $Enums.TransferStatus
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringNullableFilter<"StockTransfer"> | string | null
    syncVersion?: IntFilter<"StockTransfer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    isDirty?: BoolFilter<"StockTransfer"> | boolean
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
    fromLocation?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    toLocation?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lineItems?: StockTransferLineListRelationFilter
  }

  export type StockTransferOrderByWithRelationInput = {
    id?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromLocation?: LocationOrderByWithRelationInput
    toLocation?: LocationOrderByWithRelationInput
    lineItems?: StockTransferLineOrderByRelationAggregateInput
  }

  export type StockTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transferNumber?: string
    AND?: StockTransferWhereInput | StockTransferWhereInput[]
    OR?: StockTransferWhereInput[]
    NOT?: StockTransferWhereInput | StockTransferWhereInput[]
    fromLocationId?: StringFilter<"StockTransfer"> | string
    toLocationId?: StringFilter<"StockTransfer"> | string
    status?: EnumTransferStatusFilter<"StockTransfer"> | $Enums.TransferStatus
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringNullableFilter<"StockTransfer"> | string | null
    syncVersion?: IntFilter<"StockTransfer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    isDirty?: BoolFilter<"StockTransfer"> | boolean
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
    fromLocation?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    toLocation?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lineItems?: StockTransferLineListRelationFilter
  }, "id" | "transferNumber">

  export type StockTransferOrderByWithAggregationInput = {
    id?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StockTransferCountOrderByAggregateInput
    _avg?: StockTransferAvgOrderByAggregateInput
    _max?: StockTransferMaxOrderByAggregateInput
    _min?: StockTransferMinOrderByAggregateInput
    _sum?: StockTransferSumOrderByAggregateInput
  }

  export type StockTransferScalarWhereWithAggregatesInput = {
    AND?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    OR?: StockTransferScalarWhereWithAggregatesInput[]
    NOT?: StockTransferScalarWhereWithAggregatesInput | StockTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransfer"> | string
    fromLocationId?: StringWithAggregatesFilter<"StockTransfer"> | string
    toLocationId?: StringWithAggregatesFilter<"StockTransfer"> | string
    transferNumber?: StringWithAggregatesFilter<"StockTransfer"> | string
    status?: EnumTransferStatusWithAggregatesFilter<"StockTransfer"> | $Enums.TransferStatus
    transferDate?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"StockTransfer"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"StockTransfer"> | string | null
    syncVersion?: IntWithAggregatesFilter<"StockTransfer"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"StockTransfer"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"StockTransfer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StockTransfer"> | Date | string
  }

  export type StockTransferLineWhereInput = {
    AND?: StockTransferLineWhereInput | StockTransferLineWhereInput[]
    OR?: StockTransferLineWhereInput[]
    NOT?: StockTransferLineWhereInput | StockTransferLineWhereInput[]
    id?: StringFilter<"StockTransferLine"> | string
    transferId?: StringFilter<"StockTransferLine"> | string
    variantId?: StringFilter<"StockTransferLine"> | string
    quantity?: IntFilter<"StockTransferLine"> | number
    received?: IntNullableFilter<"StockTransferLine"> | number | null
    transfer?: XOR<StockTransferScalarRelationFilter, StockTransferWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }

  export type StockTransferLineOrderByWithRelationInput = {
    id?: SortOrder
    transferId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    received?: SortOrderInput | SortOrder
    transfer?: StockTransferOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type StockTransferLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockTransferLineWhereInput | StockTransferLineWhereInput[]
    OR?: StockTransferLineWhereInput[]
    NOT?: StockTransferLineWhereInput | StockTransferLineWhereInput[]
    transferId?: StringFilter<"StockTransferLine"> | string
    variantId?: StringFilter<"StockTransferLine"> | string
    quantity?: IntFilter<"StockTransferLine"> | number
    received?: IntNullableFilter<"StockTransferLine"> | number | null
    transfer?: XOR<StockTransferScalarRelationFilter, StockTransferWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }, "id">

  export type StockTransferLineOrderByWithAggregationInput = {
    id?: SortOrder
    transferId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    received?: SortOrderInput | SortOrder
    _count?: StockTransferLineCountOrderByAggregateInput
    _avg?: StockTransferLineAvgOrderByAggregateInput
    _max?: StockTransferLineMaxOrderByAggregateInput
    _min?: StockTransferLineMinOrderByAggregateInput
    _sum?: StockTransferLineSumOrderByAggregateInput
  }

  export type StockTransferLineScalarWhereWithAggregatesInput = {
    AND?: StockTransferLineScalarWhereWithAggregatesInput | StockTransferLineScalarWhereWithAggregatesInput[]
    OR?: StockTransferLineScalarWhereWithAggregatesInput[]
    NOT?: StockTransferLineScalarWhereWithAggregatesInput | StockTransferLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockTransferLine"> | string
    transferId?: StringWithAggregatesFilter<"StockTransferLine"> | string
    variantId?: StringWithAggregatesFilter<"StockTransferLine"> | string
    quantity?: IntWithAggregatesFilter<"StockTransferLine"> | number
    received?: IntNullableWithAggregatesFilter<"StockTransferLine"> | number | null
  }

  export type SaleOrderWhereInput = {
    AND?: SaleOrderWhereInput | SaleOrderWhereInput[]
    OR?: SaleOrderWhereInput[]
    NOT?: SaleOrderWhereInput | SaleOrderWhereInput[]
    id?: StringFilter<"SaleOrder"> | string
    locationId?: StringFilter<"SaleOrder"> | string
    terminalId?: StringNullableFilter<"SaleOrder"> | string | null
    orderNumber?: StringFilter<"SaleOrder"> | string
    type?: EnumOrderTypeFilter<"SaleOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"SaleOrder"> | $Enums.OrderStatus
    source?: EnumOrderSourceFilter<"SaleOrder"> | $Enums.OrderSource
    customerId?: StringNullableFilter<"SaleOrder"> | string | null
    shiftId?: StringNullableFilter<"SaleOrder"> | string | null
    userId?: StringNullableFilter<"SaleOrder"> | string | null
    subtotal?: FloatFilter<"SaleOrder"> | number
    taxAmount?: FloatFilter<"SaleOrder"> | number
    discountAmount?: FloatFilter<"SaleOrder"> | number
    total?: FloatFilter<"SaleOrder"> | number
    completedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidReason?: StringNullableFilter<"SaleOrder"> | string | null
    receiptPrinted?: BoolFilter<"SaleOrder"> | boolean
    receiptEmailed?: BoolFilter<"SaleOrder"> | boolean
    receiptPrintedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptEmailedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptNumber?: StringNullableFilter<"SaleOrder"> | string | null
    discountReason?: StringNullableFilter<"SaleOrder"> | string | null
    notes?: StringNullableFilter<"SaleOrder"> | string | null
    syncVersion?: IntFilter<"SaleOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    isDirty?: BoolFilter<"SaleOrder"> | boolean
    syncPriority?: IntFilter<"SaleOrder"> | number
    syncAttempts?: IntFilter<"SaleOrder"> | number
    createdAt?: DateTimeFilter<"SaleOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrder"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    terminal?: XOR<TerminalNullableScalarRelationFilter, TerminalWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
    user?: XOR<LocalUserNullableScalarRelationFilter, LocalUserWhereInput> | null
    lines?: SaleOrderLineListRelationFilter
    payments?: PaymentListRelationFilter
    discounts?: DiscountListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
    parkedOrders?: ParkedOrderListRelationFilter
    exchangesFrom?: ExchangeOrderListRelationFilter
    exchangesTo?: ExchangeOrderListRelationFilter
  }

  export type SaleOrderOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    customerId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    voidedAt?: SortOrderInput | SortOrder
    voidReason?: SortOrderInput | SortOrder
    receiptPrinted?: SortOrder
    receiptEmailed?: SortOrder
    receiptPrintedAt?: SortOrderInput | SortOrder
    receiptEmailedAt?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    discountReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    location?: LocationOrderByWithRelationInput
    terminal?: TerminalOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    shift?: ShiftOrderByWithRelationInput
    user?: LocalUserOrderByWithRelationInput
    lines?: SaleOrderLineOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
    returnOrders?: ReturnOrderOrderByRelationAggregateInput
    parkedOrders?: ParkedOrderOrderByRelationAggregateInput
    exchangesFrom?: ExchangeOrderOrderByRelationAggregateInput
    exchangesTo?: ExchangeOrderOrderByRelationAggregateInput
  }

  export type SaleOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderNumber?: string
    AND?: SaleOrderWhereInput | SaleOrderWhereInput[]
    OR?: SaleOrderWhereInput[]
    NOT?: SaleOrderWhereInput | SaleOrderWhereInput[]
    locationId?: StringFilter<"SaleOrder"> | string
    terminalId?: StringNullableFilter<"SaleOrder"> | string | null
    type?: EnumOrderTypeFilter<"SaleOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"SaleOrder"> | $Enums.OrderStatus
    source?: EnumOrderSourceFilter<"SaleOrder"> | $Enums.OrderSource
    customerId?: StringNullableFilter<"SaleOrder"> | string | null
    shiftId?: StringNullableFilter<"SaleOrder"> | string | null
    userId?: StringNullableFilter<"SaleOrder"> | string | null
    subtotal?: FloatFilter<"SaleOrder"> | number
    taxAmount?: FloatFilter<"SaleOrder"> | number
    discountAmount?: FloatFilter<"SaleOrder"> | number
    total?: FloatFilter<"SaleOrder"> | number
    completedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidReason?: StringNullableFilter<"SaleOrder"> | string | null
    receiptPrinted?: BoolFilter<"SaleOrder"> | boolean
    receiptEmailed?: BoolFilter<"SaleOrder"> | boolean
    receiptPrintedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptEmailedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptNumber?: StringNullableFilter<"SaleOrder"> | string | null
    discountReason?: StringNullableFilter<"SaleOrder"> | string | null
    notes?: StringNullableFilter<"SaleOrder"> | string | null
    syncVersion?: IntFilter<"SaleOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    isDirty?: BoolFilter<"SaleOrder"> | boolean
    syncPriority?: IntFilter<"SaleOrder"> | number
    syncAttempts?: IntFilter<"SaleOrder"> | number
    createdAt?: DateTimeFilter<"SaleOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrder"> | Date | string
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    terminal?: XOR<TerminalNullableScalarRelationFilter, TerminalWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    shift?: XOR<ShiftNullableScalarRelationFilter, ShiftWhereInput> | null
    user?: XOR<LocalUserNullableScalarRelationFilter, LocalUserWhereInput> | null
    lines?: SaleOrderLineListRelationFilter
    payments?: PaymentListRelationFilter
    discounts?: DiscountListRelationFilter
    returnOrders?: ReturnOrderListRelationFilter
    parkedOrders?: ParkedOrderListRelationFilter
    exchangesFrom?: ExchangeOrderListRelationFilter
    exchangesTo?: ExchangeOrderListRelationFilter
  }, "id" | "orderNumber">

  export type SaleOrderOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    customerId?: SortOrderInput | SortOrder
    shiftId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    voidedAt?: SortOrderInput | SortOrder
    voidReason?: SortOrderInput | SortOrder
    receiptPrinted?: SortOrder
    receiptEmailed?: SortOrder
    receiptPrintedAt?: SortOrderInput | SortOrder
    receiptEmailedAt?: SortOrderInput | SortOrder
    receiptNumber?: SortOrderInput | SortOrder
    discountReason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleOrderCountOrderByAggregateInput
    _avg?: SaleOrderAvgOrderByAggregateInput
    _max?: SaleOrderMaxOrderByAggregateInput
    _min?: SaleOrderMinOrderByAggregateInput
    _sum?: SaleOrderSumOrderByAggregateInput
  }

  export type SaleOrderScalarWhereWithAggregatesInput = {
    AND?: SaleOrderScalarWhereWithAggregatesInput | SaleOrderScalarWhereWithAggregatesInput[]
    OR?: SaleOrderScalarWhereWithAggregatesInput[]
    NOT?: SaleOrderScalarWhereWithAggregatesInput | SaleOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleOrder"> | string
    locationId?: StringWithAggregatesFilter<"SaleOrder"> | string
    terminalId?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    orderNumber?: StringWithAggregatesFilter<"SaleOrder"> | string
    type?: EnumOrderTypeWithAggregatesFilter<"SaleOrder"> | $Enums.OrderType
    status?: EnumOrderStatusWithAggregatesFilter<"SaleOrder"> | $Enums.OrderStatus
    source?: EnumOrderSourceWithAggregatesFilter<"SaleOrder"> | $Enums.OrderSource
    customerId?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    shiftId?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    userId?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    subtotal?: FloatWithAggregatesFilter<"SaleOrder"> | number
    taxAmount?: FloatWithAggregatesFilter<"SaleOrder"> | number
    discountAmount?: FloatWithAggregatesFilter<"SaleOrder"> | number
    total?: FloatWithAggregatesFilter<"SaleOrder"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"SaleOrder"> | Date | string | null
    voidedAt?: DateTimeNullableWithAggregatesFilter<"SaleOrder"> | Date | string | null
    voidReason?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    receiptPrinted?: BoolWithAggregatesFilter<"SaleOrder"> | boolean
    receiptEmailed?: BoolWithAggregatesFilter<"SaleOrder"> | boolean
    receiptPrintedAt?: DateTimeNullableWithAggregatesFilter<"SaleOrder"> | Date | string | null
    receiptEmailedAt?: DateTimeNullableWithAggregatesFilter<"SaleOrder"> | Date | string | null
    receiptNumber?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    discountReason?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SaleOrder"> | string | null
    syncVersion?: IntWithAggregatesFilter<"SaleOrder"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"SaleOrder"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"SaleOrder"> | boolean
    syncPriority?: IntWithAggregatesFilter<"SaleOrder"> | number
    syncAttempts?: IntWithAggregatesFilter<"SaleOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SaleOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleOrder"> | Date | string
  }

  export type SaleOrderLineWhereInput = {
    AND?: SaleOrderLineWhereInput | SaleOrderLineWhereInput[]
    OR?: SaleOrderLineWhereInput[]
    NOT?: SaleOrderLineWhereInput | SaleOrderLineWhereInput[]
    id?: StringFilter<"SaleOrderLine"> | string
    orderId?: StringFilter<"SaleOrderLine"> | string
    variantId?: StringFilter<"SaleOrderLine"> | string
    quantity?: IntFilter<"SaleOrderLine"> | number
    unitPrice?: FloatFilter<"SaleOrderLine"> | number
    discountAmount?: FloatFilter<"SaleOrderLine"> | number
    taxAmount?: FloatFilter<"SaleOrderLine"> | number
    lineTotal?: FloatFilter<"SaleOrderLine"> | number
    notes?: StringNullableFilter<"SaleOrderLine"> | string | null
    syncVersion?: IntFilter<"SaleOrderLine"> | number
    createdAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }

  export type SaleOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: SaleOrderOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type SaleOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleOrderLineWhereInput | SaleOrderLineWhereInput[]
    OR?: SaleOrderLineWhereInput[]
    NOT?: SaleOrderLineWhereInput | SaleOrderLineWhereInput[]
    orderId?: StringFilter<"SaleOrderLine"> | string
    variantId?: StringFilter<"SaleOrderLine"> | string
    quantity?: IntFilter<"SaleOrderLine"> | number
    unitPrice?: FloatFilter<"SaleOrderLine"> | number
    discountAmount?: FloatFilter<"SaleOrderLine"> | number
    taxAmount?: FloatFilter<"SaleOrderLine"> | number
    lineTotal?: FloatFilter<"SaleOrderLine"> | number
    notes?: StringNullableFilter<"SaleOrderLine"> | string | null
    syncVersion?: IntFilter<"SaleOrderLine"> | number
    createdAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }, "id">

  export type SaleOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleOrderLineCountOrderByAggregateInput
    _avg?: SaleOrderLineAvgOrderByAggregateInput
    _max?: SaleOrderLineMaxOrderByAggregateInput
    _min?: SaleOrderLineMinOrderByAggregateInput
    _sum?: SaleOrderLineSumOrderByAggregateInput
  }

  export type SaleOrderLineScalarWhereWithAggregatesInput = {
    AND?: SaleOrderLineScalarWhereWithAggregatesInput | SaleOrderLineScalarWhereWithAggregatesInput[]
    OR?: SaleOrderLineScalarWhereWithAggregatesInput[]
    NOT?: SaleOrderLineScalarWhereWithAggregatesInput | SaleOrderLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleOrderLine"> | string
    orderId?: StringWithAggregatesFilter<"SaleOrderLine"> | string
    variantId?: StringWithAggregatesFilter<"SaleOrderLine"> | string
    quantity?: IntWithAggregatesFilter<"SaleOrderLine"> | number
    unitPrice?: FloatWithAggregatesFilter<"SaleOrderLine"> | number
    discountAmount?: FloatWithAggregatesFilter<"SaleOrderLine"> | number
    taxAmount?: FloatWithAggregatesFilter<"SaleOrderLine"> | number
    lineTotal?: FloatWithAggregatesFilter<"SaleOrderLine"> | number
    notes?: StringNullableWithAggregatesFilter<"SaleOrderLine"> | string | null
    syncVersion?: IntWithAggregatesFilter<"SaleOrderLine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SaleOrderLine"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SaleOrderLine"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    cardLast4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    authCode?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    syncVersion?: IntFilter<"Payment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    isDirty?: BoolFilter<"Payment"> | boolean
    syncPriority?: IntFilter<"Payment"> | number
    processedAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reference?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    status?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: SaleOrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    orderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    cardLast4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    authCode?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    syncVersion?: IntFilter<"Payment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    isDirty?: BoolFilter<"Payment"> | boolean
    syncPriority?: IntFilter<"Payment"> | number
    processedAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reference?: SortOrderInput | SortOrder
    cardLast4?: SortOrderInput | SortOrder
    cardBrand?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    status?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    orderId?: StringWithAggregatesFilter<"Payment"> | string
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    reference?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    cardLast4?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    cardBrand?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    authCode?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    syncVersion?: IntWithAggregatesFilter<"Payment"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Payment"> | boolean
    syncPriority?: IntWithAggregatesFilter<"Payment"> | number
    processedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    orderId?: StringFilter<"Discount"> | string
    type?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    name?: StringFilter<"Discount"> | string
    code?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    percent?: FloatNullableFilter<"Discount"> | number | null
    syncVersion?: IntFilter<"Discount"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Discount"> | Date | string | null
    isDirty?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    amount?: SortOrder
    percent?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    order?: SaleOrderOrderByWithRelationInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    orderId?: StringFilter<"Discount"> | string
    type?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    name?: StringFilter<"Discount"> | string
    code?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    percent?: FloatNullableFilter<"Discount"> | number | null
    syncVersion?: IntFilter<"Discount"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Discount"> | Date | string | null
    isDirty?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }, "id">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    amount?: SortOrder
    percent?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    orderId?: StringWithAggregatesFilter<"Discount"> | string
    type?: EnumDiscountTypeWithAggregatesFilter<"Discount"> | $Enums.DiscountType
    name?: StringWithAggregatesFilter<"Discount"> | string
    code?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    amount?: FloatWithAggregatesFilter<"Discount"> | number
    percent?: FloatNullableWithAggregatesFilter<"Discount"> | number | null
    syncVersion?: IntWithAggregatesFilter<"Discount"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Discount"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Discount"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
  }

  export type ReturnOrderWhereInput = {
    AND?: ReturnOrderWhereInput | ReturnOrderWhereInput[]
    OR?: ReturnOrderWhereInput[]
    NOT?: ReturnOrderWhereInput | ReturnOrderWhereInput[]
    id?: StringFilter<"ReturnOrder"> | string
    returnNumber?: StringFilter<"ReturnOrder"> | string
    originalOrderId?: StringFilter<"ReturnOrder"> | string
    customerId?: StringNullableFilter<"ReturnOrder"> | string | null
    locationId?: StringFilter<"ReturnOrder"> | string
    reason?: EnumReturnReasonNullableFilter<"ReturnOrder"> | $Enums.ReturnReason | null
    notes?: StringNullableFilter<"ReturnOrder"> | string | null
    subtotal?: FloatFilter<"ReturnOrder"> | number
    taxAmount?: FloatFilter<"ReturnOrder"> | number
    total?: FloatFilter<"ReturnOrder"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnOrder"> | $Enums.RefundMethod | null
    refundAmount?: FloatFilter<"ReturnOrder"> | number
    status?: EnumReturnStatusFilter<"ReturnOrder"> | $Enums.ReturnStatus
    processedBy?: StringNullableFilter<"ReturnOrder"> | string | null
    processedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    syncVersion?: IntFilter<"ReturnOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    isDirty?: BoolFilter<"ReturnOrder"> | boolean
    syncAttempts?: IntFilter<"ReturnOrder"> | number
    createdAt?: DateTimeFilter<"ReturnOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnOrder"> | Date | string
    originalOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lines?: ReturnOrderLineListRelationFilter
  }

  export type ReturnOrderOrderByWithRelationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    originalOrderId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundAmount?: SortOrder
    status?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originalOrder?: SaleOrderOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    lines?: ReturnOrderLineOrderByRelationAggregateInput
  }

  export type ReturnOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    returnNumber?: string
    AND?: ReturnOrderWhereInput | ReturnOrderWhereInput[]
    OR?: ReturnOrderWhereInput[]
    NOT?: ReturnOrderWhereInput | ReturnOrderWhereInput[]
    originalOrderId?: StringFilter<"ReturnOrder"> | string
    customerId?: StringNullableFilter<"ReturnOrder"> | string | null
    locationId?: StringFilter<"ReturnOrder"> | string
    reason?: EnumReturnReasonNullableFilter<"ReturnOrder"> | $Enums.ReturnReason | null
    notes?: StringNullableFilter<"ReturnOrder"> | string | null
    subtotal?: FloatFilter<"ReturnOrder"> | number
    taxAmount?: FloatFilter<"ReturnOrder"> | number
    total?: FloatFilter<"ReturnOrder"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnOrder"> | $Enums.RefundMethod | null
    refundAmount?: FloatFilter<"ReturnOrder"> | number
    status?: EnumReturnStatusFilter<"ReturnOrder"> | $Enums.ReturnStatus
    processedBy?: StringNullableFilter<"ReturnOrder"> | string | null
    processedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    syncVersion?: IntFilter<"ReturnOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    isDirty?: BoolFilter<"ReturnOrder"> | boolean
    syncAttempts?: IntFilter<"ReturnOrder"> | number
    createdAt?: DateTimeFilter<"ReturnOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnOrder"> | Date | string
    originalOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    lines?: ReturnOrderLineListRelationFilter
  }, "id" | "returnNumber">

  export type ReturnOrderOrderByWithAggregationInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    originalOrderId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    locationId?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundMethod?: SortOrderInput | SortOrder
    refundAmount?: SortOrder
    status?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReturnOrderCountOrderByAggregateInput
    _avg?: ReturnOrderAvgOrderByAggregateInput
    _max?: ReturnOrderMaxOrderByAggregateInput
    _min?: ReturnOrderMinOrderByAggregateInput
    _sum?: ReturnOrderSumOrderByAggregateInput
  }

  export type ReturnOrderScalarWhereWithAggregatesInput = {
    AND?: ReturnOrderScalarWhereWithAggregatesInput | ReturnOrderScalarWhereWithAggregatesInput[]
    OR?: ReturnOrderScalarWhereWithAggregatesInput[]
    NOT?: ReturnOrderScalarWhereWithAggregatesInput | ReturnOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReturnOrder"> | string
    returnNumber?: StringWithAggregatesFilter<"ReturnOrder"> | string
    originalOrderId?: StringWithAggregatesFilter<"ReturnOrder"> | string
    customerId?: StringNullableWithAggregatesFilter<"ReturnOrder"> | string | null
    locationId?: StringWithAggregatesFilter<"ReturnOrder"> | string
    reason?: EnumReturnReasonNullableWithAggregatesFilter<"ReturnOrder"> | $Enums.ReturnReason | null
    notes?: StringNullableWithAggregatesFilter<"ReturnOrder"> | string | null
    subtotal?: FloatWithAggregatesFilter<"ReturnOrder"> | number
    taxAmount?: FloatWithAggregatesFilter<"ReturnOrder"> | number
    total?: FloatWithAggregatesFilter<"ReturnOrder"> | number
    refundMethod?: EnumRefundMethodNullableWithAggregatesFilter<"ReturnOrder"> | $Enums.RefundMethod | null
    refundAmount?: FloatWithAggregatesFilter<"ReturnOrder"> | number
    status?: EnumReturnStatusWithAggregatesFilter<"ReturnOrder"> | $Enums.ReturnStatus
    processedBy?: StringNullableWithAggregatesFilter<"ReturnOrder"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"ReturnOrder"> | Date | string | null
    syncVersion?: IntWithAggregatesFilter<"ReturnOrder"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"ReturnOrder"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"ReturnOrder"> | boolean
    syncAttempts?: IntWithAggregatesFilter<"ReturnOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReturnOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReturnOrder"> | Date | string
  }

  export type ReturnOrderLineWhereInput = {
    AND?: ReturnOrderLineWhereInput | ReturnOrderLineWhereInput[]
    OR?: ReturnOrderLineWhereInput[]
    NOT?: ReturnOrderLineWhereInput | ReturnOrderLineWhereInput[]
    id?: StringFilter<"ReturnOrderLine"> | string
    returnOrderId?: StringFilter<"ReturnOrderLine"> | string
    variantId?: StringFilter<"ReturnOrderLine"> | string
    originalLineId?: StringNullableFilter<"ReturnOrderLine"> | string | null
    quantity?: IntFilter<"ReturnOrderLine"> | number
    unitPrice?: FloatFilter<"ReturnOrderLine"> | number
    lineTotal?: FloatFilter<"ReturnOrderLine"> | number
    reason?: StringNullableFilter<"ReturnOrderLine"> | string | null
    createdAt?: DateTimeFilter<"ReturnOrderLine"> | Date | string
    returnOrder?: XOR<ReturnOrderScalarRelationFilter, ReturnOrderWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }

  export type ReturnOrderLineOrderByWithRelationInput = {
    id?: SortOrder
    returnOrderId?: SortOrder
    variantId?: SortOrder
    originalLineId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    returnOrder?: ReturnOrderOrderByWithRelationInput
    variant?: ProductVariantOrderByWithRelationInput
  }

  export type ReturnOrderLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReturnOrderLineWhereInput | ReturnOrderLineWhereInput[]
    OR?: ReturnOrderLineWhereInput[]
    NOT?: ReturnOrderLineWhereInput | ReturnOrderLineWhereInput[]
    returnOrderId?: StringFilter<"ReturnOrderLine"> | string
    variantId?: StringFilter<"ReturnOrderLine"> | string
    originalLineId?: StringNullableFilter<"ReturnOrderLine"> | string | null
    quantity?: IntFilter<"ReturnOrderLine"> | number
    unitPrice?: FloatFilter<"ReturnOrderLine"> | number
    lineTotal?: FloatFilter<"ReturnOrderLine"> | number
    reason?: StringNullableFilter<"ReturnOrderLine"> | string | null
    createdAt?: DateTimeFilter<"ReturnOrderLine"> | Date | string
    returnOrder?: XOR<ReturnOrderScalarRelationFilter, ReturnOrderWhereInput>
    variant?: XOR<ProductVariantScalarRelationFilter, ProductVariantWhereInput>
  }, "id">

  export type ReturnOrderLineOrderByWithAggregationInput = {
    id?: SortOrder
    returnOrderId?: SortOrder
    variantId?: SortOrder
    originalLineId?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReturnOrderLineCountOrderByAggregateInput
    _avg?: ReturnOrderLineAvgOrderByAggregateInput
    _max?: ReturnOrderLineMaxOrderByAggregateInput
    _min?: ReturnOrderLineMinOrderByAggregateInput
    _sum?: ReturnOrderLineSumOrderByAggregateInput
  }

  export type ReturnOrderLineScalarWhereWithAggregatesInput = {
    AND?: ReturnOrderLineScalarWhereWithAggregatesInput | ReturnOrderLineScalarWhereWithAggregatesInput[]
    OR?: ReturnOrderLineScalarWhereWithAggregatesInput[]
    NOT?: ReturnOrderLineScalarWhereWithAggregatesInput | ReturnOrderLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReturnOrderLine"> | string
    returnOrderId?: StringWithAggregatesFilter<"ReturnOrderLine"> | string
    variantId?: StringWithAggregatesFilter<"ReturnOrderLine"> | string
    originalLineId?: StringNullableWithAggregatesFilter<"ReturnOrderLine"> | string | null
    quantity?: IntWithAggregatesFilter<"ReturnOrderLine"> | number
    unitPrice?: FloatWithAggregatesFilter<"ReturnOrderLine"> | number
    lineTotal?: FloatWithAggregatesFilter<"ReturnOrderLine"> | number
    reason?: StringNullableWithAggregatesFilter<"ReturnOrderLine"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReturnOrderLine"> | Date | string
  }

  export type ExchangeOrderWhereInput = {
    AND?: ExchangeOrderWhereInput | ExchangeOrderWhereInput[]
    OR?: ExchangeOrderWhereInput[]
    NOT?: ExchangeOrderWhereInput | ExchangeOrderWhereInput[]
    id?: StringFilter<"ExchangeOrder"> | string
    exchangeNumber?: StringFilter<"ExchangeOrder"> | string
    originalOrderId?: StringFilter<"ExchangeOrder"> | string
    newOrderId?: StringFilter<"ExchangeOrder"> | string
    priceDifference?: FloatFilter<"ExchangeOrder"> | number
    additionalPayment?: FloatFilter<"ExchangeOrder"> | number
    refundAmount?: FloatFilter<"ExchangeOrder"> | number
    processedBy?: StringNullableFilter<"ExchangeOrder"> | string | null
    processedAt?: DateTimeFilter<"ExchangeOrder"> | Date | string
    syncVersion?: IntFilter<"ExchangeOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ExchangeOrder"> | Date | string | null
    isDirty?: BoolFilter<"ExchangeOrder"> | boolean
    originalOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    newOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }

  export type ExchangeOrderOrderByWithRelationInput = {
    id?: SortOrder
    exchangeNumber?: SortOrder
    originalOrderId?: SortOrder
    newOrderId?: SortOrder
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    originalOrder?: SaleOrderOrderByWithRelationInput
    newOrder?: SaleOrderOrderByWithRelationInput
  }

  export type ExchangeOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    exchangeNumber?: string
    AND?: ExchangeOrderWhereInput | ExchangeOrderWhereInput[]
    OR?: ExchangeOrderWhereInput[]
    NOT?: ExchangeOrderWhereInput | ExchangeOrderWhereInput[]
    originalOrderId?: StringFilter<"ExchangeOrder"> | string
    newOrderId?: StringFilter<"ExchangeOrder"> | string
    priceDifference?: FloatFilter<"ExchangeOrder"> | number
    additionalPayment?: FloatFilter<"ExchangeOrder"> | number
    refundAmount?: FloatFilter<"ExchangeOrder"> | number
    processedBy?: StringNullableFilter<"ExchangeOrder"> | string | null
    processedAt?: DateTimeFilter<"ExchangeOrder"> | Date | string
    syncVersion?: IntFilter<"ExchangeOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ExchangeOrder"> | Date | string | null
    isDirty?: BoolFilter<"ExchangeOrder"> | boolean
    originalOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
    newOrder?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }, "id" | "exchangeNumber">

  export type ExchangeOrderOrderByWithAggregationInput = {
    id?: SortOrder
    exchangeNumber?: SortOrder
    originalOrderId?: SortOrder
    newOrderId?: SortOrder
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    _count?: ExchangeOrderCountOrderByAggregateInput
    _avg?: ExchangeOrderAvgOrderByAggregateInput
    _max?: ExchangeOrderMaxOrderByAggregateInput
    _min?: ExchangeOrderMinOrderByAggregateInput
    _sum?: ExchangeOrderSumOrderByAggregateInput
  }

  export type ExchangeOrderScalarWhereWithAggregatesInput = {
    AND?: ExchangeOrderScalarWhereWithAggregatesInput | ExchangeOrderScalarWhereWithAggregatesInput[]
    OR?: ExchangeOrderScalarWhereWithAggregatesInput[]
    NOT?: ExchangeOrderScalarWhereWithAggregatesInput | ExchangeOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExchangeOrder"> | string
    exchangeNumber?: StringWithAggregatesFilter<"ExchangeOrder"> | string
    originalOrderId?: StringWithAggregatesFilter<"ExchangeOrder"> | string
    newOrderId?: StringWithAggregatesFilter<"ExchangeOrder"> | string
    priceDifference?: FloatWithAggregatesFilter<"ExchangeOrder"> | number
    additionalPayment?: FloatWithAggregatesFilter<"ExchangeOrder"> | number
    refundAmount?: FloatWithAggregatesFilter<"ExchangeOrder"> | number
    processedBy?: StringNullableWithAggregatesFilter<"ExchangeOrder"> | string | null
    processedAt?: DateTimeWithAggregatesFilter<"ExchangeOrder"> | Date | string
    syncVersion?: IntWithAggregatesFilter<"ExchangeOrder"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"ExchangeOrder"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"ExchangeOrder"> | boolean
  }

  export type ParkedOrderWhereInput = {
    AND?: ParkedOrderWhereInput | ParkedOrderWhereInput[]
    OR?: ParkedOrderWhereInput[]
    NOT?: ParkedOrderWhereInput | ParkedOrderWhereInput[]
    id?: StringFilter<"ParkedOrder"> | string
    parkNumber?: StringFilter<"ParkedOrder"> | string
    orderId?: StringFilter<"ParkedOrder"> | string
    customerId?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedBy?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedAt?: DateTimeFilter<"ParkedOrder"> | Date | string
    expiryDate?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    notes?: StringNullableFilter<"ParkedOrder"> | string | null
    syncVersion?: IntFilter<"ParkedOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    isDirty?: BoolFilter<"ParkedOrder"> | boolean
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }

  export type ParkedOrderOrderByWithRelationInput = {
    id?: SortOrder
    parkNumber?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    parkedBy?: SortOrderInput | SortOrder
    parkedAt?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    order?: SaleOrderOrderByWithRelationInput
  }

  export type ParkedOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    parkNumber?: string
    AND?: ParkedOrderWhereInput | ParkedOrderWhereInput[]
    OR?: ParkedOrderWhereInput[]
    NOT?: ParkedOrderWhereInput | ParkedOrderWhereInput[]
    orderId?: StringFilter<"ParkedOrder"> | string
    customerId?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedBy?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedAt?: DateTimeFilter<"ParkedOrder"> | Date | string
    expiryDate?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    notes?: StringNullableFilter<"ParkedOrder"> | string | null
    syncVersion?: IntFilter<"ParkedOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    isDirty?: BoolFilter<"ParkedOrder"> | boolean
    order?: XOR<SaleOrderScalarRelationFilter, SaleOrderWhereInput>
  }, "id" | "parkNumber">

  export type ParkedOrderOrderByWithAggregationInput = {
    id?: SortOrder
    parkNumber?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrderInput | SortOrder
    parkedBy?: SortOrderInput | SortOrder
    parkedAt?: SortOrder
    expiryDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    _count?: ParkedOrderCountOrderByAggregateInput
    _avg?: ParkedOrderAvgOrderByAggregateInput
    _max?: ParkedOrderMaxOrderByAggregateInput
    _min?: ParkedOrderMinOrderByAggregateInput
    _sum?: ParkedOrderSumOrderByAggregateInput
  }

  export type ParkedOrderScalarWhereWithAggregatesInput = {
    AND?: ParkedOrderScalarWhereWithAggregatesInput | ParkedOrderScalarWhereWithAggregatesInput[]
    OR?: ParkedOrderScalarWhereWithAggregatesInput[]
    NOT?: ParkedOrderScalarWhereWithAggregatesInput | ParkedOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParkedOrder"> | string
    parkNumber?: StringWithAggregatesFilter<"ParkedOrder"> | string
    orderId?: StringWithAggregatesFilter<"ParkedOrder"> | string
    customerId?: StringNullableWithAggregatesFilter<"ParkedOrder"> | string | null
    parkedBy?: StringNullableWithAggregatesFilter<"ParkedOrder"> | string | null
    parkedAt?: DateTimeWithAggregatesFilter<"ParkedOrder"> | Date | string
    expiryDate?: DateTimeNullableWithAggregatesFilter<"ParkedOrder"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ParkedOrder"> | string | null
    syncVersion?: IntWithAggregatesFilter<"ParkedOrder"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"ParkedOrder"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"ParkedOrder"> | boolean
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    locationId?: StringFilter<"Shift"> | string
    terminalId?: StringNullableFilter<"Shift"> | string | null
    userId?: StringFilter<"Shift"> | string
    shiftNumber?: StringFilter<"Shift"> | string
    registerId?: StringNullableFilter<"Shift"> | string | null
    openingCash?: FloatFilter<"Shift"> | number
    closingCash?: FloatNullableFilter<"Shift"> | number | null
    expectedCash?: FloatNullableFilter<"Shift"> | number | null
    cashDifference?: FloatNullableFilter<"Shift"> | number | null
    totalSales?: FloatFilter<"Shift"> | number
    totalRefunds?: FloatFilter<"Shift"> | number
    totalTransactions?: IntFilter<"Shift"> | number
    openedAt?: DateTimeFilter<"Shift"> | Date | string
    closedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    status?: EnumShiftStatusFilter<"Shift"> | $Enums.ShiftStatus
    notes?: StringNullableFilter<"Shift"> | string | null
    syncVersion?: IntFilter<"Shift"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isDirty?: BoolFilter<"Shift"> | boolean
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    terminal?: XOR<TerminalNullableScalarRelationFilter, TerminalWhereInput> | null
    user?: XOR<LocalUserScalarRelationFilter, LocalUserWhereInput>
    saleOrders?: SaleOrderListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    shiftNumber?: SortOrder
    registerId?: SortOrderInput | SortOrder
    openingCash?: SortOrder
    closingCash?: SortOrderInput | SortOrder
    expectedCash?: SortOrderInput | SortOrder
    cashDifference?: SortOrderInput | SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    location?: LocationOrderByWithRelationInput
    terminal?: TerminalOrderByWithRelationInput
    user?: LocalUserOrderByWithRelationInput
    saleOrders?: SaleOrderOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shiftNumber?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    locationId?: StringFilter<"Shift"> | string
    terminalId?: StringNullableFilter<"Shift"> | string | null
    userId?: StringFilter<"Shift"> | string
    registerId?: StringNullableFilter<"Shift"> | string | null
    openingCash?: FloatFilter<"Shift"> | number
    closingCash?: FloatNullableFilter<"Shift"> | number | null
    expectedCash?: FloatNullableFilter<"Shift"> | number | null
    cashDifference?: FloatNullableFilter<"Shift"> | number | null
    totalSales?: FloatFilter<"Shift"> | number
    totalRefunds?: FloatFilter<"Shift"> | number
    totalTransactions?: IntFilter<"Shift"> | number
    openedAt?: DateTimeFilter<"Shift"> | Date | string
    closedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    status?: EnumShiftStatusFilter<"Shift"> | $Enums.ShiftStatus
    notes?: StringNullableFilter<"Shift"> | string | null
    syncVersion?: IntFilter<"Shift"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isDirty?: BoolFilter<"Shift"> | boolean
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    terminal?: XOR<TerminalNullableScalarRelationFilter, TerminalWhereInput> | null
    user?: XOR<LocalUserScalarRelationFilter, LocalUserWhereInput>
    saleOrders?: SaleOrderListRelationFilter
  }, "id" | "shiftNumber">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    userId?: SortOrder
    shiftNumber?: SortOrder
    registerId?: SortOrderInput | SortOrder
    openingCash?: SortOrder
    closingCash?: SortOrderInput | SortOrder
    expectedCash?: SortOrderInput | SortOrder
    cashDifference?: SortOrderInput | SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    locationId?: StringWithAggregatesFilter<"Shift"> | string
    terminalId?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    userId?: StringWithAggregatesFilter<"Shift"> | string
    shiftNumber?: StringWithAggregatesFilter<"Shift"> | string
    registerId?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    openingCash?: FloatWithAggregatesFilter<"Shift"> | number
    closingCash?: FloatNullableWithAggregatesFilter<"Shift"> | number | null
    expectedCash?: FloatNullableWithAggregatesFilter<"Shift"> | number | null
    cashDifference?: FloatNullableWithAggregatesFilter<"Shift"> | number | null
    totalSales?: FloatWithAggregatesFilter<"Shift"> | number
    totalRefunds?: FloatWithAggregatesFilter<"Shift"> | number
    totalTransactions?: IntWithAggregatesFilter<"Shift"> | number
    openedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Shift"> | Date | string | null
    status?: EnumShiftStatusWithAggregatesFilter<"Shift"> | $Enums.ShiftStatus
    notes?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    syncVersion?: IntWithAggregatesFilter<"Shift"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Shift"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"Shift"> | boolean
  }

  export type TaxCategoryWhereInput = {
    AND?: TaxCategoryWhereInput | TaxCategoryWhereInput[]
    OR?: TaxCategoryWhereInput[]
    NOT?: TaxCategoryWhereInput | TaxCategoryWhereInput[]
    id?: StringFilter<"TaxCategory"> | string
    code?: StringFilter<"TaxCategory"> | string
    name?: StringFilter<"TaxCategory"> | string
    description?: StringNullableFilter<"TaxCategory"> | string | null
    syncVersion?: IntFilter<"TaxCategory"> | number
    lastSyncedAt?: DateTimeNullableFilter<"TaxCategory"> | Date | string | null
    isDirty?: BoolFilter<"TaxCategory"> | boolean
    isActive?: BoolFilter<"TaxCategory"> | boolean
    createdAt?: DateTimeFilter<"TaxCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCategory"> | Date | string
    products?: ProductListRelationFilter
    rates?: TaxRateListRelationFilter
  }

  export type TaxCategoryOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductOrderByRelationAggregateInput
    rates?: TaxRateOrderByRelationAggregateInput
  }

  export type TaxCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TaxCategoryWhereInput | TaxCategoryWhereInput[]
    OR?: TaxCategoryWhereInput[]
    NOT?: TaxCategoryWhereInput | TaxCategoryWhereInput[]
    name?: StringFilter<"TaxCategory"> | string
    description?: StringNullableFilter<"TaxCategory"> | string | null
    syncVersion?: IntFilter<"TaxCategory"> | number
    lastSyncedAt?: DateTimeNullableFilter<"TaxCategory"> | Date | string | null
    isDirty?: BoolFilter<"TaxCategory"> | boolean
    isActive?: BoolFilter<"TaxCategory"> | boolean
    createdAt?: DateTimeFilter<"TaxCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TaxCategory"> | Date | string
    products?: ProductListRelationFilter
    rates?: TaxRateListRelationFilter
  }, "id" | "code">

  export type TaxCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxCategoryCountOrderByAggregateInput
    _avg?: TaxCategoryAvgOrderByAggregateInput
    _max?: TaxCategoryMaxOrderByAggregateInput
    _min?: TaxCategoryMinOrderByAggregateInput
    _sum?: TaxCategorySumOrderByAggregateInput
  }

  export type TaxCategoryScalarWhereWithAggregatesInput = {
    AND?: TaxCategoryScalarWhereWithAggregatesInput | TaxCategoryScalarWhereWithAggregatesInput[]
    OR?: TaxCategoryScalarWhereWithAggregatesInput[]
    NOT?: TaxCategoryScalarWhereWithAggregatesInput | TaxCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxCategory"> | string
    code?: StringWithAggregatesFilter<"TaxCategory"> | string
    name?: StringWithAggregatesFilter<"TaxCategory"> | string
    description?: StringNullableWithAggregatesFilter<"TaxCategory"> | string | null
    syncVersion?: IntWithAggregatesFilter<"TaxCategory"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"TaxCategory"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"TaxCategory"> | boolean
    isActive?: BoolWithAggregatesFilter<"TaxCategory"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaxCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxCategory"> | Date | string
  }

  export type TaxRateWhereInput = {
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    id?: StringFilter<"TaxRate"> | string
    taxCategoryId?: StringFilter<"TaxRate"> | string
    name?: StringFilter<"TaxRate"> | string
    rate?: FloatFilter<"TaxRate"> | number
    country?: StringNullableFilter<"TaxRate"> | string | null
    state?: StringNullableFilter<"TaxRate"> | string | null
    city?: StringNullableFilter<"TaxRate"> | string | null
    isActive?: BoolFilter<"TaxRate"> | boolean
    effectiveFrom?: DateTimeFilter<"TaxRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    syncVersion?: IntFilter<"TaxRate"> | number
    lastSyncedAt?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    isDirty?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
    taxCategory?: XOR<TaxCategoryScalarRelationFilter, TaxCategoryWhereInput>
  }

  export type TaxRateOrderByWithRelationInput = {
    id?: SortOrder
    taxCategoryId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    taxCategory?: TaxCategoryOrderByWithRelationInput
  }

  export type TaxRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxRateWhereInput | TaxRateWhereInput[]
    OR?: TaxRateWhereInput[]
    NOT?: TaxRateWhereInput | TaxRateWhereInput[]
    taxCategoryId?: StringFilter<"TaxRate"> | string
    name?: StringFilter<"TaxRate"> | string
    rate?: FloatFilter<"TaxRate"> | number
    country?: StringNullableFilter<"TaxRate"> | string | null
    state?: StringNullableFilter<"TaxRate"> | string | null
    city?: StringNullableFilter<"TaxRate"> | string | null
    isActive?: BoolFilter<"TaxRate"> | boolean
    effectiveFrom?: DateTimeFilter<"TaxRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    syncVersion?: IntFilter<"TaxRate"> | number
    lastSyncedAt?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    isDirty?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
    taxCategory?: XOR<TaxCategoryScalarRelationFilter, TaxCategoryWhereInput>
  }, "id">

  export type TaxRateOrderByWithAggregationInput = {
    id?: SortOrder
    taxCategoryId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    country?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaxRateCountOrderByAggregateInput
    _avg?: TaxRateAvgOrderByAggregateInput
    _max?: TaxRateMaxOrderByAggregateInput
    _min?: TaxRateMinOrderByAggregateInput
    _sum?: TaxRateSumOrderByAggregateInput
  }

  export type TaxRateScalarWhereWithAggregatesInput = {
    AND?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    OR?: TaxRateScalarWhereWithAggregatesInput[]
    NOT?: TaxRateScalarWhereWithAggregatesInput | TaxRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxRate"> | string
    taxCategoryId?: StringWithAggregatesFilter<"TaxRate"> | string
    name?: StringWithAggregatesFilter<"TaxRate"> | string
    rate?: FloatWithAggregatesFilter<"TaxRate"> | number
    country?: StringNullableWithAggregatesFilter<"TaxRate"> | string | null
    state?: StringNullableWithAggregatesFilter<"TaxRate"> | string | null
    city?: StringNullableWithAggregatesFilter<"TaxRate"> | string | null
    isActive?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    effectiveFrom?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"TaxRate"> | Date | string | null
    syncVersion?: IntWithAggregatesFilter<"TaxRate"> | number
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"TaxRate"> | Date | string | null
    isDirty?: BoolWithAggregatesFilter<"TaxRate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TaxRate"> | Date | string
  }

  export type LocalSettingsWhereInput = {
    AND?: LocalSettingsWhereInput | LocalSettingsWhereInput[]
    OR?: LocalSettingsWhereInput[]
    NOT?: LocalSettingsWhereInput | LocalSettingsWhereInput[]
    id?: StringFilter<"LocalSettings"> | string
    key?: StringFilter<"LocalSettings"> | string
    value?: StringFilter<"LocalSettings"> | string
    category?: StringFilter<"LocalSettings"> | string
    description?: StringNullableFilter<"LocalSettings"> | string | null
    createdAt?: DateTimeFilter<"LocalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"LocalSettings"> | Date | string
  }

  export type LocalSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: LocalSettingsWhereInput | LocalSettingsWhereInput[]
    OR?: LocalSettingsWhereInput[]
    NOT?: LocalSettingsWhereInput | LocalSettingsWhereInput[]
    value?: StringFilter<"LocalSettings"> | string
    category?: StringFilter<"LocalSettings"> | string
    description?: StringNullableFilter<"LocalSettings"> | string | null
    createdAt?: DateTimeFilter<"LocalSettings"> | Date | string
    updatedAt?: DateTimeFilter<"LocalSettings"> | Date | string
  }, "id" | "key">

  export type LocalSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocalSettingsCountOrderByAggregateInput
    _max?: LocalSettingsMaxOrderByAggregateInput
    _min?: LocalSettingsMinOrderByAggregateInput
  }

  export type LocalSettingsScalarWhereWithAggregatesInput = {
    AND?: LocalSettingsScalarWhereWithAggregatesInput | LocalSettingsScalarWhereWithAggregatesInput[]
    OR?: LocalSettingsScalarWhereWithAggregatesInput[]
    NOT?: LocalSettingsScalarWhereWithAggregatesInput | LocalSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocalSettings"> | string
    key?: StringWithAggregatesFilter<"LocalSettings"> | string
    value?: StringWithAggregatesFilter<"LocalSettings"> | string
    category?: StringWithAggregatesFilter<"LocalSettings"> | string
    description?: StringNullableWithAggregatesFilter<"LocalSettings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LocalSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LocalSettings"> | Date | string
  }

  export type CacheWhereInput = {
    AND?: CacheWhereInput | CacheWhereInput[]
    OR?: CacheWhereInput[]
    NOT?: CacheWhereInput | CacheWhereInput[]
    id?: StringFilter<"Cache"> | string
    key?: StringFilter<"Cache"> | string
    value?: JsonFilter<"Cache">
    expiresAt?: DateTimeNullableFilter<"Cache"> | Date | string | null
    lastAccessed?: DateTimeFilter<"Cache"> | Date | string
    createdAt?: DateTimeFilter<"Cache"> | Date | string
    updatedAt?: DateTimeFilter<"Cache"> | Date | string
  }

  export type CacheOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: CacheWhereInput | CacheWhereInput[]
    OR?: CacheWhereInput[]
    NOT?: CacheWhereInput | CacheWhereInput[]
    value?: JsonFilter<"Cache">
    expiresAt?: DateTimeNullableFilter<"Cache"> | Date | string | null
    lastAccessed?: DateTimeFilter<"Cache"> | Date | string
    createdAt?: DateTimeFilter<"Cache"> | Date | string
    updatedAt?: DateTimeFilter<"Cache"> | Date | string
  }, "id" | "key">

  export type CacheOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CacheCountOrderByAggregateInput
    _max?: CacheMaxOrderByAggregateInput
    _min?: CacheMinOrderByAggregateInput
  }

  export type CacheScalarWhereWithAggregatesInput = {
    AND?: CacheScalarWhereWithAggregatesInput | CacheScalarWhereWithAggregatesInput[]
    OR?: CacheScalarWhereWithAggregatesInput[]
    NOT?: CacheScalarWhereWithAggregatesInput | CacheScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cache"> | string
    key?: StringWithAggregatesFilter<"Cache"> | string
    value?: JsonWithAggregatesFilter<"Cache">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Cache"> | Date | string | null
    lastAccessed?: DateTimeWithAggregatesFilter<"Cache"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Cache"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cache"> | Date | string
  }

  export type TerminalCreateInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateManyInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TerminalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalSessionCreateInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
    terminal: TerminalCreateNestedOneWithoutSessionsInput
  }

  export type TerminalSessionUncheckedCreateInput = {
    id?: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
  }

  export type TerminalSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminal?: TerminalUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type TerminalSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TerminalSessionCreateManyInput = {
    id?: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
  }

  export type TerminalSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TerminalSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OperationModeCreateInput = {
    id?: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
    terminal: TerminalCreateNestedOneWithoutOperationModesInput
  }

  export type OperationModeUncheckedCreateInput = {
    id?: string
    terminalId: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
  }

  export type OperationModeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminal?: TerminalUpdateOneRequiredWithoutOperationModesNestedInput
  }

  export type OperationModeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationModeCreateManyInput = {
    id?: string
    terminalId: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
  }

  export type OperationModeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationModeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionLogCreateInput = {
    id?: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
    terminal: TerminalCreateNestedOneWithoutConnectionLogsInput
  }

  export type ConnectionLogUncheckedCreateInput = {
    id?: string
    terminalId: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
  }

  export type ConnectionLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
    terminal?: TerminalUpdateOneRequiredWithoutConnectionLogsNestedInput
  }

  export type ConnectionLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionLogCreateManyInput = {
    id?: string
    terminalId: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
  }

  export type ConnectionLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocalUserCreateInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    saleOrders?: SaleOrderCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type LocalUserUncheckedCreateInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type LocalUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type LocalUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LocalUserCreateManyInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    user: LocalUserCreateNestedOneWithoutSessionsInput
    terminal: TerminalCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: LocalUserUpdateOneRequiredWithoutSessionsNestedInput
    terminal?: TerminalUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OutboxCreateInput = {
    id?: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
    terminal: TerminalCreateNestedOneWithoutOutboxesInput
  }

  export type OutboxUncheckedCreateInput = {
    id?: string
    terminalId: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
  }

  export type OutboxUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    terminal?: TerminalUpdateOneRequiredWithoutOutboxesNestedInput
  }

  export type OutboxUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type OutboxCreateManyInput = {
    id?: string
    terminalId: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
  }

  export type OutboxUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type OutboxUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type SyncHistoryCreateInput = {
    id?: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
    terminal: TerminalCreateNestedOneWithoutSyncHistoriesInput
  }

  export type SyncHistoryUncheckedCreateInput = {
    id?: string
    terminalId: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
  }

  export type SyncHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    terminal?: TerminalUpdateOneRequiredWithoutSyncHistoriesNestedInput
  }

  export type SyncHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryCreateManyInput = {
    id?: string
    terminalId: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
  }

  export type SyncHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StoreCreateInput = {
    id: string
    storeCode: string
    storeName: string
    legalName?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    timezone?: string
    defaultCurrency?: string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUncheckedCreateInput = {
    id: string
    storeCode: string
    storeName: string
    legalName?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    timezone?: string
    defaultCurrency?: string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeCode?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeCode?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreCreateManyInput = {
    id: string
    storeCode: string
    storeName: string
    legalName?: string | null
    email?: string | null
    phone?: string | null
    addressLine1?: string | null
    city?: string | null
    state?: string | null
    zipCode?: string | null
    timezone?: string
    defaultCurrency?: string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeCode?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    storeCode?: StringFieldUpdateOperationsInput | string
    storeName?: StringFieldUpdateOperationsInput | string
    legalName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    defaultCurrency?: StringFieldUpdateOperationsInput | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    taxCategory?: TaxCategoryCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    brandId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    taxCategory?: TaxCategoryUpdateOneWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    brandId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantCreateManyInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    parentId?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    parentId?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    logoUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    logoUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    logoUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: CustomerGroupCreateNestedOneWithoutCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    groupId?: string | null
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CustomerGroupUpdateOneWithoutCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    groupId?: string | null
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    discountPercent?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerCreateNestedManyWithoutGroupInput
  }

  export type CustomerGroupUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    discountPercent?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: CustomerUncheckedCreateNestedManyWithoutGroupInput
  }

  export type CustomerGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUpdateManyWithoutGroupNestedInput
  }

  export type CustomerGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: CustomerUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type CustomerGroupCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    discountPercent?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateInput = {
    id?: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: CustomerCreateNestedOneWithoutAddressesInput
  }

  export type CustomerAddressUncheckedCreateInput = {
    id?: string
    customerId: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type CustomerAddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyInput = {
    id?: string
    customerId: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutInventoryItemsInput
    location: LocationCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id: string
    variantId: string
    locationId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutInventoryItemsNestedInput
    location?: LocationUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyInput = {
    id: string
    variantId: string
    locationId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAdjustmentCreateInput = {
    id?: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutStockAdjustmentsInput
    lineItems?: StockAdjustmentLineCreateNestedManyWithoutAdjustmentInput
  }

  export type StockAdjustmentUncheckedCreateInput = {
    id?: string
    locationId: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    lineItems?: StockAdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput
  }

  export type StockAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutStockAdjustmentsNestedInput
    lineItems?: StockAdjustmentLineUpdateManyWithoutAdjustmentNestedInput
  }

  export type StockAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockAdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput
  }

  export type StockAdjustmentCreateManyInput = {
    id?: string
    locationId: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type StockAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAdjustmentLineCreateInput = {
    id?: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
    adjustment: StockAdjustmentCreateNestedOneWithoutLineItemsInput
    variant: ProductVariantCreateNestedOneWithoutStockAdjustmentLinesInput
  }

  export type StockAdjustmentLineUncheckedCreateInput = {
    id?: string
    adjustmentId: string
    variantId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockAdjustmentLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
    adjustment?: StockAdjustmentUpdateOneRequiredWithoutLineItemsNestedInput
    variant?: ProductVariantUpdateOneRequiredWithoutStockAdjustmentLinesNestedInput
  }

  export type StockAdjustmentLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockAdjustmentLineCreateManyInput = {
    id?: string
    adjustmentId: string
    variantId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockAdjustmentLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockAdjustmentLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockTransferCreateInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromLocation: LocationCreateNestedOneWithoutStockTransfersFromInput
    toLocation: LocationCreateNestedOneWithoutStockTransfersToInput
    lineItems?: StockTransferLineCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateInput = {
    id?: string
    fromLocationId: string
    toLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: StockTransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromLocation?: LocationUpdateOneRequiredWithoutStockTransfersFromNestedInput
    toLocation?: LocationUpdateOneRequiredWithoutStockTransfersToNestedInput
    lineItems?: StockTransferLineUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromLocationId?: StringFieldUpdateOperationsInput | string
    toLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockTransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferCreateManyInput = {
    id?: string
    fromLocationId: string
    toLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromLocationId?: StringFieldUpdateOperationsInput | string
    toLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferLineCreateInput = {
    id?: string
    quantity: number
    received?: number | null
    transfer: StockTransferCreateNestedOneWithoutLineItemsInput
    variant: ProductVariantCreateNestedOneWithoutStockTransferLinesInput
  }

  export type StockTransferLineUncheckedCreateInput = {
    id?: string
    transferId: string
    variantId: string
    quantity: number
    received?: number | null
  }

  export type StockTransferLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
    transfer?: StockTransferUpdateOneRequiredWithoutLineItemsNestedInput
    variant?: ProductVariantUpdateOneRequiredWithoutStockTransferLinesNestedInput
  }

  export type StockTransferLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockTransferLineCreateManyInput = {
    id?: string
    transferId: string
    variantId: string
    quantity: number
    received?: number | null
  }

  export type StockTransferLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockTransferLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SaleOrderCreateInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderCreateManyInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineCreateInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: SaleOrderCreateNestedOneWithoutLinesInput
    variant: ProductVariantCreateNestedOneWithoutSaleOrderLinesInput
  }

  export type SaleOrderLineUncheckedCreateInput = {
    id?: string
    orderId: string
    variantId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SaleOrderUpdateOneRequiredWithoutLinesNestedInput
    variant?: ProductVariantUpdateOneRequiredWithoutSaleOrderLinesNestedInput
  }

  export type SaleOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineCreateManyInput = {
    id?: string
    orderId: string
    variantId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    order: SaleOrderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    orderId: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SaleOrderUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    orderId: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id?: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    order: SaleOrderCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    orderId: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SaleOrderUpdateOneRequiredWithoutDiscountsNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateManyInput = {
    id?: string
    orderId: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderCreateInput = {
    id?: string
    returnNumber: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalOrder: SaleOrderCreateNestedOneWithoutReturnOrdersInput
    customer?: CustomerCreateNestedOneWithoutReturnOrdersInput
    location: LocationCreateNestedOneWithoutReturnOrdersInput
    lines?: ReturnOrderLineCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderUncheckedCreateInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    customerId?: string | null
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReturnOrderLineUncheckedCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOrder?: SaleOrderUpdateOneRequiredWithoutReturnOrdersNestedInput
    customer?: CustomerUpdateOneWithoutReturnOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutReturnOrdersNestedInput
    lines?: ReturnOrderLineUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderCreateManyInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    customerId?: string | null
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineCreateInput = {
    id?: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
    returnOrder: ReturnOrderCreateNestedOneWithoutLinesInput
    variant: ProductVariantCreateNestedOneWithoutReturnOrderLinesInput
  }

  export type ReturnOrderLineUncheckedCreateInput = {
    id?: string
    returnOrderId: string
    variantId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReturnOrderLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnOrder?: ReturnOrderUpdateOneRequiredWithoutLinesNestedInput
    variant?: ProductVariantUpdateOneRequiredWithoutReturnOrderLinesNestedInput
  }

  export type ReturnOrderLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnOrderId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineCreateManyInput = {
    id?: string
    returnOrderId: string
    variantId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReturnOrderLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnOrderId?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeOrderCreateInput = {
    id?: string
    exchangeNumber: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    originalOrder: SaleOrderCreateNestedOneWithoutExchangesFromInput
    newOrder: SaleOrderCreateNestedOneWithoutExchangesToInput
  }

  export type ExchangeOrderUncheckedCreateInput = {
    id?: string
    exchangeNumber: string
    originalOrderId: string
    newOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    originalOrder?: SaleOrderUpdateOneRequiredWithoutExchangesFromNestedInput
    newOrder?: SaleOrderUpdateOneRequiredWithoutExchangesToNestedInput
  }

  export type ExchangeOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    newOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderCreateManyInput = {
    id?: string
    exchangeNumber: string
    originalOrderId: string
    newOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    newOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkedOrderCreateInput = {
    id?: string
    parkNumber: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    order: SaleOrderCreateNestedOneWithoutParkedOrdersInput
  }

  export type ParkedOrderUncheckedCreateInput = {
    id?: string
    parkNumber: string
    orderId: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ParkedOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    order?: SaleOrderUpdateOneRequiredWithoutParkedOrdersNestedInput
  }

  export type ParkedOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkedOrderCreateManyInput = {
    id?: string
    parkNumber: string
    orderId: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ParkedOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkedOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftCreateInput = {
    id?: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    location: LocationCreateNestedOneWithoutShiftsInput
    terminal?: TerminalCreateNestedOneWithoutShiftsInput
    user: LocalUserCreateNestedOneWithoutShiftsInput
    saleOrders?: SaleOrderCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutShiftsNestedInput
    terminal?: TerminalUpdateOneWithoutShiftsNestedInput
    user?: LocalUserUpdateOneRequiredWithoutShiftsNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaxCategoryCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutTaxCategoryInput
    rates?: TaxRateCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryUncheckedCreateInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutTaxCategoryInput
    rates?: TaxRateUncheckedCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutTaxCategoryNestedInput
    rates?: TaxRateUpdateManyWithoutTaxCategoryNestedInput
  }

  export type TaxCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutTaxCategoryNestedInput
    rates?: TaxRateUncheckedUpdateManyWithoutTaxCategoryNestedInput
  }

  export type TaxCategoryCreateManyInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateInput = {
    id?: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    taxCategory: TaxCategoryCreateNestedOneWithoutRatesInput
  }

  export type TaxRateUncheckedCreateInput = {
    id?: string
    taxCategoryId: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    taxCategory?: TaxCategoryUpdateOneRequiredWithoutRatesNestedInput
  }

  export type TaxRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxCategoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateCreateManyInput = {
    id?: string
    taxCategoryId: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxCategoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalSettingsCreateInput = {
    id?: string
    key: string
    value: string
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalSettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalSettingsCreateManyInput = {
    id?: string
    key: string
    value: string
    category?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocalSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocalSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    lastAccessed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    lastAccessed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    lastAccessed?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAccessed?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TerminalSessionListRelationFilter = {
    every?: TerminalSessionWhereInput
    some?: TerminalSessionWhereInput
    none?: TerminalSessionWhereInput
  }

  export type OperationModeListRelationFilter = {
    every?: OperationModeWhereInput
    some?: OperationModeWhereInput
    none?: OperationModeWhereInput
  }

  export type ConnectionLogListRelationFilter = {
    every?: ConnectionLogWhereInput
    some?: ConnectionLogWhereInput
    none?: ConnectionLogWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type OutboxListRelationFilter = {
    every?: OutboxWhereInput
    some?: OutboxWhereInput
    none?: OutboxWhereInput
  }

  export type SyncHistoryListRelationFilter = {
    every?: SyncHistoryWhereInput
    some?: SyncHistoryWhereInput
    none?: SyncHistoryWhereInput
  }

  export type SaleOrderListRelationFilter = {
    every?: SaleOrderWhereInput
    some?: SaleOrderWhereInput
    none?: SaleOrderWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TerminalSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperationModeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConnectionLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OutboxOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SyncHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TerminalCountOrderByAggregateInput = {
    id?: SortOrder
    terminalCode?: SortOrder
    terminalName?: SortOrder
    macAddress?: SortOrder
    centralTerminalId?: SortOrder
    centralStoreId?: SortOrder
    centralBranchId?: SortOrder
    centralLocationId?: SortOrder
    apiKey?: SortOrder
    sessionToken?: SortOrder
    sessionExpiry?: SortOrder
    storeName?: SortOrder
    branchName?: SortOrder
    locationName?: SortOrder
    features?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    currentShiftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalCode?: SortOrder
    terminalName?: SortOrder
    macAddress?: SortOrder
    centralTerminalId?: SortOrder
    centralStoreId?: SortOrder
    centralBranchId?: SortOrder
    centralLocationId?: SortOrder
    apiKey?: SortOrder
    sessionToken?: SortOrder
    sessionExpiry?: SortOrder
    storeName?: SortOrder
    branchName?: SortOrder
    locationName?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    currentShiftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalMinOrderByAggregateInput = {
    id?: SortOrder
    terminalCode?: SortOrder
    terminalName?: SortOrder
    macAddress?: SortOrder
    centralTerminalId?: SortOrder
    centralStoreId?: SortOrder
    centralBranchId?: SortOrder
    centralLocationId?: SortOrder
    apiKey?: SortOrder
    sessionToken?: SortOrder
    sessionExpiry?: SortOrder
    storeName?: SortOrder
    branchName?: SortOrder
    locationName?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    currentShiftId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TerminalScalarRelationFilter = {
    is?: TerminalWhereInput
    isNot?: TerminalWhereInput
  }

  export type TerminalSessionCountOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
  }

  export type TerminalSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
  }

  export type TerminalSessionMinOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    ipAddress?: SortOrder
    isActive?: SortOrder
  }

  export type EnumOperationModeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationModeType | EnumOperationModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationModeType[]
    notIn?: $Enums.OperationModeType[]
    not?: NestedEnumOperationModeTypeFilter<$PrismaModel> | $Enums.OperationModeType
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OperationModeCountOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    currentMode?: SortOrder
    lastModeChange?: SortOrder
    lastOnlineCheck?: SortOrder
    centralBaseURL?: SortOrder
    syncEndpoint?: SortOrder
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
    offlineSince?: SortOrder
  }

  export type OperationModeAvgOrderByAggregateInput = {
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
  }

  export type OperationModeMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    currentMode?: SortOrder
    lastModeChange?: SortOrder
    lastOnlineCheck?: SortOrder
    centralBaseURL?: SortOrder
    syncEndpoint?: SortOrder
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
    offlineSince?: SortOrder
  }

  export type OperationModeMinOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    currentMode?: SortOrder
    lastModeChange?: SortOrder
    lastOnlineCheck?: SortOrder
    centralBaseURL?: SortOrder
    syncEndpoint?: SortOrder
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
    offlineSince?: SortOrder
  }

  export type OperationModeSumOrderByAggregateInput = {
    heartbeatInterval?: SortOrder
    maxOfflineHours?: SortOrder
  }

  export type EnumOperationModeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationModeType | EnumOperationModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationModeType[]
    notIn?: $Enums.OperationModeType[]
    not?: NestedEnumOperationModeTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperationModeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationModeTypeFilter<$PrismaModel>
    _max?: NestedEnumOperationModeTypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ConnectionLogCountOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    mode?: SortOrder
    timestamp?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    success?: SortOrder
  }

  export type ConnectionLogAvgOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type ConnectionLogMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    mode?: SortOrder
    timestamp?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    success?: SortOrder
  }

  export type ConnectionLogMinOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    mode?: SortOrder
    timestamp?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    success?: SortOrder
  }

  export type ConnectionLogSumOrderByAggregateInput = {
    durationMs?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type LocalUserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    pinCode?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    centralUserId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalUserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type LocalUserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    pinCode?: SortOrder
    role?: SortOrder
    centralUserId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalUserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    pinCode?: SortOrder
    role?: SortOrder
    centralUserId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalUserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type LocalUserScalarRelationFilter = {
    is?: LocalUserWhereInput
    isNot?: LocalUserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    terminalId?: SortOrder
    sessionToken?: SortOrder
    startedAt?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
  }

  export type EnumSyncOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationFilter<$PrismaModel> | $Enums.SyncOperation
  }

  export type OutboxCountOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    data?: SortOrder
    createdInMode?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    lastAttemptAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    localTimestamp?: SortOrder
    syncVersion?: SortOrder
  }

  export type OutboxAvgOrderByAggregateInput = {
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    syncVersion?: SortOrder
  }

  export type OutboxMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    createdInMode?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    lastAttemptAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    localTimestamp?: SortOrder
    syncVersion?: SortOrder
  }

  export type OutboxMinOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    operation?: SortOrder
    createdInMode?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    lastAttemptAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    localTimestamp?: SortOrder
    syncVersion?: SortOrder
  }

  export type OutboxSumOrderByAggregateInput = {
    syncPriority?: SortOrder
    attemptCount?: SortOrder
    maxAttempts?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumSyncOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel> | $Enums.SyncOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncOperationFilter<$PrismaModel>
    _max?: NestedEnumSyncOperationFilter<$PrismaModel>
  }

  export type EnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[]
    notIn?: $Enums.SyncType[]
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type EnumSyncDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncDirection | EnumSyncDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncDirection[]
    notIn?: $Enums.SyncDirection[]
    not?: NestedEnumSyncDirectionFilter<$PrismaModel> | $Enums.SyncDirection
  }

  export type SyncHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    syncType?: SortOrder
    direction?: SortOrder
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
  }

  export type SyncHistoryAvgOrderByAggregateInput = {
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    durationMs?: SortOrder
  }

  export type SyncHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    syncType?: SortOrder
    direction?: SortOrder
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
  }

  export type SyncHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    terminalId?: SortOrder
    syncType?: SortOrder
    direction?: SortOrder
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    durationMs?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
  }

  export type SyncHistorySumOrderByAggregateInput = {
    entitiesProcessed?: SortOrder
    successCount?: SortOrder
    failureCount?: SortOrder
    conflictsFound?: SortOrder
    durationMs?: SortOrder
  }

  export type EnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[]
    notIn?: $Enums.SyncType[]
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type EnumSyncDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncDirection | EnumSyncDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncDirection[]
    notIn?: $Enums.SyncDirection[]
    not?: NestedEnumSyncDirectionWithAggregatesFilter<$PrismaModel> | $Enums.SyncDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncDirectionFilter<$PrismaModel>
    _max?: NestedEnumSyncDirectionFilter<$PrismaModel>
  }

  export type StoreCountOrderByAggregateInput = {
    id?: SortOrder
    storeCode?: SortOrder
    storeName?: SortOrder
    legalName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    timezone?: SortOrder
    defaultCurrency?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type StoreMaxOrderByAggregateInput = {
    id?: SortOrder
    storeCode?: SortOrder
    storeName?: SortOrder
    legalName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    timezone?: SortOrder
    defaultCurrency?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreMinOrderByAggregateInput = {
    id?: SortOrder
    storeCode?: SortOrder
    storeName?: SortOrder
    legalName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    addressLine1?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    timezone?: SortOrder
    defaultCurrency?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StoreSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InventoryItemListRelationFilter = {
    every?: InventoryItemWhereInput
    some?: InventoryItemWhereInput
    none?: InventoryItemWhereInput
  }

  export type StockAdjustmentListRelationFilter = {
    every?: StockAdjustmentWhereInput
    some?: StockAdjustmentWhereInput
    none?: StockAdjustmentWhereInput
  }

  export type StockTransferListRelationFilter = {
    every?: StockTransferWhereInput
    some?: StockTransferWhereInput
    none?: StockTransferWhereInput
  }

  export type ReturnOrderListRelationFilter = {
    every?: ReturnOrderWhereInput
    some?: ReturnOrderWhereInput
    none?: ReturnOrderWhereInput
  }

  export type InventoryItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    centralLocationId?: SortOrder
    centralBranchId?: SortOrder
    timezone?: SortOrder
    taxRate?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    syncVersion?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    centralLocationId?: SortOrder
    centralBranchId?: SortOrder
    timezone?: SortOrder
    taxRate?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    type?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    centralLocationId?: SortOrder
    centralBranchId?: SortOrder
    timezone?: SortOrder
    taxRate?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationSumOrderByAggregateInput = {
    taxRate?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type TaxCategoryNullableScalarRelationFilter = {
    is?: TaxCategoryWhereInput | null
    isNot?: TaxCategoryWhereInput | null
  }

  export type ProductVariantListRelationFilter = {
    every?: ProductVariantWhereInput
    some?: ProductVariantWhereInput
    none?: ProductVariantWhereInput
  }

  export type ProductVariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    taxCategoryId?: SortOrder
    imageUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    taxCategoryId?: SortOrder
    imageUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    categoryId?: SortOrder
    brandId?: SortOrder
    taxCategoryId?: SortOrder
    imageUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SaleOrderLineListRelationFilter = {
    every?: SaleOrderLineWhereInput
    some?: SaleOrderLineWhereInput
    none?: SaleOrderLineWhereInput
  }

  export type ReturnOrderLineListRelationFilter = {
    every?: ReturnOrderLineWhereInput
    some?: ReturnOrderLineWhereInput
    none?: ReturnOrderLineWhereInput
  }

  export type StockAdjustmentLineListRelationFilter = {
    every?: StockAdjustmentLineWhereInput
    some?: StockAdjustmentLineWhereInput
    none?: StockAdjustmentLineWhereInput
  }

  export type StockTransferLineListRelationFilter = {
    every?: StockTransferLineWhereInput
    some?: StockTransferLineWhereInput
    none?: StockTransferLineWhereInput
  }

  export type SaleOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReturnOrderLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockAdjustmentLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StockTransferLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductVariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    trackInventory?: SortOrder
    barcode?: SortOrder
    upc?: SortOrder
    ean?: SortOrder
    color?: SortOrder
    size?: SortOrder
    material?: SortOrder
    style?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantAvgOrderByAggregateInput = {
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    weight?: SortOrder
    syncVersion?: SortOrder
  }

  export type ProductVariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    trackInventory?: SortOrder
    barcode?: SortOrder
    upc?: SortOrder
    ean?: SortOrder
    color?: SortOrder
    size?: SortOrder
    material?: SortOrder
    style?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    trackInventory?: SortOrder
    barcode?: SortOrder
    upc?: SortOrder
    ean?: SortOrder
    color?: SortOrder
    size?: SortOrder
    material?: SortOrder
    style?: SortOrder
    weight?: SortOrder
    weightUnit?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductVariantSumOrderByAggregateInput = {
    cost?: SortOrder
    price?: SortOrder
    compareAtPrice?: SortOrder
    weight?: SortOrder
    syncVersion?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CategoryListRelationFilter = {
    every?: CategoryWhereInput
    some?: CategoryWhereInput
    none?: CategoryWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type CategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    parentId?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    parentId?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    parentId?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type CustomerGroupNullableScalarRelationFilter = {
    is?: CustomerGroupWhereInput | null
    isNot?: CustomerGroupWhereInput | null
  }

  export type CustomerAddressListRelationFilter = {
    every?: CustomerAddressWhereInput
    some?: CustomerAddressWhereInput
    none?: CustomerAddressWhereInput
  }

  export type CustomerAddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    allowMarketing?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    syncVersion?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    allowMarketing?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    type?: SortOrder
    groupId?: SortOrder
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    allowMarketing?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    loyaltyPoints?: SortOrder
    totalSpent?: SortOrder
    totalOrders?: SortOrder
    creditLimit?: SortOrder
    currentBalance?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerGroupCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discountPercent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupAvgOrderByAggregateInput = {
    discountPercent?: SortOrder
    syncVersion?: SortOrder
  }

  export type CustomerGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discountPercent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    discountPercent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerGroupSumOrderByAggregateInput = {
    discountPercent?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[]
    notIn?: $Enums.AddressType[]
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type CustomerScalarRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type CustomerAddressCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAddressMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[]
    notIn?: $Enums.AddressType[]
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type ProductVariantScalarRelationFilter = {
    is?: ProductVariantWhereInput
    isNot?: ProductVariantWhereInput
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type InventoryItemVariantIdLocationIdCompoundUniqueInput = {
    variantId: string
    locationId: string
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    locationId?: SortOrder
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    lastCountedAt?: SortOrder
    lastReceivedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    pendingSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    syncVersion?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    locationId?: SortOrder
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    lastCountedAt?: SortOrder
    lastReceivedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    pendingSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    locationId?: SortOrder
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    lastCountedAt?: SortOrder
    lastReceivedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    pendingSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    quantityOnHand?: SortOrder
    quantityReserved?: SortOrder
    quantityAvailable?: SortOrder
    reorderPoint?: SortOrder
    reorderQuantity?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumStockAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockAdjustmentType | EnumStockAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockAdjustmentType[]
    notIn?: $Enums.StockAdjustmentType[]
    not?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel> | $Enums.StockAdjustmentType
  }

  export type StockAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    adjustmentType?: SortOrder
    reason?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    adjustedBy?: SortOrder
    adjustedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type StockAdjustmentAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type StockAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    adjustmentType?: SortOrder
    reason?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    adjustedBy?: SortOrder
    adjustedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type StockAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    adjustmentType?: SortOrder
    reason?: SortOrder
    referenceNumber?: SortOrder
    notes?: SortOrder
    adjustedBy?: SortOrder
    adjustedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type StockAdjustmentSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumStockAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockAdjustmentType | EnumStockAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockAdjustmentType[]
    notIn?: $Enums.StockAdjustmentType[]
    not?: NestedEnumStockAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel>
  }

  export type StockAdjustmentScalarRelationFilter = {
    is?: StockAdjustmentWhereInput
    isNot?: StockAdjustmentWhereInput
  }

  export type StockAdjustmentLineCountOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    variantId?: SortOrder
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
  }

  export type StockAdjustmentLineAvgOrderByAggregateInput = {
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
  }

  export type StockAdjustmentLineMaxOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    variantId?: SortOrder
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
  }

  export type StockAdjustmentLineMinOrderByAggregateInput = {
    id?: SortOrder
    adjustmentId?: SortOrder
    variantId?: SortOrder
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
  }

  export type StockAdjustmentLineSumOrderByAggregateInput = {
    quantityBefore?: SortOrder
    quantityAfter?: SortOrder
    quantityChange?: SortOrder
  }

  export type EnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type StockTransferCountOrderByAggregateInput = {
    id?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type StockTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferMinOrderByAggregateInput = {
    id?: SortOrder
    fromLocationId?: SortOrder
    toLocationId?: SortOrder
    transferNumber?: SortOrder
    status?: SortOrder
    transferDate?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StockTransferSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type StockTransferScalarRelationFilter = {
    is?: StockTransferWhereInput
    isNot?: StockTransferWhereInput
  }

  export type StockTransferLineCountOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    received?: SortOrder
  }

  export type StockTransferLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    received?: SortOrder
  }

  export type StockTransferLineMaxOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    received?: SortOrder
  }

  export type StockTransferLineMinOrderByAggregateInput = {
    id?: SortOrder
    transferId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    received?: SortOrder
  }

  export type StockTransferLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    received?: SortOrder
  }

  export type EnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumOrderSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[]
    notIn?: $Enums.OrderSource[]
    not?: NestedEnumOrderSourceFilter<$PrismaModel> | $Enums.OrderSource
  }

  export type TerminalNullableScalarRelationFilter = {
    is?: TerminalWhereInput | null
    isNot?: TerminalWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type ShiftNullableScalarRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type LocalUserNullableScalarRelationFilter = {
    is?: LocalUserWhereInput | null
    isNot?: LocalUserWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type ParkedOrderListRelationFilter = {
    every?: ParkedOrderWhereInput
    some?: ParkedOrderWhereInput
    none?: ParkedOrderWhereInput
  }

  export type ExchangeOrderListRelationFilter = {
    every?: ExchangeOrderWhereInput
    some?: ExchangeOrderWhereInput
    none?: ExchangeOrderWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParkedOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExchangeOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    customerId?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    completedAt?: SortOrder
    voidedAt?: SortOrder
    voidReason?: SortOrder
    receiptPrinted?: SortOrder
    receiptEmailed?: SortOrder
    receiptPrintedAt?: SortOrder
    receiptEmailedAt?: SortOrder
    receiptNumber?: SortOrder
    discountReason?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    syncVersion?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
  }

  export type SaleOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    customerId?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    completedAt?: SortOrder
    voidedAt?: SortOrder
    voidReason?: SortOrder
    receiptPrinted?: SortOrder
    receiptEmailed?: SortOrder
    receiptPrintedAt?: SortOrder
    receiptEmailedAt?: SortOrder
    receiptNumber?: SortOrder
    discountReason?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    orderNumber?: SortOrder
    type?: SortOrder
    status?: SortOrder
    source?: SortOrder
    customerId?: SortOrder
    shiftId?: SortOrder
    userId?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    completedAt?: SortOrder
    voidedAt?: SortOrder
    voidReason?: SortOrder
    receiptPrinted?: SortOrder
    receiptEmailed?: SortOrder
    receiptPrintedAt?: SortOrder
    receiptEmailedAt?: SortOrder
    receiptNumber?: SortOrder
    discountReason?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    total?: SortOrder
    syncVersion?: SortOrder
    syncPriority?: SortOrder
    syncAttempts?: SortOrder
  }

  export type EnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumOrderSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[]
    notIn?: $Enums.OrderSource[]
    not?: NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel> | $Enums.OrderSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSourceFilter<$PrismaModel>
    _max?: NestedEnumOrderSourceFilter<$PrismaModel>
  }

  export type SaleOrderScalarRelationFilter = {
    is?: SaleOrderWhereInput
    isNot?: SaleOrderWhereInput
  }

  export type SaleOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    syncVersion?: SortOrder
  }

  export type SaleOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    variantId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleOrderLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    discountAmount?: SortOrder
    taxAmount?: SortOrder
    lineTotal?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reference?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    syncVersion?: SortOrder
    syncPriority?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reference?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reference?: SortOrder
    cardLast4?: SortOrder
    cardBrand?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncPriority?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    syncVersion?: SortOrder
    syncPriority?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    percent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    amount?: SortOrder
    percent?: SortOrder
    syncVersion?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    percent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    code?: SortOrder
    amount?: SortOrder
    percent?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    amount?: SortOrder
    percent?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type EnumReturnReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReturnReason[] | null
    notIn?: $Enums.ReturnReason[] | null
    not?: NestedEnumReturnReasonNullableFilter<$PrismaModel> | $Enums.ReturnReason | null
  }

  export type EnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | null
    notIn?: $Enums.RefundMethod[] | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type EnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[]
    notIn?: $Enums.ReturnStatus[]
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type ReturnOrderCountOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    originalOrderId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnOrderAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundAmount?: SortOrder
    syncVersion?: SortOrder
    syncAttempts?: SortOrder
  }

  export type ReturnOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    originalOrderId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnOrderMinOrderByAggregateInput = {
    id?: SortOrder
    returnNumber?: SortOrder
    originalOrderId?: SortOrder
    customerId?: SortOrder
    locationId?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundMethod?: SortOrder
    refundAmount?: SortOrder
    status?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    syncAttempts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReturnOrderSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    refundAmount?: SortOrder
    syncVersion?: SortOrder
    syncAttempts?: SortOrder
  }

  export type EnumReturnReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReturnReason[] | null
    notIn?: $Enums.ReturnReason[] | null
    not?: NestedEnumReturnReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReturnReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReturnReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumReturnReasonNullableFilter<$PrismaModel>
  }

  export type EnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | null
    notIn?: $Enums.RefundMethod[] | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type EnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[]
    notIn?: $Enums.ReturnStatus[]
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type ReturnOrderScalarRelationFilter = {
    is?: ReturnOrderWhereInput
    isNot?: ReturnOrderWhereInput
  }

  export type ReturnOrderLineCountOrderByAggregateInput = {
    id?: SortOrder
    returnOrderId?: SortOrder
    variantId?: SortOrder
    originalLineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReturnOrderLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type ReturnOrderLineMaxOrderByAggregateInput = {
    id?: SortOrder
    returnOrderId?: SortOrder
    variantId?: SortOrder
    originalLineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReturnOrderLineMinOrderByAggregateInput = {
    id?: SortOrder
    returnOrderId?: SortOrder
    variantId?: SortOrder
    originalLineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReturnOrderLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    lineTotal?: SortOrder
  }

  export type ExchangeOrderCountOrderByAggregateInput = {
    id?: SortOrder
    exchangeNumber?: SortOrder
    originalOrderId?: SortOrder
    newOrderId?: SortOrder
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ExchangeOrderAvgOrderByAggregateInput = {
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    syncVersion?: SortOrder
  }

  export type ExchangeOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    exchangeNumber?: SortOrder
    originalOrderId?: SortOrder
    newOrderId?: SortOrder
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ExchangeOrderMinOrderByAggregateInput = {
    id?: SortOrder
    exchangeNumber?: SortOrder
    originalOrderId?: SortOrder
    newOrderId?: SortOrder
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ExchangeOrderSumOrderByAggregateInput = {
    priceDifference?: SortOrder
    additionalPayment?: SortOrder
    refundAmount?: SortOrder
    syncVersion?: SortOrder
  }

  export type ParkedOrderCountOrderByAggregateInput = {
    id?: SortOrder
    parkNumber?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    parkedBy?: SortOrder
    parkedAt?: SortOrder
    expiryDate?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ParkedOrderAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type ParkedOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    parkNumber?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    parkedBy?: SortOrder
    parkedAt?: SortOrder
    expiryDate?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ParkedOrderMinOrderByAggregateInput = {
    id?: SortOrder
    parkNumber?: SortOrder
    orderId?: SortOrder
    customerId?: SortOrder
    parkedBy?: SortOrder
    parkedAt?: SortOrder
    expiryDate?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ParkedOrderSumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type EnumShiftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[]
    notIn?: $Enums.ShiftStatus[]
    not?: NestedEnumShiftStatusFilter<$PrismaModel> | $Enums.ShiftStatus
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    userId?: SortOrder
    shiftNumber?: SortOrder
    registerId?: SortOrder
    openingCash?: SortOrder
    closingCash?: SortOrder
    expectedCash?: SortOrder
    cashDifference?: SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    openingCash?: SortOrder
    closingCash?: SortOrder
    expectedCash?: SortOrder
    cashDifference?: SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    syncVersion?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    userId?: SortOrder
    shiftNumber?: SortOrder
    registerId?: SortOrder
    openingCash?: SortOrder
    closingCash?: SortOrder
    expectedCash?: SortOrder
    cashDifference?: SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    locationId?: SortOrder
    terminalId?: SortOrder
    userId?: SortOrder
    shiftNumber?: SortOrder
    registerId?: SortOrder
    openingCash?: SortOrder
    closingCash?: SortOrder
    expectedCash?: SortOrder
    cashDifference?: SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    openedAt?: SortOrder
    closedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    openingCash?: SortOrder
    closingCash?: SortOrder
    expectedCash?: SortOrder
    cashDifference?: SortOrder
    totalSales?: SortOrder
    totalRefunds?: SortOrder
    totalTransactions?: SortOrder
    syncVersion?: SortOrder
  }

  export type EnumShiftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[]
    notIn?: $Enums.ShiftStatus[]
    not?: NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShiftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftStatusFilter<$PrismaModel>
    _max?: NestedEnumShiftStatusFilter<$PrismaModel>
  }

  export type TaxRateListRelationFilter = {
    every?: TaxRateWhereInput
    some?: TaxRateWhereInput
    none?: TaxRateWhereInput
  }

  export type TaxRateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCategoryAvgOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type TaxCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    description?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxCategorySumOrderByAggregateInput = {
    syncVersion?: SortOrder
  }

  export type TaxCategoryScalarRelationFilter = {
    is?: TaxCategoryWhereInput
    isNot?: TaxCategoryWhereInput
  }

  export type TaxRateCountOrderByAggregateInput = {
    id?: SortOrder
    taxCategoryId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateAvgOrderByAggregateInput = {
    rate?: SortOrder
    syncVersion?: SortOrder
  }

  export type TaxRateMaxOrderByAggregateInput = {
    id?: SortOrder
    taxCategoryId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateMinOrderByAggregateInput = {
    id?: SortOrder
    taxCategoryId?: SortOrder
    name?: SortOrder
    rate?: SortOrder
    country?: SortOrder
    state?: SortOrder
    city?: SortOrder
    isActive?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    syncVersion?: SortOrder
    lastSyncedAt?: SortOrder
    isDirty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaxRateSumOrderByAggregateInput = {
    rate?: SortOrder
    syncVersion?: SortOrder
  }

  export type LocalSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocalSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    category?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    expiresAt?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    expiresAt?: SortOrder
    lastAccessed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalSessionCreateNestedManyWithoutTerminalInput = {
    create?: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput> | TerminalSessionCreateWithoutTerminalInput[] | TerminalSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TerminalSessionCreateOrConnectWithoutTerminalInput | TerminalSessionCreateOrConnectWithoutTerminalInput[]
    createMany?: TerminalSessionCreateManyTerminalInputEnvelope
    connect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
  }

  export type OperationModeCreateNestedManyWithoutTerminalInput = {
    create?: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput> | OperationModeCreateWithoutTerminalInput[] | OperationModeUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OperationModeCreateOrConnectWithoutTerminalInput | OperationModeCreateOrConnectWithoutTerminalInput[]
    createMany?: OperationModeCreateManyTerminalInputEnvelope
    connect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
  }

  export type ConnectionLogCreateNestedManyWithoutTerminalInput = {
    create?: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput> | ConnectionLogCreateWithoutTerminalInput[] | ConnectionLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ConnectionLogCreateOrConnectWithoutTerminalInput | ConnectionLogCreateOrConnectWithoutTerminalInput[]
    createMany?: ConnectionLogCreateManyTerminalInputEnvelope
    connect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutTerminalInput = {
    create?: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput> | UserSessionCreateWithoutTerminalInput[] | UserSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutTerminalInput | UserSessionCreateOrConnectWithoutTerminalInput[]
    createMany?: UserSessionCreateManyTerminalInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OutboxCreateNestedManyWithoutTerminalInput = {
    create?: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput> | OutboxCreateWithoutTerminalInput[] | OutboxUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OutboxCreateOrConnectWithoutTerminalInput | OutboxCreateOrConnectWithoutTerminalInput[]
    createMany?: OutboxCreateManyTerminalInputEnvelope
    connect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
  }

  export type SyncHistoryCreateNestedManyWithoutTerminalInput = {
    create?: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput> | SyncHistoryCreateWithoutTerminalInput[] | SyncHistoryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SyncHistoryCreateOrConnectWithoutTerminalInput | SyncHistoryCreateOrConnectWithoutTerminalInput[]
    createMany?: SyncHistoryCreateManyTerminalInputEnvelope
    connect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
  }

  export type SaleOrderCreateNestedManyWithoutTerminalInput = {
    create?: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput> | SaleOrderCreateWithoutTerminalInput[] | SaleOrderUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutTerminalInput | SaleOrderCreateOrConnectWithoutTerminalInput[]
    createMany?: SaleOrderCreateManyTerminalInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutTerminalInput = {
    create?: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput> | ShiftCreateWithoutTerminalInput[] | ShiftUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTerminalInput | ShiftCreateOrConnectWithoutTerminalInput[]
    createMany?: ShiftCreateManyTerminalInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput> | TerminalSessionCreateWithoutTerminalInput[] | TerminalSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TerminalSessionCreateOrConnectWithoutTerminalInput | TerminalSessionCreateOrConnectWithoutTerminalInput[]
    createMany?: TerminalSessionCreateManyTerminalInputEnvelope
    connect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
  }

  export type OperationModeUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput> | OperationModeCreateWithoutTerminalInput[] | OperationModeUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OperationModeCreateOrConnectWithoutTerminalInput | OperationModeCreateOrConnectWithoutTerminalInput[]
    createMany?: OperationModeCreateManyTerminalInputEnvelope
    connect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
  }

  export type ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput> | ConnectionLogCreateWithoutTerminalInput[] | ConnectionLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ConnectionLogCreateOrConnectWithoutTerminalInput | ConnectionLogCreateOrConnectWithoutTerminalInput[]
    createMany?: ConnectionLogCreateManyTerminalInputEnvelope
    connect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput> | UserSessionCreateWithoutTerminalInput[] | UserSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutTerminalInput | UserSessionCreateOrConnectWithoutTerminalInput[]
    createMany?: UserSessionCreateManyTerminalInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type OutboxUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput> | OutboxCreateWithoutTerminalInput[] | OutboxUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OutboxCreateOrConnectWithoutTerminalInput | OutboxCreateOrConnectWithoutTerminalInput[]
    createMany?: OutboxCreateManyTerminalInputEnvelope
    connect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
  }

  export type SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput> | SyncHistoryCreateWithoutTerminalInput[] | SyncHistoryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SyncHistoryCreateOrConnectWithoutTerminalInput | SyncHistoryCreateOrConnectWithoutTerminalInput[]
    createMany?: SyncHistoryCreateManyTerminalInputEnvelope
    connect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
  }

  export type SaleOrderUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput> | SaleOrderCreateWithoutTerminalInput[] | SaleOrderUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutTerminalInput | SaleOrderCreateOrConnectWithoutTerminalInput[]
    createMany?: SaleOrderCreateManyTerminalInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput> | ShiftCreateWithoutTerminalInput[] | ShiftUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTerminalInput | ShiftCreateOrConnectWithoutTerminalInput[]
    createMany?: ShiftCreateManyTerminalInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TerminalSessionUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput> | TerminalSessionCreateWithoutTerminalInput[] | TerminalSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TerminalSessionCreateOrConnectWithoutTerminalInput | TerminalSessionCreateOrConnectWithoutTerminalInput[]
    upsert?: TerminalSessionUpsertWithWhereUniqueWithoutTerminalInput | TerminalSessionUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: TerminalSessionCreateManyTerminalInputEnvelope
    set?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    disconnect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    delete?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    connect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    update?: TerminalSessionUpdateWithWhereUniqueWithoutTerminalInput | TerminalSessionUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: TerminalSessionUpdateManyWithWhereWithoutTerminalInput | TerminalSessionUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: TerminalSessionScalarWhereInput | TerminalSessionScalarWhereInput[]
  }

  export type OperationModeUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput> | OperationModeCreateWithoutTerminalInput[] | OperationModeUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OperationModeCreateOrConnectWithoutTerminalInput | OperationModeCreateOrConnectWithoutTerminalInput[]
    upsert?: OperationModeUpsertWithWhereUniqueWithoutTerminalInput | OperationModeUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: OperationModeCreateManyTerminalInputEnvelope
    set?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    disconnect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    delete?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    connect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    update?: OperationModeUpdateWithWhereUniqueWithoutTerminalInput | OperationModeUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: OperationModeUpdateManyWithWhereWithoutTerminalInput | OperationModeUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: OperationModeScalarWhereInput | OperationModeScalarWhereInput[]
  }

  export type ConnectionLogUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput> | ConnectionLogCreateWithoutTerminalInput[] | ConnectionLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ConnectionLogCreateOrConnectWithoutTerminalInput | ConnectionLogCreateOrConnectWithoutTerminalInput[]
    upsert?: ConnectionLogUpsertWithWhereUniqueWithoutTerminalInput | ConnectionLogUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: ConnectionLogCreateManyTerminalInputEnvelope
    set?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    disconnect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    delete?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    connect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    update?: ConnectionLogUpdateWithWhereUniqueWithoutTerminalInput | ConnectionLogUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: ConnectionLogUpdateManyWithWhereWithoutTerminalInput | ConnectionLogUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: ConnectionLogScalarWhereInput | ConnectionLogScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput> | UserSessionCreateWithoutTerminalInput[] | UserSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutTerminalInput | UserSessionCreateOrConnectWithoutTerminalInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutTerminalInput | UserSessionUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: UserSessionCreateManyTerminalInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutTerminalInput | UserSessionUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutTerminalInput | UserSessionUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OutboxUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput> | OutboxCreateWithoutTerminalInput[] | OutboxUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OutboxCreateOrConnectWithoutTerminalInput | OutboxCreateOrConnectWithoutTerminalInput[]
    upsert?: OutboxUpsertWithWhereUniqueWithoutTerminalInput | OutboxUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: OutboxCreateManyTerminalInputEnvelope
    set?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    disconnect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    delete?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    connect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    update?: OutboxUpdateWithWhereUniqueWithoutTerminalInput | OutboxUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: OutboxUpdateManyWithWhereWithoutTerminalInput | OutboxUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: OutboxScalarWhereInput | OutboxScalarWhereInput[]
  }

  export type SyncHistoryUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput> | SyncHistoryCreateWithoutTerminalInput[] | SyncHistoryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SyncHistoryCreateOrConnectWithoutTerminalInput | SyncHistoryCreateOrConnectWithoutTerminalInput[]
    upsert?: SyncHistoryUpsertWithWhereUniqueWithoutTerminalInput | SyncHistoryUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: SyncHistoryCreateManyTerminalInputEnvelope
    set?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    disconnect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    delete?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    connect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    update?: SyncHistoryUpdateWithWhereUniqueWithoutTerminalInput | SyncHistoryUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: SyncHistoryUpdateManyWithWhereWithoutTerminalInput | SyncHistoryUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: SyncHistoryScalarWhereInput | SyncHistoryScalarWhereInput[]
  }

  export type SaleOrderUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput> | SaleOrderCreateWithoutTerminalInput[] | SaleOrderUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutTerminalInput | SaleOrderCreateOrConnectWithoutTerminalInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutTerminalInput | SaleOrderUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: SaleOrderCreateManyTerminalInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutTerminalInput | SaleOrderUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutTerminalInput | SaleOrderUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput> | ShiftCreateWithoutTerminalInput[] | ShiftUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTerminalInput | ShiftCreateOrConnectWithoutTerminalInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutTerminalInput | ShiftUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: ShiftCreateManyTerminalInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutTerminalInput | ShiftUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutTerminalInput | ShiftUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput> | TerminalSessionCreateWithoutTerminalInput[] | TerminalSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TerminalSessionCreateOrConnectWithoutTerminalInput | TerminalSessionCreateOrConnectWithoutTerminalInput[]
    upsert?: TerminalSessionUpsertWithWhereUniqueWithoutTerminalInput | TerminalSessionUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: TerminalSessionCreateManyTerminalInputEnvelope
    set?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    disconnect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    delete?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    connect?: TerminalSessionWhereUniqueInput | TerminalSessionWhereUniqueInput[]
    update?: TerminalSessionUpdateWithWhereUniqueWithoutTerminalInput | TerminalSessionUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: TerminalSessionUpdateManyWithWhereWithoutTerminalInput | TerminalSessionUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: TerminalSessionScalarWhereInput | TerminalSessionScalarWhereInput[]
  }

  export type OperationModeUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput> | OperationModeCreateWithoutTerminalInput[] | OperationModeUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OperationModeCreateOrConnectWithoutTerminalInput | OperationModeCreateOrConnectWithoutTerminalInput[]
    upsert?: OperationModeUpsertWithWhereUniqueWithoutTerminalInput | OperationModeUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: OperationModeCreateManyTerminalInputEnvelope
    set?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    disconnect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    delete?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    connect?: OperationModeWhereUniqueInput | OperationModeWhereUniqueInput[]
    update?: OperationModeUpdateWithWhereUniqueWithoutTerminalInput | OperationModeUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: OperationModeUpdateManyWithWhereWithoutTerminalInput | OperationModeUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: OperationModeScalarWhereInput | OperationModeScalarWhereInput[]
  }

  export type ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput> | ConnectionLogCreateWithoutTerminalInput[] | ConnectionLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ConnectionLogCreateOrConnectWithoutTerminalInput | ConnectionLogCreateOrConnectWithoutTerminalInput[]
    upsert?: ConnectionLogUpsertWithWhereUniqueWithoutTerminalInput | ConnectionLogUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: ConnectionLogCreateManyTerminalInputEnvelope
    set?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    disconnect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    delete?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    connect?: ConnectionLogWhereUniqueInput | ConnectionLogWhereUniqueInput[]
    update?: ConnectionLogUpdateWithWhereUniqueWithoutTerminalInput | ConnectionLogUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: ConnectionLogUpdateManyWithWhereWithoutTerminalInput | ConnectionLogUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: ConnectionLogScalarWhereInput | ConnectionLogScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput> | UserSessionCreateWithoutTerminalInput[] | UserSessionUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutTerminalInput | UserSessionCreateOrConnectWithoutTerminalInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutTerminalInput | UserSessionUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: UserSessionCreateManyTerminalInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutTerminalInput | UserSessionUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutTerminalInput | UserSessionUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type OutboxUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput> | OutboxCreateWithoutTerminalInput[] | OutboxUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: OutboxCreateOrConnectWithoutTerminalInput | OutboxCreateOrConnectWithoutTerminalInput[]
    upsert?: OutboxUpsertWithWhereUniqueWithoutTerminalInput | OutboxUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: OutboxCreateManyTerminalInputEnvelope
    set?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    disconnect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    delete?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    connect?: OutboxWhereUniqueInput | OutboxWhereUniqueInput[]
    update?: OutboxUpdateWithWhereUniqueWithoutTerminalInput | OutboxUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: OutboxUpdateManyWithWhereWithoutTerminalInput | OutboxUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: OutboxScalarWhereInput | OutboxScalarWhereInput[]
  }

  export type SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput> | SyncHistoryCreateWithoutTerminalInput[] | SyncHistoryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SyncHistoryCreateOrConnectWithoutTerminalInput | SyncHistoryCreateOrConnectWithoutTerminalInput[]
    upsert?: SyncHistoryUpsertWithWhereUniqueWithoutTerminalInput | SyncHistoryUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: SyncHistoryCreateManyTerminalInputEnvelope
    set?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    disconnect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    delete?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    connect?: SyncHistoryWhereUniqueInput | SyncHistoryWhereUniqueInput[]
    update?: SyncHistoryUpdateWithWhereUniqueWithoutTerminalInput | SyncHistoryUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: SyncHistoryUpdateManyWithWhereWithoutTerminalInput | SyncHistoryUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: SyncHistoryScalarWhereInput | SyncHistoryScalarWhereInput[]
  }

  export type SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput> | SaleOrderCreateWithoutTerminalInput[] | SaleOrderUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutTerminalInput | SaleOrderCreateOrConnectWithoutTerminalInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutTerminalInput | SaleOrderUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: SaleOrderCreateManyTerminalInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutTerminalInput | SaleOrderUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutTerminalInput | SaleOrderUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput> | ShiftCreateWithoutTerminalInput[] | ShiftUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutTerminalInput | ShiftCreateOrConnectWithoutTerminalInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutTerminalInput | ShiftUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: ShiftCreateManyTerminalInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutTerminalInput | ShiftUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutTerminalInput | ShiftUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type TerminalCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TerminalCreateWithoutSessionsInput, TerminalUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSessionsInput
    connect?: TerminalWhereUniqueInput
  }

  export type TerminalUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TerminalCreateWithoutSessionsInput, TerminalUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSessionsInput
    upsert?: TerminalUpsertWithoutSessionsInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutSessionsInput, TerminalUpdateWithoutSessionsInput>, TerminalUncheckedUpdateWithoutSessionsInput>
  }

  export type TerminalCreateNestedOneWithoutOperationModesInput = {
    create?: XOR<TerminalCreateWithoutOperationModesInput, TerminalUncheckedCreateWithoutOperationModesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutOperationModesInput
    connect?: TerminalWhereUniqueInput
  }

  export type EnumOperationModeTypeFieldUpdateOperationsInput = {
    set?: $Enums.OperationModeType
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TerminalUpdateOneRequiredWithoutOperationModesNestedInput = {
    create?: XOR<TerminalCreateWithoutOperationModesInput, TerminalUncheckedCreateWithoutOperationModesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutOperationModesInput
    upsert?: TerminalUpsertWithoutOperationModesInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutOperationModesInput, TerminalUpdateWithoutOperationModesInput>, TerminalUncheckedUpdateWithoutOperationModesInput>
  }

  export type TerminalCreateNestedOneWithoutConnectionLogsInput = {
    create?: XOR<TerminalCreateWithoutConnectionLogsInput, TerminalUncheckedCreateWithoutConnectionLogsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutConnectionLogsInput
    connect?: TerminalWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TerminalUpdateOneRequiredWithoutConnectionLogsNestedInput = {
    create?: XOR<TerminalCreateWithoutConnectionLogsInput, TerminalUncheckedCreateWithoutConnectionLogsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutConnectionLogsInput
    upsert?: TerminalUpsertWithoutConnectionLogsInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutConnectionLogsInput, TerminalUpdateWithoutConnectionLogsInput>, TerminalUncheckedUpdateWithoutConnectionLogsInput>
  }

  export type ShiftCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type SaleOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput> | SaleOrderCreateWithoutUserInput[] | SaleOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutUserInput | SaleOrderCreateOrConnectWithoutUserInput[]
    createMany?: SaleOrderCreateManyUserInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type SaleOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput> | SaleOrderCreateWithoutUserInput[] | SaleOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutUserInput | SaleOrderCreateOrConnectWithoutUserInput[]
    createMany?: SaleOrderCreateManyUserInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ShiftUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutUserInput | ShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutUserInput | ShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutUserInput | ShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type SaleOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput> | SaleOrderCreateWithoutUserInput[] | SaleOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutUserInput | SaleOrderCreateOrConnectWithoutUserInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutUserInput | SaleOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaleOrderCreateManyUserInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutUserInput | SaleOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutUserInput | SaleOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput> | ShiftCreateWithoutUserInput[] | ShiftUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutUserInput | ShiftCreateOrConnectWithoutUserInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutUserInput | ShiftUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ShiftCreateManyUserInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutUserInput | ShiftUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutUserInput | ShiftUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type SaleOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput> | SaleOrderCreateWithoutUserInput[] | SaleOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutUserInput | SaleOrderCreateOrConnectWithoutUserInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutUserInput | SaleOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SaleOrderCreateManyUserInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutUserInput | SaleOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutUserInput | SaleOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type LocalUserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<LocalUserCreateWithoutSessionsInput, LocalUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutSessionsInput
    connect?: LocalUserWhereUniqueInput
  }

  export type TerminalCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<TerminalCreateWithoutUserSessionsInput, TerminalUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutUserSessionsInput
    connect?: TerminalWhereUniqueInput
  }

  export type LocalUserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<LocalUserCreateWithoutSessionsInput, LocalUserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutSessionsInput
    upsert?: LocalUserUpsertWithoutSessionsInput
    connect?: LocalUserWhereUniqueInput
    update?: XOR<XOR<LocalUserUpdateToOneWithWhereWithoutSessionsInput, LocalUserUpdateWithoutSessionsInput>, LocalUserUncheckedUpdateWithoutSessionsInput>
  }

  export type TerminalUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<TerminalCreateWithoutUserSessionsInput, TerminalUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutUserSessionsInput
    upsert?: TerminalUpsertWithoutUserSessionsInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutUserSessionsInput, TerminalUpdateWithoutUserSessionsInput>, TerminalUncheckedUpdateWithoutUserSessionsInput>
  }

  export type TerminalCreateNestedOneWithoutOutboxesInput = {
    create?: XOR<TerminalCreateWithoutOutboxesInput, TerminalUncheckedCreateWithoutOutboxesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutOutboxesInput
    connect?: TerminalWhereUniqueInput
  }

  export type EnumSyncOperationFieldUpdateOperationsInput = {
    set?: $Enums.SyncOperation
  }

  export type TerminalUpdateOneRequiredWithoutOutboxesNestedInput = {
    create?: XOR<TerminalCreateWithoutOutboxesInput, TerminalUncheckedCreateWithoutOutboxesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutOutboxesInput
    upsert?: TerminalUpsertWithoutOutboxesInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutOutboxesInput, TerminalUpdateWithoutOutboxesInput>, TerminalUncheckedUpdateWithoutOutboxesInput>
  }

  export type TerminalCreateNestedOneWithoutSyncHistoriesInput = {
    create?: XOR<TerminalCreateWithoutSyncHistoriesInput, TerminalUncheckedCreateWithoutSyncHistoriesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSyncHistoriesInput
    connect?: TerminalWhereUniqueInput
  }

  export type EnumSyncTypeFieldUpdateOperationsInput = {
    set?: $Enums.SyncType
  }

  export type EnumSyncDirectionFieldUpdateOperationsInput = {
    set?: $Enums.SyncDirection
  }

  export type TerminalUpdateOneRequiredWithoutSyncHistoriesNestedInput = {
    create?: XOR<TerminalCreateWithoutSyncHistoriesInput, TerminalUncheckedCreateWithoutSyncHistoriesInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSyncHistoriesInput
    upsert?: TerminalUpsertWithoutSyncHistoriesInput
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutSyncHistoriesInput, TerminalUpdateWithoutSyncHistoriesInput>, TerminalUncheckedUpdateWithoutSyncHistoriesInput>
  }

  export type SaleOrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput> | SaleOrderCreateWithoutLocationInput[] | SaleOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLocationInput | SaleOrderCreateOrConnectWithoutLocationInput[]
    createMany?: SaleOrderCreateManyLocationInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type InventoryItemCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput> | InventoryItemCreateWithoutLocationInput[] | InventoryItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLocationInput | InventoryItemCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryItemCreateManyLocationInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutLocationInput = {
    create?: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput> | ShiftCreateWithoutLocationInput[] | ShiftUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutLocationInput | ShiftCreateOrConnectWithoutLocationInput[]
    createMany?: ShiftCreateManyLocationInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type StockAdjustmentCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput> | StockAdjustmentCreateWithoutLocationInput[] | StockAdjustmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLocationInput | StockAdjustmentCreateOrConnectWithoutLocationInput[]
    createMany?: StockAdjustmentCreateManyLocationInputEnvelope
    connect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutFromLocationInput = {
    create?: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput> | StockTransferCreateWithoutFromLocationInput[] | StockTransferUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutFromLocationInput | StockTransferCreateOrConnectWithoutFromLocationInput[]
    createMany?: StockTransferCreateManyFromLocationInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockTransferCreateNestedManyWithoutToLocationInput = {
    create?: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput> | StockTransferCreateWithoutToLocationInput[] | StockTransferUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutToLocationInput | StockTransferCreateOrConnectWithoutToLocationInput[]
    createMany?: StockTransferCreateManyToLocationInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type ReturnOrderCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput> | ReturnOrderCreateWithoutLocationInput[] | ReturnOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLocationInput | ReturnOrderCreateOrConnectWithoutLocationInput[]
    createMany?: ReturnOrderCreateManyLocationInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type SaleOrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput> | SaleOrderCreateWithoutLocationInput[] | SaleOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLocationInput | SaleOrderCreateOrConnectWithoutLocationInput[]
    createMany?: SaleOrderCreateManyLocationInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput> | InventoryItemCreateWithoutLocationInput[] | InventoryItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLocationInput | InventoryItemCreateOrConnectWithoutLocationInput[]
    createMany?: InventoryItemCreateManyLocationInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput> | ShiftCreateWithoutLocationInput[] | ShiftUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutLocationInput | ShiftCreateOrConnectWithoutLocationInput[]
    createMany?: ShiftCreateManyLocationInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput> | StockAdjustmentCreateWithoutLocationInput[] | StockAdjustmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLocationInput | StockAdjustmentCreateOrConnectWithoutLocationInput[]
    createMany?: StockAdjustmentCreateManyLocationInputEnvelope
    connect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutFromLocationInput = {
    create?: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput> | StockTransferCreateWithoutFromLocationInput[] | StockTransferUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutFromLocationInput | StockTransferCreateOrConnectWithoutFromLocationInput[]
    createMany?: StockTransferCreateManyFromLocationInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type StockTransferUncheckedCreateNestedManyWithoutToLocationInput = {
    create?: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput> | StockTransferCreateWithoutToLocationInput[] | StockTransferUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutToLocationInput | StockTransferCreateOrConnectWithoutToLocationInput[]
    createMany?: StockTransferCreateManyToLocationInputEnvelope
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
  }

  export type ReturnOrderUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput> | ReturnOrderCreateWithoutLocationInput[] | ReturnOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLocationInput | ReturnOrderCreateOrConnectWithoutLocationInput[]
    createMany?: ReturnOrderCreateManyLocationInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type EnumLocationTypeFieldUpdateOperationsInput = {
    set?: $Enums.LocationType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SaleOrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput> | SaleOrderCreateWithoutLocationInput[] | SaleOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLocationInput | SaleOrderCreateOrConnectWithoutLocationInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutLocationInput | SaleOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SaleOrderCreateManyLocationInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutLocationInput | SaleOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutLocationInput | SaleOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type InventoryItemUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput> | InventoryItemCreateWithoutLocationInput[] | InventoryItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLocationInput | InventoryItemCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutLocationInput | InventoryItemUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryItemCreateManyLocationInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutLocationInput | InventoryItemUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutLocationInput | InventoryItemUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput> | ShiftCreateWithoutLocationInput[] | ShiftUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutLocationInput | ShiftCreateOrConnectWithoutLocationInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutLocationInput | ShiftUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ShiftCreateManyLocationInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutLocationInput | ShiftUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutLocationInput | ShiftUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type StockAdjustmentUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput> | StockAdjustmentCreateWithoutLocationInput[] | StockAdjustmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLocationInput | StockAdjustmentCreateOrConnectWithoutLocationInput[]
    upsert?: StockAdjustmentUpsertWithWhereUniqueWithoutLocationInput | StockAdjustmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockAdjustmentCreateManyLocationInputEnvelope
    set?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    disconnect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    delete?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    connect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    update?: StockAdjustmentUpdateWithWhereUniqueWithoutLocationInput | StockAdjustmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockAdjustmentUpdateManyWithWhereWithoutLocationInput | StockAdjustmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockAdjustmentScalarWhereInput | StockAdjustmentScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutFromLocationNestedInput = {
    create?: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput> | StockTransferCreateWithoutFromLocationInput[] | StockTransferUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutFromLocationInput | StockTransferCreateOrConnectWithoutFromLocationInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutFromLocationInput | StockTransferUpsertWithWhereUniqueWithoutFromLocationInput[]
    createMany?: StockTransferCreateManyFromLocationInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutFromLocationInput | StockTransferUpdateWithWhereUniqueWithoutFromLocationInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutFromLocationInput | StockTransferUpdateManyWithWhereWithoutFromLocationInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockTransferUpdateManyWithoutToLocationNestedInput = {
    create?: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput> | StockTransferCreateWithoutToLocationInput[] | StockTransferUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutToLocationInput | StockTransferCreateOrConnectWithoutToLocationInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutToLocationInput | StockTransferUpsertWithWhereUniqueWithoutToLocationInput[]
    createMany?: StockTransferCreateManyToLocationInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutToLocationInput | StockTransferUpdateWithWhereUniqueWithoutToLocationInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutToLocationInput | StockTransferUpdateManyWithWhereWithoutToLocationInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type ReturnOrderUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput> | ReturnOrderCreateWithoutLocationInput[] | ReturnOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLocationInput | ReturnOrderCreateOrConnectWithoutLocationInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutLocationInput | ReturnOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReturnOrderCreateManyLocationInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutLocationInput | ReturnOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutLocationInput | ReturnOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type SaleOrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput> | SaleOrderCreateWithoutLocationInput[] | SaleOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLocationInput | SaleOrderCreateOrConnectWithoutLocationInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutLocationInput | SaleOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: SaleOrderCreateManyLocationInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutLocationInput | SaleOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutLocationInput | SaleOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput> | InventoryItemCreateWithoutLocationInput[] | InventoryItemUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutLocationInput | InventoryItemCreateOrConnectWithoutLocationInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutLocationInput | InventoryItemUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: InventoryItemCreateManyLocationInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutLocationInput | InventoryItemUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutLocationInput | InventoryItemUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput> | ShiftCreateWithoutLocationInput[] | ShiftUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutLocationInput | ShiftCreateOrConnectWithoutLocationInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutLocationInput | ShiftUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ShiftCreateManyLocationInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutLocationInput | ShiftUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutLocationInput | ShiftUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput> | StockAdjustmentCreateWithoutLocationInput[] | StockAdjustmentUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLocationInput | StockAdjustmentCreateOrConnectWithoutLocationInput[]
    upsert?: StockAdjustmentUpsertWithWhereUniqueWithoutLocationInput | StockAdjustmentUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StockAdjustmentCreateManyLocationInputEnvelope
    set?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    disconnect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    delete?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    connect?: StockAdjustmentWhereUniqueInput | StockAdjustmentWhereUniqueInput[]
    update?: StockAdjustmentUpdateWithWhereUniqueWithoutLocationInput | StockAdjustmentUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StockAdjustmentUpdateManyWithWhereWithoutLocationInput | StockAdjustmentUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StockAdjustmentScalarWhereInput | StockAdjustmentScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput = {
    create?: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput> | StockTransferCreateWithoutFromLocationInput[] | StockTransferUncheckedCreateWithoutFromLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutFromLocationInput | StockTransferCreateOrConnectWithoutFromLocationInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutFromLocationInput | StockTransferUpsertWithWhereUniqueWithoutFromLocationInput[]
    createMany?: StockTransferCreateManyFromLocationInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutFromLocationInput | StockTransferUpdateWithWhereUniqueWithoutFromLocationInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutFromLocationInput | StockTransferUpdateManyWithWhereWithoutFromLocationInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type StockTransferUncheckedUpdateManyWithoutToLocationNestedInput = {
    create?: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput> | StockTransferCreateWithoutToLocationInput[] | StockTransferUncheckedCreateWithoutToLocationInput[]
    connectOrCreate?: StockTransferCreateOrConnectWithoutToLocationInput | StockTransferCreateOrConnectWithoutToLocationInput[]
    upsert?: StockTransferUpsertWithWhereUniqueWithoutToLocationInput | StockTransferUpsertWithWhereUniqueWithoutToLocationInput[]
    createMany?: StockTransferCreateManyToLocationInputEnvelope
    set?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    disconnect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    delete?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    connect?: StockTransferWhereUniqueInput | StockTransferWhereUniqueInput[]
    update?: StockTransferUpdateWithWhereUniqueWithoutToLocationInput | StockTransferUpdateWithWhereUniqueWithoutToLocationInput[]
    updateMany?: StockTransferUpdateManyWithWhereWithoutToLocationInput | StockTransferUpdateManyWithWhereWithoutToLocationInput[]
    deleteMany?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
  }

  export type ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput> | ReturnOrderCreateWithoutLocationInput[] | ReturnOrderUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLocationInput | ReturnOrderCreateOrConnectWithoutLocationInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutLocationInput | ReturnOrderUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: ReturnOrderCreateManyLocationInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutLocationInput | ReturnOrderUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutLocationInput | ReturnOrderUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    connect?: BrandWhereUniqueInput
  }

  export type TaxCategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<TaxCategoryCreateWithoutProductsInput, TaxCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TaxCategoryCreateOrConnectWithoutProductsInput
    connect?: TaxCategoryWhereUniqueInput
  }

  export type ProductVariantCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type ProductVariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
  }

  export type EnumProductTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProductType
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateOneWithoutProductsNestedInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    upsert?: BrandUpsertWithoutProductsInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductsInput, BrandUpdateWithoutProductsInput>, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type TaxCategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<TaxCategoryCreateWithoutProductsInput, TaxCategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TaxCategoryCreateOrConnectWithoutProductsInput
    upsert?: TaxCategoryUpsertWithoutProductsInput
    disconnect?: TaxCategoryWhereInput | boolean
    delete?: TaxCategoryWhereInput | boolean
    connect?: TaxCategoryWhereUniqueInput
    update?: XOR<XOR<TaxCategoryUpdateToOneWithWhereWithoutProductsInput, TaxCategoryUpdateWithoutProductsInput>, TaxCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ProductVariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput> | ProductVariantCreateWithoutProductInput[] | ProductVariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductVariantCreateOrConnectWithoutProductInput | ProductVariantCreateOrConnectWithoutProductInput[]
    upsert?: ProductVariantUpsertWithWhereUniqueWithoutProductInput | ProductVariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductVariantCreateManyProductInputEnvelope
    set?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    disconnect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    delete?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    connect?: ProductVariantWhereUniqueInput | ProductVariantWhereUniqueInput[]
    update?: ProductVariantUpdateWithWhereUniqueWithoutProductInput | ProductVariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductVariantUpdateManyWithWhereWithoutProductInput | ProductVariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type InventoryItemCreateNestedManyWithoutVariantInput = {
    create?: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput> | InventoryItemCreateWithoutVariantInput[] | InventoryItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVariantInput | InventoryItemCreateOrConnectWithoutVariantInput[]
    createMany?: InventoryItemCreateManyVariantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleOrderLineCreateNestedManyWithoutVariantInput = {
    create?: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput> | SaleOrderLineCreateWithoutVariantInput[] | SaleOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutVariantInput | SaleOrderLineCreateOrConnectWithoutVariantInput[]
    createMany?: SaleOrderLineCreateManyVariantInputEnvelope
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
  }

  export type ReturnOrderLineCreateNestedManyWithoutVariantInput = {
    create?: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput> | ReturnOrderLineCreateWithoutVariantInput[] | ReturnOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutVariantInput | ReturnOrderLineCreateOrConnectWithoutVariantInput[]
    createMany?: ReturnOrderLineCreateManyVariantInputEnvelope
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
  }

  export type StockAdjustmentLineCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput> | StockAdjustmentLineCreateWithoutVariantInput[] | StockAdjustmentLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutVariantInput | StockAdjustmentLineCreateOrConnectWithoutVariantInput[]
    createMany?: StockAdjustmentLineCreateManyVariantInputEnvelope
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
  }

  export type StockTransferLineCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput> | StockTransferLineCreateWithoutVariantInput[] | StockTransferLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutVariantInput | StockTransferLineCreateOrConnectWithoutVariantInput[]
    createMany?: StockTransferLineCreateManyVariantInputEnvelope
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
  }

  export type InventoryItemUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput> | InventoryItemCreateWithoutVariantInput[] | InventoryItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVariantInput | InventoryItemCreateOrConnectWithoutVariantInput[]
    createMany?: InventoryItemCreateManyVariantInputEnvelope
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
  }

  export type SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput> | SaleOrderLineCreateWithoutVariantInput[] | SaleOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutVariantInput | SaleOrderLineCreateOrConnectWithoutVariantInput[]
    createMany?: SaleOrderLineCreateManyVariantInputEnvelope
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
  }

  export type ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput> | ReturnOrderLineCreateWithoutVariantInput[] | ReturnOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutVariantInput | ReturnOrderLineCreateOrConnectWithoutVariantInput[]
    createMany?: ReturnOrderLineCreateManyVariantInputEnvelope
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
  }

  export type StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput> | StockAdjustmentLineCreateWithoutVariantInput[] | StockAdjustmentLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutVariantInput | StockAdjustmentLineCreateOrConnectWithoutVariantInput[]
    createMany?: StockAdjustmentLineCreateManyVariantInputEnvelope
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
  }

  export type StockTransferLineUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput> | StockTransferLineCreateWithoutVariantInput[] | StockTransferLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutVariantInput | StockTransferLineCreateOrConnectWithoutVariantInput[]
    createMany?: StockTransferLineCreateManyVariantInputEnvelope
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type InventoryItemUpdateManyWithoutVariantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput> | InventoryItemCreateWithoutVariantInput[] | InventoryItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVariantInput | InventoryItemCreateOrConnectWithoutVariantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutVariantInput | InventoryItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: InventoryItemCreateManyVariantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutVariantInput | InventoryItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutVariantInput | InventoryItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleOrderLineUpdateManyWithoutVariantNestedInput = {
    create?: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput> | SaleOrderLineCreateWithoutVariantInput[] | SaleOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutVariantInput | SaleOrderLineCreateOrConnectWithoutVariantInput[]
    upsert?: SaleOrderLineUpsertWithWhereUniqueWithoutVariantInput | SaleOrderLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: SaleOrderLineCreateManyVariantInputEnvelope
    set?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    disconnect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    delete?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    update?: SaleOrderLineUpdateWithWhereUniqueWithoutVariantInput | SaleOrderLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: SaleOrderLineUpdateManyWithWhereWithoutVariantInput | SaleOrderLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
  }

  export type ReturnOrderLineUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput> | ReturnOrderLineCreateWithoutVariantInput[] | ReturnOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutVariantInput | ReturnOrderLineCreateOrConnectWithoutVariantInput[]
    upsert?: ReturnOrderLineUpsertWithWhereUniqueWithoutVariantInput | ReturnOrderLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ReturnOrderLineCreateManyVariantInputEnvelope
    set?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    disconnect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    delete?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    update?: ReturnOrderLineUpdateWithWhereUniqueWithoutVariantInput | ReturnOrderLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ReturnOrderLineUpdateManyWithWhereWithoutVariantInput | ReturnOrderLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
  }

  export type StockAdjustmentLineUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput> | StockAdjustmentLineCreateWithoutVariantInput[] | StockAdjustmentLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutVariantInput | StockAdjustmentLineCreateOrConnectWithoutVariantInput[]
    upsert?: StockAdjustmentLineUpsertWithWhereUniqueWithoutVariantInput | StockAdjustmentLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockAdjustmentLineCreateManyVariantInputEnvelope
    set?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    disconnect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    delete?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    update?: StockAdjustmentLineUpdateWithWhereUniqueWithoutVariantInput | StockAdjustmentLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockAdjustmentLineUpdateManyWithWhereWithoutVariantInput | StockAdjustmentLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
  }

  export type StockTransferLineUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput> | StockTransferLineCreateWithoutVariantInput[] | StockTransferLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutVariantInput | StockTransferLineCreateOrConnectWithoutVariantInput[]
    upsert?: StockTransferLineUpsertWithWhereUniqueWithoutVariantInput | StockTransferLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockTransferLineCreateManyVariantInputEnvelope
    set?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    disconnect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    delete?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    update?: StockTransferLineUpdateWithWhereUniqueWithoutVariantInput | StockTransferLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockTransferLineUpdateManyWithWhereWithoutVariantInput | StockTransferLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
  }

  export type InventoryItemUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput> | InventoryItemCreateWithoutVariantInput[] | InventoryItemUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: InventoryItemCreateOrConnectWithoutVariantInput | InventoryItemCreateOrConnectWithoutVariantInput[]
    upsert?: InventoryItemUpsertWithWhereUniqueWithoutVariantInput | InventoryItemUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: InventoryItemCreateManyVariantInputEnvelope
    set?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    disconnect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    delete?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    connect?: InventoryItemWhereUniqueInput | InventoryItemWhereUniqueInput[]
    update?: InventoryItemUpdateWithWhereUniqueWithoutVariantInput | InventoryItemUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: InventoryItemUpdateManyWithWhereWithoutVariantInput | InventoryItemUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
  }

  export type SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput> | SaleOrderLineCreateWithoutVariantInput[] | SaleOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutVariantInput | SaleOrderLineCreateOrConnectWithoutVariantInput[]
    upsert?: SaleOrderLineUpsertWithWhereUniqueWithoutVariantInput | SaleOrderLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: SaleOrderLineCreateManyVariantInputEnvelope
    set?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    disconnect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    delete?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    update?: SaleOrderLineUpdateWithWhereUniqueWithoutVariantInput | SaleOrderLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: SaleOrderLineUpdateManyWithWhereWithoutVariantInput | SaleOrderLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
  }

  export type ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput> | ReturnOrderLineCreateWithoutVariantInput[] | ReturnOrderLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutVariantInput | ReturnOrderLineCreateOrConnectWithoutVariantInput[]
    upsert?: ReturnOrderLineUpsertWithWhereUniqueWithoutVariantInput | ReturnOrderLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: ReturnOrderLineCreateManyVariantInputEnvelope
    set?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    disconnect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    delete?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    update?: ReturnOrderLineUpdateWithWhereUniqueWithoutVariantInput | ReturnOrderLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: ReturnOrderLineUpdateManyWithWhereWithoutVariantInput | ReturnOrderLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
  }

  export type StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput> | StockAdjustmentLineCreateWithoutVariantInput[] | StockAdjustmentLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutVariantInput | StockAdjustmentLineCreateOrConnectWithoutVariantInput[]
    upsert?: StockAdjustmentLineUpsertWithWhereUniqueWithoutVariantInput | StockAdjustmentLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockAdjustmentLineCreateManyVariantInputEnvelope
    set?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    disconnect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    delete?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    update?: StockAdjustmentLineUpdateWithWhereUniqueWithoutVariantInput | StockAdjustmentLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockAdjustmentLineUpdateManyWithWhereWithoutVariantInput | StockAdjustmentLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
  }

  export type StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput> | StockTransferLineCreateWithoutVariantInput[] | StockTransferLineUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutVariantInput | StockTransferLineCreateOrConnectWithoutVariantInput[]
    upsert?: StockTransferLineUpsertWithWhereUniqueWithoutVariantInput | StockTransferLineUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: StockTransferLineCreateManyVariantInputEnvelope
    set?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    disconnect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    delete?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    update?: StockTransferLineUpdateWithWhereUniqueWithoutVariantInput | StockTransferLineUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: StockTransferLineUpdateManyWithWhereWithoutVariantInput | StockTransferLineUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    connect?: CategoryWhereUniqueInput
  }

  export type CategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type CategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutChildrenInput
    upsert?: CategoryUpsertWithoutChildrenInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutChildrenInput, CategoryUpdateWithoutChildrenInput>, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput> | CategoryCreateWithoutParentInput[] | CategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CategoryCreateOrConnectWithoutParentInput | CategoryCreateOrConnectWithoutParentInput[]
    upsert?: CategoryUpsertWithWhereUniqueWithoutParentInput | CategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CategoryCreateManyParentInputEnvelope
    set?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    disconnect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    delete?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    connect?: CategoryWhereUniqueInput | CategoryWhereUniqueInput[]
    update?: CategoryUpdateWithWhereUniqueWithoutParentInput | CategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CategoryUpdateManyWithWhereWithoutParentInput | CategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type CustomerGroupCreateNestedOneWithoutCustomersInput = {
    create?: XOR<CustomerGroupCreateWithoutCustomersInput, CustomerGroupUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutCustomersInput
    connect?: CustomerGroupWhereUniqueInput
  }

  export type CustomerAddressCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type SaleOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput> | SaleOrderCreateWithoutCustomerInput[] | SaleOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutCustomerInput | SaleOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleOrderCreateManyCustomerInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type ReturnOrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput> | ReturnOrderCreateWithoutCustomerInput[] | ReturnOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutCustomerInput | ReturnOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: ReturnOrderCreateManyCustomerInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
  }

  export type SaleOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput> | SaleOrderCreateWithoutCustomerInput[] | SaleOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutCustomerInput | SaleOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: SaleOrderCreateManyCustomerInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type ReturnOrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput> | ReturnOrderCreateWithoutCustomerInput[] | ReturnOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutCustomerInput | ReturnOrderCreateOrConnectWithoutCustomerInput[]
    createMany?: ReturnOrderCreateManyCustomerInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type EnumCustomerTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerType
  }

  export type CustomerGroupUpdateOneWithoutCustomersNestedInput = {
    create?: XOR<CustomerGroupCreateWithoutCustomersInput, CustomerGroupUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: CustomerGroupCreateOrConnectWithoutCustomersInput
    upsert?: CustomerGroupUpsertWithoutCustomersInput
    disconnect?: CustomerGroupWhereInput | boolean
    delete?: CustomerGroupWhereInput | boolean
    connect?: CustomerGroupWhereUniqueInput
    update?: XOR<XOR<CustomerGroupUpdateToOneWithWhereWithoutCustomersInput, CustomerGroupUpdateWithoutCustomersInput>, CustomerGroupUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerAddressUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type SaleOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput> | SaleOrderCreateWithoutCustomerInput[] | SaleOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutCustomerInput | SaleOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutCustomerInput | SaleOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleOrderCreateManyCustomerInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutCustomerInput | SaleOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutCustomerInput | SaleOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type ReturnOrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput> | ReturnOrderCreateWithoutCustomerInput[] | ReturnOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutCustomerInput | ReturnOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutCustomerInput | ReturnOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReturnOrderCreateManyCustomerInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutCustomerInput | ReturnOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutCustomerInput | ReturnOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput> | CustomerAddressCreateWithoutCustomerInput[] | CustomerAddressUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: CustomerAddressCreateOrConnectWithoutCustomerInput | CustomerAddressCreateOrConnectWithoutCustomerInput[]
    upsert?: CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput | CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: CustomerAddressCreateManyCustomerInputEnvelope
    set?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    disconnect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    delete?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    connect?: CustomerAddressWhereUniqueInput | CustomerAddressWhereUniqueInput[]
    update?: CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput | CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: CustomerAddressUpdateManyWithWhereWithoutCustomerInput | CustomerAddressUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
  }

  export type SaleOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput> | SaleOrderCreateWithoutCustomerInput[] | SaleOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutCustomerInput | SaleOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutCustomerInput | SaleOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SaleOrderCreateManyCustomerInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutCustomerInput | SaleOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutCustomerInput | SaleOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type ReturnOrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput> | ReturnOrderCreateWithoutCustomerInput[] | ReturnOrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutCustomerInput | ReturnOrderCreateOrConnectWithoutCustomerInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutCustomerInput | ReturnOrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ReturnOrderCreateManyCustomerInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutCustomerInput | ReturnOrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutCustomerInput | ReturnOrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type CustomerCreateNestedManyWithoutGroupInput = {
    create?: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput> | CustomerCreateWithoutGroupInput[] | CustomerUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutGroupInput | CustomerCreateOrConnectWithoutGroupInput[]
    createMany?: CustomerCreateManyGroupInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput> | CustomerCreateWithoutGroupInput[] | CustomerUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutGroupInput | CustomerCreateOrConnectWithoutGroupInput[]
    createMany?: CustomerCreateManyGroupInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type CustomerUpdateManyWithoutGroupNestedInput = {
    create?: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput> | CustomerCreateWithoutGroupInput[] | CustomerUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutGroupInput | CustomerCreateOrConnectWithoutGroupInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutGroupInput | CustomerUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: CustomerCreateManyGroupInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutGroupInput | CustomerUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutGroupInput | CustomerUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput> | CustomerCreateWithoutGroupInput[] | CustomerUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutGroupInput | CustomerCreateOrConnectWithoutGroupInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutGroupInput | CustomerUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: CustomerCreateManyGroupInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutGroupInput | CustomerUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutGroupInput | CustomerUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutAddressesInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumAddressTypeFieldUpdateOperationsInput = {
    set?: $Enums.AddressType
  }

  export type CustomerUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAddressesInput
    upsert?: CustomerUpsertWithoutAddressesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAddressesInput, CustomerUpdateWithoutAddressesInput>, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type ProductVariantCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryItemsInput, ProductVariantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryItemsInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<LocationCreateWithoutInventoryItemsInput, LocationUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryItemsInput
    connect?: LocationWhereUniqueInput
  }

  export type ProductVariantUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<ProductVariantCreateWithoutInventoryItemsInput, ProductVariantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutInventoryItemsInput
    upsert?: ProductVariantUpsertWithoutInventoryItemsInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutInventoryItemsInput, ProductVariantUpdateWithoutInventoryItemsInput>, ProductVariantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type LocationUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<LocationCreateWithoutInventoryItemsInput, LocationUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutInventoryItemsInput
    upsert?: LocationUpsertWithoutInventoryItemsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutInventoryItemsInput, LocationUpdateWithoutInventoryItemsInput>, LocationUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type LocationCreateNestedOneWithoutStockAdjustmentsInput = {
    create?: XOR<LocationCreateWithoutStockAdjustmentsInput, LocationUncheckedCreateWithoutStockAdjustmentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockAdjustmentsInput
    connect?: LocationWhereUniqueInput
  }

  export type StockAdjustmentLineCreateNestedManyWithoutAdjustmentInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput> | StockAdjustmentLineCreateWithoutAdjustmentInput[] | StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput | StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    createMany?: StockAdjustmentLineCreateManyAdjustmentInputEnvelope
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
  }

  export type StockAdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput> | StockAdjustmentLineCreateWithoutAdjustmentInput[] | StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput | StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    createMany?: StockAdjustmentLineCreateManyAdjustmentInputEnvelope
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
  }

  export type EnumStockAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.StockAdjustmentType
  }

  export type LocationUpdateOneRequiredWithoutStockAdjustmentsNestedInput = {
    create?: XOR<LocationCreateWithoutStockAdjustmentsInput, LocationUncheckedCreateWithoutStockAdjustmentsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockAdjustmentsInput
    upsert?: LocationUpsertWithoutStockAdjustmentsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockAdjustmentsInput, LocationUpdateWithoutStockAdjustmentsInput>, LocationUncheckedUpdateWithoutStockAdjustmentsInput>
  }

  export type StockAdjustmentLineUpdateManyWithoutAdjustmentNestedInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput> | StockAdjustmentLineCreateWithoutAdjustmentInput[] | StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput | StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    upsert?: StockAdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput | StockAdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput[]
    createMany?: StockAdjustmentLineCreateManyAdjustmentInputEnvelope
    set?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    disconnect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    delete?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    update?: StockAdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput | StockAdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput[]
    updateMany?: StockAdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput | StockAdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput[]
    deleteMany?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
  }

  export type StockAdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput = {
    create?: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput> | StockAdjustmentLineCreateWithoutAdjustmentInput[] | StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput[]
    connectOrCreate?: StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput | StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput[]
    upsert?: StockAdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput | StockAdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput[]
    createMany?: StockAdjustmentLineCreateManyAdjustmentInputEnvelope
    set?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    disconnect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    delete?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    connect?: StockAdjustmentLineWhereUniqueInput | StockAdjustmentLineWhereUniqueInput[]
    update?: StockAdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput | StockAdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput[]
    updateMany?: StockAdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput | StockAdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput[]
    deleteMany?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
  }

  export type StockAdjustmentCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<StockAdjustmentCreateWithoutLineItemsInput, StockAdjustmentUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLineItemsInput
    connect?: StockAdjustmentWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockAdjustmentLinesInput = {
    create?: XOR<ProductVariantCreateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedCreateWithoutStockAdjustmentLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockAdjustmentLinesInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type StockAdjustmentUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<StockAdjustmentCreateWithoutLineItemsInput, StockAdjustmentUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: StockAdjustmentCreateOrConnectWithoutLineItemsInput
    upsert?: StockAdjustmentUpsertWithoutLineItemsInput
    connect?: StockAdjustmentWhereUniqueInput
    update?: XOR<XOR<StockAdjustmentUpdateToOneWithWhereWithoutLineItemsInput, StockAdjustmentUpdateWithoutLineItemsInput>, StockAdjustmentUncheckedUpdateWithoutLineItemsInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutStockAdjustmentLinesNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedCreateWithoutStockAdjustmentLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockAdjustmentLinesInput
    upsert?: ProductVariantUpsertWithoutStockAdjustmentLinesInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockAdjustmentLinesInput, ProductVariantUpdateWithoutStockAdjustmentLinesInput>, ProductVariantUncheckedUpdateWithoutStockAdjustmentLinesInput>
  }

  export type LocationCreateNestedOneWithoutStockTransfersFromInput = {
    create?: XOR<LocationCreateWithoutStockTransfersFromInput, LocationUncheckedCreateWithoutStockTransfersFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockTransfersFromInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStockTransfersToInput = {
    create?: XOR<LocationCreateWithoutStockTransfersToInput, LocationUncheckedCreateWithoutStockTransfersToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockTransfersToInput
    connect?: LocationWhereUniqueInput
  }

  export type StockTransferLineCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput> | StockTransferLineCreateWithoutTransferInput[] | StockTransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutTransferInput | StockTransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: StockTransferLineCreateManyTransferInputEnvelope
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
  }

  export type StockTransferLineUncheckedCreateNestedManyWithoutTransferInput = {
    create?: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput> | StockTransferLineCreateWithoutTransferInput[] | StockTransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutTransferInput | StockTransferLineCreateOrConnectWithoutTransferInput[]
    createMany?: StockTransferLineCreateManyTransferInputEnvelope
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
  }

  export type EnumTransferStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransferStatus
  }

  export type LocationUpdateOneRequiredWithoutStockTransfersFromNestedInput = {
    create?: XOR<LocationCreateWithoutStockTransfersFromInput, LocationUncheckedCreateWithoutStockTransfersFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockTransfersFromInput
    upsert?: LocationUpsertWithoutStockTransfersFromInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockTransfersFromInput, LocationUpdateWithoutStockTransfersFromInput>, LocationUncheckedUpdateWithoutStockTransfersFromInput>
  }

  export type LocationUpdateOneRequiredWithoutStockTransfersToNestedInput = {
    create?: XOR<LocationCreateWithoutStockTransfersToInput, LocationUncheckedCreateWithoutStockTransfersToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStockTransfersToInput
    upsert?: LocationUpsertWithoutStockTransfersToInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStockTransfersToInput, LocationUpdateWithoutStockTransfersToInput>, LocationUncheckedUpdateWithoutStockTransfersToInput>
  }

  export type StockTransferLineUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput> | StockTransferLineCreateWithoutTransferInput[] | StockTransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutTransferInput | StockTransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: StockTransferLineUpsertWithWhereUniqueWithoutTransferInput | StockTransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: StockTransferLineCreateManyTransferInputEnvelope
    set?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    disconnect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    delete?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    update?: StockTransferLineUpdateWithWhereUniqueWithoutTransferInput | StockTransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockTransferLineUpdateManyWithWhereWithoutTransferInput | StockTransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
  }

  export type StockTransferLineUncheckedUpdateManyWithoutTransferNestedInput = {
    create?: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput> | StockTransferLineCreateWithoutTransferInput[] | StockTransferLineUncheckedCreateWithoutTransferInput[]
    connectOrCreate?: StockTransferLineCreateOrConnectWithoutTransferInput | StockTransferLineCreateOrConnectWithoutTransferInput[]
    upsert?: StockTransferLineUpsertWithWhereUniqueWithoutTransferInput | StockTransferLineUpsertWithWhereUniqueWithoutTransferInput[]
    createMany?: StockTransferLineCreateManyTransferInputEnvelope
    set?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    disconnect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    delete?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    connect?: StockTransferLineWhereUniqueInput | StockTransferLineWhereUniqueInput[]
    update?: StockTransferLineUpdateWithWhereUniqueWithoutTransferInput | StockTransferLineUpdateWithWhereUniqueWithoutTransferInput[]
    updateMany?: StockTransferLineUpdateManyWithWhereWithoutTransferInput | StockTransferLineUpdateManyWithWhereWithoutTransferInput[]
    deleteMany?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
  }

  export type StockTransferCreateNestedOneWithoutLineItemsInput = {
    create?: XOR<StockTransferCreateWithoutLineItemsInput, StockTransferUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutLineItemsInput
    connect?: StockTransferWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutStockTransferLinesInput = {
    create?: XOR<ProductVariantCreateWithoutStockTransferLinesInput, ProductVariantUncheckedCreateWithoutStockTransferLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockTransferLinesInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type StockTransferUpdateOneRequiredWithoutLineItemsNestedInput = {
    create?: XOR<StockTransferCreateWithoutLineItemsInput, StockTransferUncheckedCreateWithoutLineItemsInput>
    connectOrCreate?: StockTransferCreateOrConnectWithoutLineItemsInput
    upsert?: StockTransferUpsertWithoutLineItemsInput
    connect?: StockTransferWhereUniqueInput
    update?: XOR<XOR<StockTransferUpdateToOneWithWhereWithoutLineItemsInput, StockTransferUpdateWithoutLineItemsInput>, StockTransferUncheckedUpdateWithoutLineItemsInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutStockTransferLinesNestedInput = {
    create?: XOR<ProductVariantCreateWithoutStockTransferLinesInput, ProductVariantUncheckedCreateWithoutStockTransferLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutStockTransferLinesInput
    upsert?: ProductVariantUpsertWithoutStockTransferLinesInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutStockTransferLinesInput, ProductVariantUpdateWithoutStockTransferLinesInput>, ProductVariantUncheckedUpdateWithoutStockTransferLinesInput>
  }

  export type LocationCreateNestedOneWithoutSaleOrdersInput = {
    create?: XOR<LocationCreateWithoutSaleOrdersInput, LocationUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSaleOrdersInput
    connect?: LocationWhereUniqueInput
  }

  export type TerminalCreateNestedOneWithoutSaleOrdersInput = {
    create?: XOR<TerminalCreateWithoutSaleOrdersInput, TerminalUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSaleOrdersInput
    connect?: TerminalWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSaleOrdersInput = {
    create?: XOR<CustomerCreateWithoutSaleOrdersInput, CustomerUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSaleOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutSaleOrdersInput = {
    create?: XOR<ShiftCreateWithoutSaleOrdersInput, ShiftUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutSaleOrdersInput
    connect?: ShiftWhereUniqueInput
  }

  export type LocalUserCreateNestedOneWithoutSaleOrdersInput = {
    create?: XOR<LocalUserCreateWithoutSaleOrdersInput, LocalUserUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutSaleOrdersInput
    connect?: LocalUserWhereUniqueInput
  }

  export type SaleOrderLineCreateNestedManyWithoutOrderInput = {
    create?: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput> | SaleOrderLineCreateWithoutOrderInput[] | SaleOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutOrderInput | SaleOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: SaleOrderLineCreateManyOrderInputEnvelope
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DiscountCreateNestedManyWithoutOrderInput = {
    create?: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput> | DiscountCreateWithoutOrderInput[] | DiscountUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderInput | DiscountCreateOrConnectWithoutOrderInput[]
    createMany?: DiscountCreateManyOrderInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type ReturnOrderCreateNestedManyWithoutOriginalOrderInput = {
    create?: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput> | ReturnOrderCreateWithoutOriginalOrderInput[] | ReturnOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutOriginalOrderInput | ReturnOrderCreateOrConnectWithoutOriginalOrderInput[]
    createMany?: ReturnOrderCreateManyOriginalOrderInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type ParkedOrderCreateNestedManyWithoutOrderInput = {
    create?: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput> | ParkedOrderCreateWithoutOrderInput[] | ParkedOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ParkedOrderCreateOrConnectWithoutOrderInput | ParkedOrderCreateOrConnectWithoutOrderInput[]
    createMany?: ParkedOrderCreateManyOrderInputEnvelope
    connect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
  }

  export type ExchangeOrderCreateNestedManyWithoutOriginalOrderInput = {
    create?: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput> | ExchangeOrderCreateWithoutOriginalOrderInput[] | ExchangeOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutOriginalOrderInput | ExchangeOrderCreateOrConnectWithoutOriginalOrderInput[]
    createMany?: ExchangeOrderCreateManyOriginalOrderInputEnvelope
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
  }

  export type ExchangeOrderCreateNestedManyWithoutNewOrderInput = {
    create?: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput> | ExchangeOrderCreateWithoutNewOrderInput[] | ExchangeOrderUncheckedCreateWithoutNewOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutNewOrderInput | ExchangeOrderCreateOrConnectWithoutNewOrderInput[]
    createMany?: ExchangeOrderCreateManyNewOrderInputEnvelope
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
  }

  export type SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput> | SaleOrderLineCreateWithoutOrderInput[] | SaleOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutOrderInput | SaleOrderLineCreateOrConnectWithoutOrderInput[]
    createMany?: SaleOrderLineCreateManyOrderInputEnvelope
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DiscountUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput> | DiscountCreateWithoutOrderInput[] | DiscountUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderInput | DiscountCreateOrConnectWithoutOrderInput[]
    createMany?: DiscountCreateManyOrderInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput = {
    create?: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput> | ReturnOrderCreateWithoutOriginalOrderInput[] | ReturnOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutOriginalOrderInput | ReturnOrderCreateOrConnectWithoutOriginalOrderInput[]
    createMany?: ReturnOrderCreateManyOriginalOrderInputEnvelope
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
  }

  export type ParkedOrderUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput> | ParkedOrderCreateWithoutOrderInput[] | ParkedOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ParkedOrderCreateOrConnectWithoutOrderInput | ParkedOrderCreateOrConnectWithoutOrderInput[]
    createMany?: ParkedOrderCreateManyOrderInputEnvelope
    connect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
  }

  export type ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput = {
    create?: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput> | ExchangeOrderCreateWithoutOriginalOrderInput[] | ExchangeOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutOriginalOrderInput | ExchangeOrderCreateOrConnectWithoutOriginalOrderInput[]
    createMany?: ExchangeOrderCreateManyOriginalOrderInputEnvelope
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
  }

  export type ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput = {
    create?: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput> | ExchangeOrderCreateWithoutNewOrderInput[] | ExchangeOrderUncheckedCreateWithoutNewOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutNewOrderInput | ExchangeOrderCreateOrConnectWithoutNewOrderInput[]
    createMany?: ExchangeOrderCreateManyNewOrderInputEnvelope
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
  }

  export type EnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumOrderSourceFieldUpdateOperationsInput = {
    set?: $Enums.OrderSource
  }

  export type LocationUpdateOneRequiredWithoutSaleOrdersNestedInput = {
    create?: XOR<LocationCreateWithoutSaleOrdersInput, LocationUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutSaleOrdersInput
    upsert?: LocationUpsertWithoutSaleOrdersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutSaleOrdersInput, LocationUpdateWithoutSaleOrdersInput>, LocationUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type TerminalUpdateOneWithoutSaleOrdersNestedInput = {
    create?: XOR<TerminalCreateWithoutSaleOrdersInput, TerminalUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutSaleOrdersInput
    upsert?: TerminalUpsertWithoutSaleOrdersInput
    disconnect?: TerminalWhereInput | boolean
    delete?: TerminalWhereInput | boolean
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutSaleOrdersInput, TerminalUpdateWithoutSaleOrdersInput>, TerminalUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type CustomerUpdateOneWithoutSaleOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutSaleOrdersInput, CustomerUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSaleOrdersInput
    upsert?: CustomerUpsertWithoutSaleOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSaleOrdersInput, CustomerUpdateWithoutSaleOrdersInput>, CustomerUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type ShiftUpdateOneWithoutSaleOrdersNestedInput = {
    create?: XOR<ShiftCreateWithoutSaleOrdersInput, ShiftUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutSaleOrdersInput
    upsert?: ShiftUpsertWithoutSaleOrdersInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutSaleOrdersInput, ShiftUpdateWithoutSaleOrdersInput>, ShiftUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type LocalUserUpdateOneWithoutSaleOrdersNestedInput = {
    create?: XOR<LocalUserCreateWithoutSaleOrdersInput, LocalUserUncheckedCreateWithoutSaleOrdersInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutSaleOrdersInput
    upsert?: LocalUserUpsertWithoutSaleOrdersInput
    disconnect?: LocalUserWhereInput | boolean
    delete?: LocalUserWhereInput | boolean
    connect?: LocalUserWhereUniqueInput
    update?: XOR<XOR<LocalUserUpdateToOneWithWhereWithoutSaleOrdersInput, LocalUserUpdateWithoutSaleOrdersInput>, LocalUserUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type SaleOrderLineUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput> | SaleOrderLineCreateWithoutOrderInput[] | SaleOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutOrderInput | SaleOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: SaleOrderLineUpsertWithWhereUniqueWithoutOrderInput | SaleOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SaleOrderLineCreateManyOrderInputEnvelope
    set?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    disconnect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    delete?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    update?: SaleOrderLineUpdateWithWhereUniqueWithoutOrderInput | SaleOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SaleOrderLineUpdateManyWithWhereWithoutOrderInput | SaleOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DiscountUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput> | DiscountCreateWithoutOrderInput[] | DiscountUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderInput | DiscountCreateOrConnectWithoutOrderInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutOrderInput | DiscountUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DiscountCreateManyOrderInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutOrderInput | DiscountUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutOrderInput | DiscountUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type ReturnOrderUpdateManyWithoutOriginalOrderNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput> | ReturnOrderCreateWithoutOriginalOrderInput[] | ReturnOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutOriginalOrderInput | ReturnOrderCreateOrConnectWithoutOriginalOrderInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutOriginalOrderInput | ReturnOrderUpsertWithWhereUniqueWithoutOriginalOrderInput[]
    createMany?: ReturnOrderCreateManyOriginalOrderInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutOriginalOrderInput | ReturnOrderUpdateWithWhereUniqueWithoutOriginalOrderInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutOriginalOrderInput | ReturnOrderUpdateManyWithWhereWithoutOriginalOrderInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type ParkedOrderUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput> | ParkedOrderCreateWithoutOrderInput[] | ParkedOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ParkedOrderCreateOrConnectWithoutOrderInput | ParkedOrderCreateOrConnectWithoutOrderInput[]
    upsert?: ParkedOrderUpsertWithWhereUniqueWithoutOrderInput | ParkedOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ParkedOrderCreateManyOrderInputEnvelope
    set?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    disconnect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    delete?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    connect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    update?: ParkedOrderUpdateWithWhereUniqueWithoutOrderInput | ParkedOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ParkedOrderUpdateManyWithWhereWithoutOrderInput | ParkedOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ParkedOrderScalarWhereInput | ParkedOrderScalarWhereInput[]
  }

  export type ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput = {
    create?: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput> | ExchangeOrderCreateWithoutOriginalOrderInput[] | ExchangeOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutOriginalOrderInput | ExchangeOrderCreateOrConnectWithoutOriginalOrderInput[]
    upsert?: ExchangeOrderUpsertWithWhereUniqueWithoutOriginalOrderInput | ExchangeOrderUpsertWithWhereUniqueWithoutOriginalOrderInput[]
    createMany?: ExchangeOrderCreateManyOriginalOrderInputEnvelope
    set?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    disconnect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    delete?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    update?: ExchangeOrderUpdateWithWhereUniqueWithoutOriginalOrderInput | ExchangeOrderUpdateWithWhereUniqueWithoutOriginalOrderInput[]
    updateMany?: ExchangeOrderUpdateManyWithWhereWithoutOriginalOrderInput | ExchangeOrderUpdateManyWithWhereWithoutOriginalOrderInput[]
    deleteMany?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
  }

  export type ExchangeOrderUpdateManyWithoutNewOrderNestedInput = {
    create?: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput> | ExchangeOrderCreateWithoutNewOrderInput[] | ExchangeOrderUncheckedCreateWithoutNewOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutNewOrderInput | ExchangeOrderCreateOrConnectWithoutNewOrderInput[]
    upsert?: ExchangeOrderUpsertWithWhereUniqueWithoutNewOrderInput | ExchangeOrderUpsertWithWhereUniqueWithoutNewOrderInput[]
    createMany?: ExchangeOrderCreateManyNewOrderInputEnvelope
    set?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    disconnect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    delete?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    update?: ExchangeOrderUpdateWithWhereUniqueWithoutNewOrderInput | ExchangeOrderUpdateWithWhereUniqueWithoutNewOrderInput[]
    updateMany?: ExchangeOrderUpdateManyWithWhereWithoutNewOrderInput | ExchangeOrderUpdateManyWithWhereWithoutNewOrderInput[]
    deleteMany?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
  }

  export type SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput> | SaleOrderLineCreateWithoutOrderInput[] | SaleOrderLineUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SaleOrderLineCreateOrConnectWithoutOrderInput | SaleOrderLineCreateOrConnectWithoutOrderInput[]
    upsert?: SaleOrderLineUpsertWithWhereUniqueWithoutOrderInput | SaleOrderLineUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SaleOrderLineCreateManyOrderInputEnvelope
    set?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    disconnect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    delete?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    connect?: SaleOrderLineWhereUniqueInput | SaleOrderLineWhereUniqueInput[]
    update?: SaleOrderLineUpdateWithWhereUniqueWithoutOrderInput | SaleOrderLineUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SaleOrderLineUpdateManyWithWhereWithoutOrderInput | SaleOrderLineUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput> | PaymentCreateWithoutOrderInput[] | PaymentUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput | PaymentCreateOrConnectWithoutOrderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutOrderInput | PaymentUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: PaymentCreateManyOrderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutOrderInput | PaymentUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutOrderInput | PaymentUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type DiscountUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput> | DiscountCreateWithoutOrderInput[] | DiscountUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderInput | DiscountCreateOrConnectWithoutOrderInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutOrderInput | DiscountUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DiscountCreateManyOrderInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutOrderInput | DiscountUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutOrderInput | DiscountUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput> | ReturnOrderCreateWithoutOriginalOrderInput[] | ReturnOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutOriginalOrderInput | ReturnOrderCreateOrConnectWithoutOriginalOrderInput[]
    upsert?: ReturnOrderUpsertWithWhereUniqueWithoutOriginalOrderInput | ReturnOrderUpsertWithWhereUniqueWithoutOriginalOrderInput[]
    createMany?: ReturnOrderCreateManyOriginalOrderInputEnvelope
    set?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    disconnect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    delete?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    connect?: ReturnOrderWhereUniqueInput | ReturnOrderWhereUniqueInput[]
    update?: ReturnOrderUpdateWithWhereUniqueWithoutOriginalOrderInput | ReturnOrderUpdateWithWhereUniqueWithoutOriginalOrderInput[]
    updateMany?: ReturnOrderUpdateManyWithWhereWithoutOriginalOrderInput | ReturnOrderUpdateManyWithWhereWithoutOriginalOrderInput[]
    deleteMany?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
  }

  export type ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput> | ParkedOrderCreateWithoutOrderInput[] | ParkedOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ParkedOrderCreateOrConnectWithoutOrderInput | ParkedOrderCreateOrConnectWithoutOrderInput[]
    upsert?: ParkedOrderUpsertWithWhereUniqueWithoutOrderInput | ParkedOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ParkedOrderCreateManyOrderInputEnvelope
    set?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    disconnect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    delete?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    connect?: ParkedOrderWhereUniqueInput | ParkedOrderWhereUniqueInput[]
    update?: ParkedOrderUpdateWithWhereUniqueWithoutOrderInput | ParkedOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ParkedOrderUpdateManyWithWhereWithoutOrderInput | ParkedOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ParkedOrderScalarWhereInput | ParkedOrderScalarWhereInput[]
  }

  export type ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput = {
    create?: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput> | ExchangeOrderCreateWithoutOriginalOrderInput[] | ExchangeOrderUncheckedCreateWithoutOriginalOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutOriginalOrderInput | ExchangeOrderCreateOrConnectWithoutOriginalOrderInput[]
    upsert?: ExchangeOrderUpsertWithWhereUniqueWithoutOriginalOrderInput | ExchangeOrderUpsertWithWhereUniqueWithoutOriginalOrderInput[]
    createMany?: ExchangeOrderCreateManyOriginalOrderInputEnvelope
    set?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    disconnect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    delete?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    update?: ExchangeOrderUpdateWithWhereUniqueWithoutOriginalOrderInput | ExchangeOrderUpdateWithWhereUniqueWithoutOriginalOrderInput[]
    updateMany?: ExchangeOrderUpdateManyWithWhereWithoutOriginalOrderInput | ExchangeOrderUpdateManyWithWhereWithoutOriginalOrderInput[]
    deleteMany?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
  }

  export type ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput = {
    create?: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput> | ExchangeOrderCreateWithoutNewOrderInput[] | ExchangeOrderUncheckedCreateWithoutNewOrderInput[]
    connectOrCreate?: ExchangeOrderCreateOrConnectWithoutNewOrderInput | ExchangeOrderCreateOrConnectWithoutNewOrderInput[]
    upsert?: ExchangeOrderUpsertWithWhereUniqueWithoutNewOrderInput | ExchangeOrderUpsertWithWhereUniqueWithoutNewOrderInput[]
    createMany?: ExchangeOrderCreateManyNewOrderInputEnvelope
    set?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    disconnect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    delete?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    connect?: ExchangeOrderWhereUniqueInput | ExchangeOrderWhereUniqueInput[]
    update?: ExchangeOrderUpdateWithWhereUniqueWithoutNewOrderInput | ExchangeOrderUpdateWithWhereUniqueWithoutNewOrderInput[]
    updateMany?: ExchangeOrderUpdateManyWithWhereWithoutNewOrderInput | ExchangeOrderUpdateManyWithWhereWithoutNewOrderInput[]
    deleteMany?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
  }

  export type SaleOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<SaleOrderCreateWithoutLinesInput, SaleOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLinesInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutSaleOrderLinesInput = {
    create?: XOR<ProductVariantCreateWithoutSaleOrderLinesInput, ProductVariantUncheckedCreateWithoutSaleOrderLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutSaleOrderLinesInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type SaleOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<SaleOrderCreateWithoutLinesInput, SaleOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutLinesInput
    upsert?: SaleOrderUpsertWithoutLinesInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutLinesInput, SaleOrderUpdateWithoutLinesInput>, SaleOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutSaleOrderLinesNestedInput = {
    create?: XOR<ProductVariantCreateWithoutSaleOrderLinesInput, ProductVariantUncheckedCreateWithoutSaleOrderLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutSaleOrderLinesInput
    upsert?: ProductVariantUpsertWithoutSaleOrderLinesInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutSaleOrderLinesInput, ProductVariantUpdateWithoutSaleOrderLinesInput>, ProductVariantUncheckedUpdateWithoutSaleOrderLinesInput>
  }

  export type SaleOrderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SaleOrderCreateWithoutPaymentsInput, SaleOrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutPaymentsInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type SaleOrderUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SaleOrderCreateWithoutPaymentsInput, SaleOrderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutPaymentsInput
    upsert?: SaleOrderUpsertWithoutPaymentsInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutPaymentsInput, SaleOrderUpdateWithoutPaymentsInput>, SaleOrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleOrderCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<SaleOrderCreateWithoutDiscountsInput, SaleOrderUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutDiscountsInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type SaleOrderUpdateOneRequiredWithoutDiscountsNestedInput = {
    create?: XOR<SaleOrderCreateWithoutDiscountsInput, SaleOrderUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutDiscountsInput
    upsert?: SaleOrderUpsertWithoutDiscountsInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutDiscountsInput, SaleOrderUpdateWithoutDiscountsInput>, SaleOrderUncheckedUpdateWithoutDiscountsInput>
  }

  export type SaleOrderCreateNestedOneWithoutReturnOrdersInput = {
    create?: XOR<SaleOrderCreateWithoutReturnOrdersInput, SaleOrderUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutReturnOrdersInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutReturnOrdersInput = {
    create?: XOR<CustomerCreateWithoutReturnOrdersInput, CustomerUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnOrdersInput
    connect?: CustomerWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutReturnOrdersInput = {
    create?: XOR<LocationCreateWithoutReturnOrdersInput, LocationUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReturnOrdersInput
    connect?: LocationWhereUniqueInput
  }

  export type ReturnOrderLineCreateNestedManyWithoutReturnOrderInput = {
    create?: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput> | ReturnOrderLineCreateWithoutReturnOrderInput[] | ReturnOrderLineUncheckedCreateWithoutReturnOrderInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutReturnOrderInput | ReturnOrderLineCreateOrConnectWithoutReturnOrderInput[]
    createMany?: ReturnOrderLineCreateManyReturnOrderInputEnvelope
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
  }

  export type ReturnOrderLineUncheckedCreateNestedManyWithoutReturnOrderInput = {
    create?: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput> | ReturnOrderLineCreateWithoutReturnOrderInput[] | ReturnOrderLineUncheckedCreateWithoutReturnOrderInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutReturnOrderInput | ReturnOrderLineCreateOrConnectWithoutReturnOrderInput[]
    createMany?: ReturnOrderLineCreateManyReturnOrderInputEnvelope
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
  }

  export type NullableEnumReturnReasonFieldUpdateOperationsInput = {
    set?: $Enums.ReturnReason | null
  }

  export type NullableEnumRefundMethodFieldUpdateOperationsInput = {
    set?: $Enums.RefundMethod | null
  }

  export type EnumReturnStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReturnStatus
  }

  export type SaleOrderUpdateOneRequiredWithoutReturnOrdersNestedInput = {
    create?: XOR<SaleOrderCreateWithoutReturnOrdersInput, SaleOrderUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutReturnOrdersInput
    upsert?: SaleOrderUpsertWithoutReturnOrdersInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutReturnOrdersInput, SaleOrderUpdateWithoutReturnOrdersInput>, SaleOrderUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type CustomerUpdateOneWithoutReturnOrdersNestedInput = {
    create?: XOR<CustomerCreateWithoutReturnOrdersInput, CustomerUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutReturnOrdersInput
    upsert?: CustomerUpsertWithoutReturnOrdersInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutReturnOrdersInput, CustomerUpdateWithoutReturnOrdersInput>, CustomerUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type LocationUpdateOneRequiredWithoutReturnOrdersNestedInput = {
    create?: XOR<LocationCreateWithoutReturnOrdersInput, LocationUncheckedCreateWithoutReturnOrdersInput>
    connectOrCreate?: LocationCreateOrConnectWithoutReturnOrdersInput
    upsert?: LocationUpsertWithoutReturnOrdersInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutReturnOrdersInput, LocationUpdateWithoutReturnOrdersInput>, LocationUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type ReturnOrderLineUpdateManyWithoutReturnOrderNestedInput = {
    create?: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput> | ReturnOrderLineCreateWithoutReturnOrderInput[] | ReturnOrderLineUncheckedCreateWithoutReturnOrderInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutReturnOrderInput | ReturnOrderLineCreateOrConnectWithoutReturnOrderInput[]
    upsert?: ReturnOrderLineUpsertWithWhereUniqueWithoutReturnOrderInput | ReturnOrderLineUpsertWithWhereUniqueWithoutReturnOrderInput[]
    createMany?: ReturnOrderLineCreateManyReturnOrderInputEnvelope
    set?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    disconnect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    delete?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    update?: ReturnOrderLineUpdateWithWhereUniqueWithoutReturnOrderInput | ReturnOrderLineUpdateWithWhereUniqueWithoutReturnOrderInput[]
    updateMany?: ReturnOrderLineUpdateManyWithWhereWithoutReturnOrderInput | ReturnOrderLineUpdateManyWithWhereWithoutReturnOrderInput[]
    deleteMany?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
  }

  export type ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderNestedInput = {
    create?: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput> | ReturnOrderLineCreateWithoutReturnOrderInput[] | ReturnOrderLineUncheckedCreateWithoutReturnOrderInput[]
    connectOrCreate?: ReturnOrderLineCreateOrConnectWithoutReturnOrderInput | ReturnOrderLineCreateOrConnectWithoutReturnOrderInput[]
    upsert?: ReturnOrderLineUpsertWithWhereUniqueWithoutReturnOrderInput | ReturnOrderLineUpsertWithWhereUniqueWithoutReturnOrderInput[]
    createMany?: ReturnOrderLineCreateManyReturnOrderInputEnvelope
    set?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    disconnect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    delete?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    connect?: ReturnOrderLineWhereUniqueInput | ReturnOrderLineWhereUniqueInput[]
    update?: ReturnOrderLineUpdateWithWhereUniqueWithoutReturnOrderInput | ReturnOrderLineUpdateWithWhereUniqueWithoutReturnOrderInput[]
    updateMany?: ReturnOrderLineUpdateManyWithWhereWithoutReturnOrderInput | ReturnOrderLineUpdateManyWithWhereWithoutReturnOrderInput[]
    deleteMany?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
  }

  export type ReturnOrderCreateNestedOneWithoutLinesInput = {
    create?: XOR<ReturnOrderCreateWithoutLinesInput, ReturnOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLinesInput
    connect?: ReturnOrderWhereUniqueInput
  }

  export type ProductVariantCreateNestedOneWithoutReturnOrderLinesInput = {
    create?: XOR<ProductVariantCreateWithoutReturnOrderLinesInput, ProductVariantUncheckedCreateWithoutReturnOrderLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutReturnOrderLinesInput
    connect?: ProductVariantWhereUniqueInput
  }

  export type ReturnOrderUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<ReturnOrderCreateWithoutLinesInput, ReturnOrderUncheckedCreateWithoutLinesInput>
    connectOrCreate?: ReturnOrderCreateOrConnectWithoutLinesInput
    upsert?: ReturnOrderUpsertWithoutLinesInput
    connect?: ReturnOrderWhereUniqueInput
    update?: XOR<XOR<ReturnOrderUpdateToOneWithWhereWithoutLinesInput, ReturnOrderUpdateWithoutLinesInput>, ReturnOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ProductVariantUpdateOneRequiredWithoutReturnOrderLinesNestedInput = {
    create?: XOR<ProductVariantCreateWithoutReturnOrderLinesInput, ProductVariantUncheckedCreateWithoutReturnOrderLinesInput>
    connectOrCreate?: ProductVariantCreateOrConnectWithoutReturnOrderLinesInput
    upsert?: ProductVariantUpsertWithoutReturnOrderLinesInput
    connect?: ProductVariantWhereUniqueInput
    update?: XOR<XOR<ProductVariantUpdateToOneWithWhereWithoutReturnOrderLinesInput, ProductVariantUpdateWithoutReturnOrderLinesInput>, ProductVariantUncheckedUpdateWithoutReturnOrderLinesInput>
  }

  export type SaleOrderCreateNestedOneWithoutExchangesFromInput = {
    create?: XOR<SaleOrderCreateWithoutExchangesFromInput, SaleOrderUncheckedCreateWithoutExchangesFromInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutExchangesFromInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type SaleOrderCreateNestedOneWithoutExchangesToInput = {
    create?: XOR<SaleOrderCreateWithoutExchangesToInput, SaleOrderUncheckedCreateWithoutExchangesToInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutExchangesToInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type SaleOrderUpdateOneRequiredWithoutExchangesFromNestedInput = {
    create?: XOR<SaleOrderCreateWithoutExchangesFromInput, SaleOrderUncheckedCreateWithoutExchangesFromInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutExchangesFromInput
    upsert?: SaleOrderUpsertWithoutExchangesFromInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutExchangesFromInput, SaleOrderUpdateWithoutExchangesFromInput>, SaleOrderUncheckedUpdateWithoutExchangesFromInput>
  }

  export type SaleOrderUpdateOneRequiredWithoutExchangesToNestedInput = {
    create?: XOR<SaleOrderCreateWithoutExchangesToInput, SaleOrderUncheckedCreateWithoutExchangesToInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutExchangesToInput
    upsert?: SaleOrderUpsertWithoutExchangesToInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutExchangesToInput, SaleOrderUpdateWithoutExchangesToInput>, SaleOrderUncheckedUpdateWithoutExchangesToInput>
  }

  export type SaleOrderCreateNestedOneWithoutParkedOrdersInput = {
    create?: XOR<SaleOrderCreateWithoutParkedOrdersInput, SaleOrderUncheckedCreateWithoutParkedOrdersInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutParkedOrdersInput
    connect?: SaleOrderWhereUniqueInput
  }

  export type SaleOrderUpdateOneRequiredWithoutParkedOrdersNestedInput = {
    create?: XOR<SaleOrderCreateWithoutParkedOrdersInput, SaleOrderUncheckedCreateWithoutParkedOrdersInput>
    connectOrCreate?: SaleOrderCreateOrConnectWithoutParkedOrdersInput
    upsert?: SaleOrderUpsertWithoutParkedOrdersInput
    connect?: SaleOrderWhereUniqueInput
    update?: XOR<XOR<SaleOrderUpdateToOneWithWhereWithoutParkedOrdersInput, SaleOrderUpdateWithoutParkedOrdersInput>, SaleOrderUncheckedUpdateWithoutParkedOrdersInput>
  }

  export type LocationCreateNestedOneWithoutShiftsInput = {
    create?: XOR<LocationCreateWithoutShiftsInput, LocationUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutShiftsInput
    connect?: LocationWhereUniqueInput
  }

  export type TerminalCreateNestedOneWithoutShiftsInput = {
    create?: XOR<TerminalCreateWithoutShiftsInput, TerminalUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutShiftsInput
    connect?: TerminalWhereUniqueInput
  }

  export type LocalUserCreateNestedOneWithoutShiftsInput = {
    create?: XOR<LocalUserCreateWithoutShiftsInput, LocalUserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutShiftsInput
    connect?: LocalUserWhereUniqueInput
  }

  export type SaleOrderCreateNestedManyWithoutShiftInput = {
    create?: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput> | SaleOrderCreateWithoutShiftInput[] | SaleOrderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutShiftInput | SaleOrderCreateOrConnectWithoutShiftInput[]
    createMany?: SaleOrderCreateManyShiftInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type SaleOrderUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput> | SaleOrderCreateWithoutShiftInput[] | SaleOrderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutShiftInput | SaleOrderCreateOrConnectWithoutShiftInput[]
    createMany?: SaleOrderCreateManyShiftInputEnvelope
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
  }

  export type EnumShiftStatusFieldUpdateOperationsInput = {
    set?: $Enums.ShiftStatus
  }

  export type LocationUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<LocationCreateWithoutShiftsInput, LocationUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutShiftsInput
    upsert?: LocationUpsertWithoutShiftsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutShiftsInput, LocationUpdateWithoutShiftsInput>, LocationUncheckedUpdateWithoutShiftsInput>
  }

  export type TerminalUpdateOneWithoutShiftsNestedInput = {
    create?: XOR<TerminalCreateWithoutShiftsInput, TerminalUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutShiftsInput
    upsert?: TerminalUpsertWithoutShiftsInput
    disconnect?: TerminalWhereInput | boolean
    delete?: TerminalWhereInput | boolean
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutShiftsInput, TerminalUpdateWithoutShiftsInput>, TerminalUncheckedUpdateWithoutShiftsInput>
  }

  export type LocalUserUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<LocalUserCreateWithoutShiftsInput, LocalUserUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: LocalUserCreateOrConnectWithoutShiftsInput
    upsert?: LocalUserUpsertWithoutShiftsInput
    connect?: LocalUserWhereUniqueInput
    update?: XOR<XOR<LocalUserUpdateToOneWithWhereWithoutShiftsInput, LocalUserUpdateWithoutShiftsInput>, LocalUserUncheckedUpdateWithoutShiftsInput>
  }

  export type SaleOrderUpdateManyWithoutShiftNestedInput = {
    create?: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput> | SaleOrderCreateWithoutShiftInput[] | SaleOrderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutShiftInput | SaleOrderCreateOrConnectWithoutShiftInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutShiftInput | SaleOrderUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: SaleOrderCreateManyShiftInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutShiftInput | SaleOrderUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutShiftInput | SaleOrderUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type SaleOrderUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput> | SaleOrderCreateWithoutShiftInput[] | SaleOrderUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: SaleOrderCreateOrConnectWithoutShiftInput | SaleOrderCreateOrConnectWithoutShiftInput[]
    upsert?: SaleOrderUpsertWithWhereUniqueWithoutShiftInput | SaleOrderUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: SaleOrderCreateManyShiftInputEnvelope
    set?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    disconnect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    delete?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    connect?: SaleOrderWhereUniqueInput | SaleOrderWhereUniqueInput[]
    update?: SaleOrderUpdateWithWhereUniqueWithoutShiftInput | SaleOrderUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: SaleOrderUpdateManyWithWhereWithoutShiftInput | SaleOrderUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutTaxCategoryInput = {
    create?: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput> | ProductCreateWithoutTaxCategoryInput[] | ProductUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTaxCategoryInput | ProductCreateOrConnectWithoutTaxCategoryInput[]
    createMany?: ProductCreateManyTaxCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TaxRateCreateNestedManyWithoutTaxCategoryInput = {
    create?: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput> | TaxRateCreateWithoutTaxCategoryInput[] | TaxRateUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: TaxRateCreateOrConnectWithoutTaxCategoryInput | TaxRateCreateOrConnectWithoutTaxCategoryInput[]
    createMany?: TaxRateCreateManyTaxCategoryInputEnvelope
    connect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutTaxCategoryInput = {
    create?: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput> | ProductCreateWithoutTaxCategoryInput[] | ProductUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTaxCategoryInput | ProductCreateOrConnectWithoutTaxCategoryInput[]
    createMany?: ProductCreateManyTaxCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type TaxRateUncheckedCreateNestedManyWithoutTaxCategoryInput = {
    create?: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput> | TaxRateCreateWithoutTaxCategoryInput[] | TaxRateUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: TaxRateCreateOrConnectWithoutTaxCategoryInput | TaxRateCreateOrConnectWithoutTaxCategoryInput[]
    createMany?: TaxRateCreateManyTaxCategoryInputEnvelope
    connect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutTaxCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput> | ProductCreateWithoutTaxCategoryInput[] | ProductUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTaxCategoryInput | ProductCreateOrConnectWithoutTaxCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTaxCategoryInput | ProductUpsertWithWhereUniqueWithoutTaxCategoryInput[]
    createMany?: ProductCreateManyTaxCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTaxCategoryInput | ProductUpdateWithWhereUniqueWithoutTaxCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTaxCategoryInput | ProductUpdateManyWithWhereWithoutTaxCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TaxRateUpdateManyWithoutTaxCategoryNestedInput = {
    create?: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput> | TaxRateCreateWithoutTaxCategoryInput[] | TaxRateUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: TaxRateCreateOrConnectWithoutTaxCategoryInput | TaxRateCreateOrConnectWithoutTaxCategoryInput[]
    upsert?: TaxRateUpsertWithWhereUniqueWithoutTaxCategoryInput | TaxRateUpsertWithWhereUniqueWithoutTaxCategoryInput[]
    createMany?: TaxRateCreateManyTaxCategoryInputEnvelope
    set?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    disconnect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    delete?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    connect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    update?: TaxRateUpdateWithWhereUniqueWithoutTaxCategoryInput | TaxRateUpdateWithWhereUniqueWithoutTaxCategoryInput[]
    updateMany?: TaxRateUpdateManyWithWhereWithoutTaxCategoryInput | TaxRateUpdateManyWithWhereWithoutTaxCategoryInput[]
    deleteMany?: TaxRateScalarWhereInput | TaxRateScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutTaxCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput> | ProductCreateWithoutTaxCategoryInput[] | ProductUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutTaxCategoryInput | ProductCreateOrConnectWithoutTaxCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutTaxCategoryInput | ProductUpsertWithWhereUniqueWithoutTaxCategoryInput[]
    createMany?: ProductCreateManyTaxCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutTaxCategoryInput | ProductUpdateWithWhereUniqueWithoutTaxCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutTaxCategoryInput | ProductUpdateManyWithWhereWithoutTaxCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type TaxRateUncheckedUpdateManyWithoutTaxCategoryNestedInput = {
    create?: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput> | TaxRateCreateWithoutTaxCategoryInput[] | TaxRateUncheckedCreateWithoutTaxCategoryInput[]
    connectOrCreate?: TaxRateCreateOrConnectWithoutTaxCategoryInput | TaxRateCreateOrConnectWithoutTaxCategoryInput[]
    upsert?: TaxRateUpsertWithWhereUniqueWithoutTaxCategoryInput | TaxRateUpsertWithWhereUniqueWithoutTaxCategoryInput[]
    createMany?: TaxRateCreateManyTaxCategoryInputEnvelope
    set?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    disconnect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    delete?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    connect?: TaxRateWhereUniqueInput | TaxRateWhereUniqueInput[]
    update?: TaxRateUpdateWithWhereUniqueWithoutTaxCategoryInput | TaxRateUpdateWithWhereUniqueWithoutTaxCategoryInput[]
    updateMany?: TaxRateUpdateManyWithWhereWithoutTaxCategoryInput | TaxRateUpdateManyWithWhereWithoutTaxCategoryInput[]
    deleteMany?: TaxRateScalarWhereInput | TaxRateScalarWhereInput[]
  }

  export type TaxCategoryCreateNestedOneWithoutRatesInput = {
    create?: XOR<TaxCategoryCreateWithoutRatesInput, TaxCategoryUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TaxCategoryCreateOrConnectWithoutRatesInput
    connect?: TaxCategoryWhereUniqueInput
  }

  export type TaxCategoryUpdateOneRequiredWithoutRatesNestedInput = {
    create?: XOR<TaxCategoryCreateWithoutRatesInput, TaxCategoryUncheckedCreateWithoutRatesInput>
    connectOrCreate?: TaxCategoryCreateOrConnectWithoutRatesInput
    upsert?: TaxCategoryUpsertWithoutRatesInput
    connect?: TaxCategoryWhereUniqueInput
    update?: XOR<XOR<TaxCategoryUpdateToOneWithWhereWithoutRatesInput, TaxCategoryUpdateWithoutRatesInput>, TaxCategoryUncheckedUpdateWithoutRatesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumOperationModeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationModeType | EnumOperationModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationModeType[]
    notIn?: $Enums.OperationModeType[]
    not?: NestedEnumOperationModeTypeFilter<$PrismaModel> | $Enums.OperationModeType
  }

  export type NestedEnumOperationModeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperationModeType | EnumOperationModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperationModeType[]
    notIn?: $Enums.OperationModeType[]
    not?: NestedEnumOperationModeTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperationModeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperationModeTypeFilter<$PrismaModel>
    _max?: NestedEnumOperationModeTypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumSyncOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationFilter<$PrismaModel> | $Enums.SyncOperation
  }

  export type NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncOperation | EnumSyncOperationFieldRefInput<$PrismaModel>
    in?: $Enums.SyncOperation[]
    notIn?: $Enums.SyncOperation[]
    not?: NestedEnumSyncOperationWithAggregatesFilter<$PrismaModel> | $Enums.SyncOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncOperationFilter<$PrismaModel>
    _max?: NestedEnumSyncOperationFilter<$PrismaModel>
  }

  export type NestedEnumSyncTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[]
    notIn?: $Enums.SyncType[]
    not?: NestedEnumSyncTypeFilter<$PrismaModel> | $Enums.SyncType
  }

  export type NestedEnumSyncDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncDirection | EnumSyncDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncDirection[]
    notIn?: $Enums.SyncDirection[]
    not?: NestedEnumSyncDirectionFilter<$PrismaModel> | $Enums.SyncDirection
  }

  export type NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncType | EnumSyncTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SyncType[]
    notIn?: $Enums.SyncType[]
    not?: NestedEnumSyncTypeWithAggregatesFilter<$PrismaModel> | $Enums.SyncType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncTypeFilter<$PrismaModel>
    _max?: NestedEnumSyncTypeFilter<$PrismaModel>
  }

  export type NestedEnumSyncDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SyncDirection | EnumSyncDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.SyncDirection[]
    notIn?: $Enums.SyncDirection[]
    not?: NestedEnumSyncDirectionWithAggregatesFilter<$PrismaModel> | $Enums.SyncDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSyncDirectionFilter<$PrismaModel>
    _max?: NestedEnumSyncDirectionFilter<$PrismaModel>
  }

  export type NestedEnumLocationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeFilter<$PrismaModel> | $Enums.LocationType
  }

  export type NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LocationType | EnumLocationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LocationType[]
    notIn?: $Enums.LocationType[]
    not?: NestedEnumLocationTypeWithAggregatesFilter<$PrismaModel> | $Enums.LocationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLocationTypeFilter<$PrismaModel>
    _max?: NestedEnumLocationTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumProductTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeFilter<$PrismaModel> | $Enums.ProductType
  }

  export type NestedEnumProductTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductType | EnumProductTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProductType[]
    notIn?: $Enums.ProductType[]
    not?: NestedEnumProductTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProductType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductTypeFilter<$PrismaModel>
    _max?: NestedEnumProductTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCustomerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeFilter<$PrismaModel> | $Enums.CustomerType
  }

  export type NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerType | EnumCustomerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerType[]
    notIn?: $Enums.CustomerType[]
    not?: NestedEnumCustomerTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerTypeFilter<$PrismaModel>
  }

  export type NestedEnumAddressTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[]
    notIn?: $Enums.AddressType[]
    not?: NestedEnumAddressTypeFilter<$PrismaModel> | $Enums.AddressType
  }

  export type NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AddressType | EnumAddressTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AddressType[]
    notIn?: $Enums.AddressType[]
    not?: NestedEnumAddressTypeWithAggregatesFilter<$PrismaModel> | $Enums.AddressType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAddressTypeFilter<$PrismaModel>
    _max?: NestedEnumAddressTypeFilter<$PrismaModel>
  }

  export type NestedEnumStockAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StockAdjustmentType | EnumStockAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockAdjustmentType[]
    notIn?: $Enums.StockAdjustmentType[]
    not?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel> | $Enums.StockAdjustmentType
  }

  export type NestedEnumStockAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StockAdjustmentType | EnumStockAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StockAdjustmentType[]
    notIn?: $Enums.StockAdjustmentType[]
    not?: NestedEnumStockAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.StockAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumStockAdjustmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransferStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusFilter<$PrismaModel> | $Enums.TransferStatus
  }

  export type NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransferStatus | EnumTransferStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransferStatus[]
    notIn?: $Enums.TransferStatus[]
    not?: NestedEnumTransferStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransferStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransferStatusFilter<$PrismaModel>
    _max?: NestedEnumTransferStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[]
    notIn?: $Enums.OrderSource[]
    not?: NestedEnumOrderSourceFilter<$PrismaModel> | $Enums.OrderSource
  }

  export type NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[]
    notIn?: $Enums.OrderType[]
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[]
    notIn?: $Enums.OrderStatus[]
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSource | EnumOrderSourceFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSource[]
    notIn?: $Enums.OrderSource[]
    not?: NestedEnumOrderSourceWithAggregatesFilter<$PrismaModel> | $Enums.OrderSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSourceFilter<$PrismaModel>
    _max?: NestedEnumOrderSourceFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[]
    notIn?: $Enums.DiscountType[]
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumReturnReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReturnReason[] | null
    notIn?: $Enums.ReturnReason[] | null
    not?: NestedEnumReturnReasonNullableFilter<$PrismaModel> | $Enums.ReturnReason | null
  }

  export type NestedEnumRefundMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | null
    notIn?: $Enums.RefundMethod[] | null
    not?: NestedEnumRefundMethodNullableFilter<$PrismaModel> | $Enums.RefundMethod | null
  }

  export type NestedEnumReturnStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[]
    notIn?: $Enums.ReturnStatus[]
    not?: NestedEnumReturnStatusFilter<$PrismaModel> | $Enums.ReturnStatus
  }

  export type NestedEnumReturnReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnReason | EnumReturnReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReturnReason[] | null
    notIn?: $Enums.ReturnReason[] | null
    not?: NestedEnumReturnReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReturnReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReturnReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumReturnReasonNullableFilter<$PrismaModel>
  }

  export type NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundMethod | EnumRefundMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.RefundMethod[] | null
    notIn?: $Enums.RefundMethod[] | null
    not?: NestedEnumRefundMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.RefundMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumRefundMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReturnStatus | EnumReturnStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReturnStatus[]
    notIn?: $Enums.ReturnStatus[]
    not?: NestedEnumReturnStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReturnStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReturnStatusFilter<$PrismaModel>
    _max?: NestedEnumReturnStatusFilter<$PrismaModel>
  }

  export type NestedEnumShiftStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[]
    notIn?: $Enums.ShiftStatus[]
    not?: NestedEnumShiftStatusFilter<$PrismaModel> | $Enums.ShiftStatus
  }

  export type NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShiftStatus | EnumShiftStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ShiftStatus[]
    notIn?: $Enums.ShiftStatus[]
    not?: NestedEnumShiftStatusWithAggregatesFilter<$PrismaModel> | $Enums.ShiftStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShiftStatusFilter<$PrismaModel>
    _max?: NestedEnumShiftStatusFilter<$PrismaModel>
  }

  export type TerminalSessionCreateWithoutTerminalInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
  }

  export type TerminalSessionUncheckedCreateWithoutTerminalInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
  }

  export type TerminalSessionCreateOrConnectWithoutTerminalInput = {
    where: TerminalSessionWhereUniqueInput
    create: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput>
  }

  export type TerminalSessionCreateManyTerminalInputEnvelope = {
    data: TerminalSessionCreateManyTerminalInput | TerminalSessionCreateManyTerminalInput[]
  }

  export type OperationModeCreateWithoutTerminalInput = {
    id?: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
  }

  export type OperationModeUncheckedCreateWithoutTerminalInput = {
    id?: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
  }

  export type OperationModeCreateOrConnectWithoutTerminalInput = {
    where: OperationModeWhereUniqueInput
    create: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput>
  }

  export type OperationModeCreateManyTerminalInputEnvelope = {
    data: OperationModeCreateManyTerminalInput | OperationModeCreateManyTerminalInput[]
  }

  export type ConnectionLogCreateWithoutTerminalInput = {
    id?: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
  }

  export type ConnectionLogUncheckedCreateWithoutTerminalInput = {
    id?: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
  }

  export type ConnectionLogCreateOrConnectWithoutTerminalInput = {
    where: ConnectionLogWhereUniqueInput
    create: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput>
  }

  export type ConnectionLogCreateManyTerminalInputEnvelope = {
    data: ConnectionLogCreateManyTerminalInput | ConnectionLogCreateManyTerminalInput[]
  }

  export type UserSessionCreateWithoutTerminalInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    user: LocalUserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutTerminalInput = {
    id?: string
    userId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type UserSessionCreateOrConnectWithoutTerminalInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput>
  }

  export type UserSessionCreateManyTerminalInputEnvelope = {
    data: UserSessionCreateManyTerminalInput | UserSessionCreateManyTerminalInput[]
  }

  export type OutboxCreateWithoutTerminalInput = {
    id?: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
  }

  export type OutboxUncheckedCreateWithoutTerminalInput = {
    id?: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
  }

  export type OutboxCreateOrConnectWithoutTerminalInput = {
    where: OutboxWhereUniqueInput
    create: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput>
  }

  export type OutboxCreateManyTerminalInputEnvelope = {
    data: OutboxCreateManyTerminalInput | OutboxCreateManyTerminalInput[]
  }

  export type SyncHistoryCreateWithoutTerminalInput = {
    id?: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
  }

  export type SyncHistoryUncheckedCreateWithoutTerminalInput = {
    id?: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
  }

  export type SyncHistoryCreateOrConnectWithoutTerminalInput = {
    where: SyncHistoryWhereUniqueInput
    create: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput>
  }

  export type SyncHistoryCreateManyTerminalInputEnvelope = {
    data: SyncHistoryCreateManyTerminalInput | SyncHistoryCreateManyTerminalInput[]
  }

  export type SaleOrderCreateWithoutTerminalInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutTerminalInput = {
    id?: string
    locationId: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutTerminalInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput>
  }

  export type SaleOrderCreateManyTerminalInputEnvelope = {
    data: SaleOrderCreateManyTerminalInput | SaleOrderCreateManyTerminalInput[]
  }

  export type ShiftCreateWithoutTerminalInput = {
    id?: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    location: LocationCreateNestedOneWithoutShiftsInput
    user: LocalUserCreateNestedOneWithoutShiftsInput
    saleOrders?: SaleOrderCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutTerminalInput = {
    id?: string
    locationId: string
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutTerminalInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput>
  }

  export type ShiftCreateManyTerminalInputEnvelope = {
    data: ShiftCreateManyTerminalInput | ShiftCreateManyTerminalInput[]
  }

  export type TerminalSessionUpsertWithWhereUniqueWithoutTerminalInput = {
    where: TerminalSessionWhereUniqueInput
    update: XOR<TerminalSessionUpdateWithoutTerminalInput, TerminalSessionUncheckedUpdateWithoutTerminalInput>
    create: XOR<TerminalSessionCreateWithoutTerminalInput, TerminalSessionUncheckedCreateWithoutTerminalInput>
  }

  export type TerminalSessionUpdateWithWhereUniqueWithoutTerminalInput = {
    where: TerminalSessionWhereUniqueInput
    data: XOR<TerminalSessionUpdateWithoutTerminalInput, TerminalSessionUncheckedUpdateWithoutTerminalInput>
  }

  export type TerminalSessionUpdateManyWithWhereWithoutTerminalInput = {
    where: TerminalSessionScalarWhereInput
    data: XOR<TerminalSessionUpdateManyMutationInput, TerminalSessionUncheckedUpdateManyWithoutTerminalInput>
  }

  export type TerminalSessionScalarWhereInput = {
    AND?: TerminalSessionScalarWhereInput | TerminalSessionScalarWhereInput[]
    OR?: TerminalSessionScalarWhereInput[]
    NOT?: TerminalSessionScalarWhereInput | TerminalSessionScalarWhereInput[]
    id?: StringFilter<"TerminalSession"> | string
    terminalId?: StringFilter<"TerminalSession"> | string
    sessionToken?: StringFilter<"TerminalSession"> | string
    startedAt?: DateTimeFilter<"TerminalSession"> | Date | string
    expiresAt?: DateTimeFilter<"TerminalSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"TerminalSession"> | Date | string
    ipAddress?: StringNullableFilter<"TerminalSession"> | string | null
    isActive?: BoolFilter<"TerminalSession"> | boolean
  }

  export type OperationModeUpsertWithWhereUniqueWithoutTerminalInput = {
    where: OperationModeWhereUniqueInput
    update: XOR<OperationModeUpdateWithoutTerminalInput, OperationModeUncheckedUpdateWithoutTerminalInput>
    create: XOR<OperationModeCreateWithoutTerminalInput, OperationModeUncheckedCreateWithoutTerminalInput>
  }

  export type OperationModeUpdateWithWhereUniqueWithoutTerminalInput = {
    where: OperationModeWhereUniqueInput
    data: XOR<OperationModeUpdateWithoutTerminalInput, OperationModeUncheckedUpdateWithoutTerminalInput>
  }

  export type OperationModeUpdateManyWithWhereWithoutTerminalInput = {
    where: OperationModeScalarWhereInput
    data: XOR<OperationModeUpdateManyMutationInput, OperationModeUncheckedUpdateManyWithoutTerminalInput>
  }

  export type OperationModeScalarWhereInput = {
    AND?: OperationModeScalarWhereInput | OperationModeScalarWhereInput[]
    OR?: OperationModeScalarWhereInput[]
    NOT?: OperationModeScalarWhereInput | OperationModeScalarWhereInput[]
    id?: StringFilter<"OperationMode"> | string
    terminalId?: StringFilter<"OperationMode"> | string
    currentMode?: EnumOperationModeTypeFilter<"OperationMode"> | $Enums.OperationModeType
    lastModeChange?: DateTimeFilter<"OperationMode"> | Date | string
    lastOnlineCheck?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
    centralBaseURL?: StringFilter<"OperationMode"> | string
    syncEndpoint?: StringFilter<"OperationMode"> | string
    heartbeatInterval?: IntFilter<"OperationMode"> | number
    maxOfflineHours?: IntFilter<"OperationMode"> | number
    offlineSince?: DateTimeNullableFilter<"OperationMode"> | Date | string | null
  }

  export type ConnectionLogUpsertWithWhereUniqueWithoutTerminalInput = {
    where: ConnectionLogWhereUniqueInput
    update: XOR<ConnectionLogUpdateWithoutTerminalInput, ConnectionLogUncheckedUpdateWithoutTerminalInput>
    create: XOR<ConnectionLogCreateWithoutTerminalInput, ConnectionLogUncheckedCreateWithoutTerminalInput>
  }

  export type ConnectionLogUpdateWithWhereUniqueWithoutTerminalInput = {
    where: ConnectionLogWhereUniqueInput
    data: XOR<ConnectionLogUpdateWithoutTerminalInput, ConnectionLogUncheckedUpdateWithoutTerminalInput>
  }

  export type ConnectionLogUpdateManyWithWhereWithoutTerminalInput = {
    where: ConnectionLogScalarWhereInput
    data: XOR<ConnectionLogUpdateManyMutationInput, ConnectionLogUncheckedUpdateManyWithoutTerminalInput>
  }

  export type ConnectionLogScalarWhereInput = {
    AND?: ConnectionLogScalarWhereInput | ConnectionLogScalarWhereInput[]
    OR?: ConnectionLogScalarWhereInput[]
    NOT?: ConnectionLogScalarWhereInput | ConnectionLogScalarWhereInput[]
    id?: StringFilter<"ConnectionLog"> | string
    terminalId?: StringFilter<"ConnectionLog"> | string
    mode?: EnumOperationModeTypeFilter<"ConnectionLog"> | $Enums.OperationModeType
    timestamp?: DateTimeFilter<"ConnectionLog"> | Date | string
    durationMs?: IntNullableFilter<"ConnectionLog"> | number | null
    errorMessage?: StringNullableFilter<"ConnectionLog"> | string | null
    success?: BoolFilter<"ConnectionLog"> | boolean
  }

  export type UserSessionUpsertWithWhereUniqueWithoutTerminalInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutTerminalInput, UserSessionUncheckedUpdateWithoutTerminalInput>
    create: XOR<UserSessionCreateWithoutTerminalInput, UserSessionUncheckedCreateWithoutTerminalInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutTerminalInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutTerminalInput, UserSessionUncheckedUpdateWithoutTerminalInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutTerminalInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutTerminalInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    terminalId?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    startedAt?: DateTimeFilter<"UserSession"> | Date | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    lastActivityAt?: DateTimeFilter<"UserSession"> | Date | string
    isActive?: BoolFilter<"UserSession"> | boolean
  }

  export type OutboxUpsertWithWhereUniqueWithoutTerminalInput = {
    where: OutboxWhereUniqueInput
    update: XOR<OutboxUpdateWithoutTerminalInput, OutboxUncheckedUpdateWithoutTerminalInput>
    create: XOR<OutboxCreateWithoutTerminalInput, OutboxUncheckedCreateWithoutTerminalInput>
  }

  export type OutboxUpdateWithWhereUniqueWithoutTerminalInput = {
    where: OutboxWhereUniqueInput
    data: XOR<OutboxUpdateWithoutTerminalInput, OutboxUncheckedUpdateWithoutTerminalInput>
  }

  export type OutboxUpdateManyWithWhereWithoutTerminalInput = {
    where: OutboxScalarWhereInput
    data: XOR<OutboxUpdateManyMutationInput, OutboxUncheckedUpdateManyWithoutTerminalInput>
  }

  export type OutboxScalarWhereInput = {
    AND?: OutboxScalarWhereInput | OutboxScalarWhereInput[]
    OR?: OutboxScalarWhereInput[]
    NOT?: OutboxScalarWhereInput | OutboxScalarWhereInput[]
    id?: StringFilter<"Outbox"> | string
    terminalId?: StringFilter<"Outbox"> | string
    entityType?: StringFilter<"Outbox"> | string
    entityId?: StringFilter<"Outbox"> | string
    operation?: EnumSyncOperationFilter<"Outbox"> | $Enums.SyncOperation
    data?: JsonFilter<"Outbox">
    createdInMode?: EnumOperationModeTypeFilter<"Outbox"> | $Enums.OperationModeType
    shiftId?: StringNullableFilter<"Outbox"> | string | null
    userId?: StringNullableFilter<"Outbox"> | string | null
    syncPriority?: IntFilter<"Outbox"> | number
    attemptCount?: IntFilter<"Outbox"> | number
    maxAttempts?: IntFilter<"Outbox"> | number
    lastAttemptAt?: DateTimeNullableFilter<"Outbox"> | Date | string | null
    errorMessage?: StringNullableFilter<"Outbox"> | string | null
    createdAt?: DateTimeFilter<"Outbox"> | Date | string
    localTimestamp?: DateTimeFilter<"Outbox"> | Date | string
    syncVersion?: IntFilter<"Outbox"> | number
  }

  export type SyncHistoryUpsertWithWhereUniqueWithoutTerminalInput = {
    where: SyncHistoryWhereUniqueInput
    update: XOR<SyncHistoryUpdateWithoutTerminalInput, SyncHistoryUncheckedUpdateWithoutTerminalInput>
    create: XOR<SyncHistoryCreateWithoutTerminalInput, SyncHistoryUncheckedCreateWithoutTerminalInput>
  }

  export type SyncHistoryUpdateWithWhereUniqueWithoutTerminalInput = {
    where: SyncHistoryWhereUniqueInput
    data: XOR<SyncHistoryUpdateWithoutTerminalInput, SyncHistoryUncheckedUpdateWithoutTerminalInput>
  }

  export type SyncHistoryUpdateManyWithWhereWithoutTerminalInput = {
    where: SyncHistoryScalarWhereInput
    data: XOR<SyncHistoryUpdateManyMutationInput, SyncHistoryUncheckedUpdateManyWithoutTerminalInput>
  }

  export type SyncHistoryScalarWhereInput = {
    AND?: SyncHistoryScalarWhereInput | SyncHistoryScalarWhereInput[]
    OR?: SyncHistoryScalarWhereInput[]
    NOT?: SyncHistoryScalarWhereInput | SyncHistoryScalarWhereInput[]
    id?: StringFilter<"SyncHistory"> | string
    terminalId?: StringFilter<"SyncHistory"> | string
    syncType?: EnumSyncTypeFilter<"SyncHistory"> | $Enums.SyncType
    direction?: EnumSyncDirectionFilter<"SyncHistory"> | $Enums.SyncDirection
    entitiesProcessed?: IntFilter<"SyncHistory"> | number
    successCount?: IntFilter<"SyncHistory"> | number
    failureCount?: IntFilter<"SyncHistory"> | number
    conflictsFound?: IntFilter<"SyncHistory"> | number
    startedAt?: DateTimeFilter<"SyncHistory"> | Date | string
    completedAt?: DateTimeNullableFilter<"SyncHistory"> | Date | string | null
    durationMs?: IntNullableFilter<"SyncHistory"> | number | null
    success?: BoolFilter<"SyncHistory"> | boolean
    errorMessage?: StringNullableFilter<"SyncHistory"> | string | null
  }

  export type SaleOrderUpsertWithWhereUniqueWithoutTerminalInput = {
    where: SaleOrderWhereUniqueInput
    update: XOR<SaleOrderUpdateWithoutTerminalInput, SaleOrderUncheckedUpdateWithoutTerminalInput>
    create: XOR<SaleOrderCreateWithoutTerminalInput, SaleOrderUncheckedCreateWithoutTerminalInput>
  }

  export type SaleOrderUpdateWithWhereUniqueWithoutTerminalInput = {
    where: SaleOrderWhereUniqueInput
    data: XOR<SaleOrderUpdateWithoutTerminalInput, SaleOrderUncheckedUpdateWithoutTerminalInput>
  }

  export type SaleOrderUpdateManyWithWhereWithoutTerminalInput = {
    where: SaleOrderScalarWhereInput
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyWithoutTerminalInput>
  }

  export type SaleOrderScalarWhereInput = {
    AND?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
    OR?: SaleOrderScalarWhereInput[]
    NOT?: SaleOrderScalarWhereInput | SaleOrderScalarWhereInput[]
    id?: StringFilter<"SaleOrder"> | string
    locationId?: StringFilter<"SaleOrder"> | string
    terminalId?: StringNullableFilter<"SaleOrder"> | string | null
    orderNumber?: StringFilter<"SaleOrder"> | string
    type?: EnumOrderTypeFilter<"SaleOrder"> | $Enums.OrderType
    status?: EnumOrderStatusFilter<"SaleOrder"> | $Enums.OrderStatus
    source?: EnumOrderSourceFilter<"SaleOrder"> | $Enums.OrderSource
    customerId?: StringNullableFilter<"SaleOrder"> | string | null
    shiftId?: StringNullableFilter<"SaleOrder"> | string | null
    userId?: StringNullableFilter<"SaleOrder"> | string | null
    subtotal?: FloatFilter<"SaleOrder"> | number
    taxAmount?: FloatFilter<"SaleOrder"> | number
    discountAmount?: FloatFilter<"SaleOrder"> | number
    total?: FloatFilter<"SaleOrder"> | number
    completedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    voidReason?: StringNullableFilter<"SaleOrder"> | string | null
    receiptPrinted?: BoolFilter<"SaleOrder"> | boolean
    receiptEmailed?: BoolFilter<"SaleOrder"> | boolean
    receiptPrintedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptEmailedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    receiptNumber?: StringNullableFilter<"SaleOrder"> | string | null
    discountReason?: StringNullableFilter<"SaleOrder"> | string | null
    notes?: StringNullableFilter<"SaleOrder"> | string | null
    syncVersion?: IntFilter<"SaleOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"SaleOrder"> | Date | string | null
    isDirty?: BoolFilter<"SaleOrder"> | boolean
    syncPriority?: IntFilter<"SaleOrder"> | number
    syncAttempts?: IntFilter<"SaleOrder"> | number
    createdAt?: DateTimeFilter<"SaleOrder"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrder"> | Date | string
  }

  export type ShiftUpsertWithWhereUniqueWithoutTerminalInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutTerminalInput, ShiftUncheckedUpdateWithoutTerminalInput>
    create: XOR<ShiftCreateWithoutTerminalInput, ShiftUncheckedCreateWithoutTerminalInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutTerminalInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutTerminalInput, ShiftUncheckedUpdateWithoutTerminalInput>
  }

  export type ShiftUpdateManyWithWhereWithoutTerminalInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutTerminalInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    locationId?: StringFilter<"Shift"> | string
    terminalId?: StringNullableFilter<"Shift"> | string | null
    userId?: StringFilter<"Shift"> | string
    shiftNumber?: StringFilter<"Shift"> | string
    registerId?: StringNullableFilter<"Shift"> | string | null
    openingCash?: FloatFilter<"Shift"> | number
    closingCash?: FloatNullableFilter<"Shift"> | number | null
    expectedCash?: FloatNullableFilter<"Shift"> | number | null
    cashDifference?: FloatNullableFilter<"Shift"> | number | null
    totalSales?: FloatFilter<"Shift"> | number
    totalRefunds?: FloatFilter<"Shift"> | number
    totalTransactions?: IntFilter<"Shift"> | number
    openedAt?: DateTimeFilter<"Shift"> | Date | string
    closedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    status?: EnumShiftStatusFilter<"Shift"> | $Enums.ShiftStatus
    notes?: StringNullableFilter<"Shift"> | string | null
    syncVersion?: IntFilter<"Shift"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Shift"> | Date | string | null
    isDirty?: BoolFilter<"Shift"> | boolean
  }

  export type TerminalCreateWithoutSessionsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutSessionsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutSessionsInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutSessionsInput, TerminalUncheckedCreateWithoutSessionsInput>
  }

  export type TerminalUpsertWithoutSessionsInput = {
    update: XOR<TerminalUpdateWithoutSessionsInput, TerminalUncheckedUpdateWithoutSessionsInput>
    create: XOR<TerminalCreateWithoutSessionsInput, TerminalUncheckedCreateWithoutSessionsInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutSessionsInput, TerminalUncheckedUpdateWithoutSessionsInput>
  }

  export type TerminalUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateWithoutOperationModesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutOperationModesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutOperationModesInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutOperationModesInput, TerminalUncheckedCreateWithoutOperationModesInput>
  }

  export type TerminalUpsertWithoutOperationModesInput = {
    update: XOR<TerminalUpdateWithoutOperationModesInput, TerminalUncheckedUpdateWithoutOperationModesInput>
    create: XOR<TerminalCreateWithoutOperationModesInput, TerminalUncheckedCreateWithoutOperationModesInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutOperationModesInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutOperationModesInput, TerminalUncheckedUpdateWithoutOperationModesInput>
  }

  export type TerminalUpdateWithoutOperationModesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutOperationModesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateWithoutConnectionLogsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutConnectionLogsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutConnectionLogsInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutConnectionLogsInput, TerminalUncheckedCreateWithoutConnectionLogsInput>
  }

  export type TerminalUpsertWithoutConnectionLogsInput = {
    update: XOR<TerminalUpdateWithoutConnectionLogsInput, TerminalUncheckedUpdateWithoutConnectionLogsInput>
    create: XOR<TerminalCreateWithoutConnectionLogsInput, TerminalUncheckedCreateWithoutConnectionLogsInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutConnectionLogsInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutConnectionLogsInput, TerminalUncheckedUpdateWithoutConnectionLogsInput>
  }

  export type TerminalUpdateWithoutConnectionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutConnectionLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type ShiftCreateWithoutUserInput = {
    id?: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    location: LocationCreateNestedOneWithoutShiftsInput
    terminal?: TerminalCreateNestedOneWithoutShiftsInput
    saleOrders?: SaleOrderCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutUserInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput>
  }

  export type ShiftCreateManyUserInputEnvelope = {
    data: ShiftCreateManyUserInput | ShiftCreateManyUserInput[]
  }

  export type SaleOrderCreateWithoutUserInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutUserInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutUserInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput>
  }

  export type SaleOrderCreateManyUserInputEnvelope = {
    data: SaleOrderCreateManyUserInput | SaleOrderCreateManyUserInput[]
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    terminal: TerminalCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
  }

  export type ShiftUpsertWithWhereUniqueWithoutUserInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutUserInput, ShiftUncheckedUpdateWithoutUserInput>
    create: XOR<ShiftCreateWithoutUserInput, ShiftUncheckedCreateWithoutUserInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutUserInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutUserInput, ShiftUncheckedUpdateWithoutUserInput>
  }

  export type ShiftUpdateManyWithWhereWithoutUserInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutUserInput>
  }

  export type SaleOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: SaleOrderWhereUniqueInput
    update: XOR<SaleOrderUpdateWithoutUserInput, SaleOrderUncheckedUpdateWithoutUserInput>
    create: XOR<SaleOrderCreateWithoutUserInput, SaleOrderUncheckedCreateWithoutUserInput>
  }

  export type SaleOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: SaleOrderWhereUniqueInput
    data: XOR<SaleOrderUpdateWithoutUserInput, SaleOrderUncheckedUpdateWithoutUserInput>
  }

  export type SaleOrderUpdateManyWithWhereWithoutUserInput = {
    where: SaleOrderScalarWhereInput
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type LocalUserCreateWithoutSessionsInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    saleOrders?: SaleOrderCreateNestedManyWithoutUserInput
  }

  export type LocalUserUncheckedCreateWithoutSessionsInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type LocalUserCreateOrConnectWithoutSessionsInput = {
    where: LocalUserWhereUniqueInput
    create: XOR<LocalUserCreateWithoutSessionsInput, LocalUserUncheckedCreateWithoutSessionsInput>
  }

  export type TerminalCreateWithoutUserSessionsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutUserSessionsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutUserSessionsInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutUserSessionsInput, TerminalUncheckedCreateWithoutUserSessionsInput>
  }

  export type LocalUserUpsertWithoutSessionsInput = {
    update: XOR<LocalUserUpdateWithoutSessionsInput, LocalUserUncheckedUpdateWithoutSessionsInput>
    create: XOR<LocalUserCreateWithoutSessionsInput, LocalUserUncheckedCreateWithoutSessionsInput>
    where?: LocalUserWhereInput
  }

  export type LocalUserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: LocalUserWhereInput
    data: XOR<LocalUserUpdateWithoutSessionsInput, LocalUserUncheckedUpdateWithoutSessionsInput>
  }

  export type LocalUserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutUserNestedInput
  }

  export type LocalUserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TerminalUpsertWithoutUserSessionsInput = {
    update: XOR<TerminalUpdateWithoutUserSessionsInput, TerminalUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<TerminalCreateWithoutUserSessionsInput, TerminalUncheckedCreateWithoutUserSessionsInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutUserSessionsInput, TerminalUncheckedUpdateWithoutUserSessionsInput>
  }

  export type TerminalUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateWithoutOutboxesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutOutboxesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutOutboxesInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutOutboxesInput, TerminalUncheckedCreateWithoutOutboxesInput>
  }

  export type TerminalUpsertWithoutOutboxesInput = {
    update: XOR<TerminalUpdateWithoutOutboxesInput, TerminalUncheckedUpdateWithoutOutboxesInput>
    create: XOR<TerminalCreateWithoutOutboxesInput, TerminalUncheckedCreateWithoutOutboxesInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutOutboxesInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutOutboxesInput, TerminalUncheckedUpdateWithoutOutboxesInput>
  }

  export type TerminalUpdateWithoutOutboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutOutboxesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateWithoutSyncHistoriesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutSyncHistoriesInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutSyncHistoriesInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutSyncHistoriesInput, TerminalUncheckedCreateWithoutSyncHistoriesInput>
  }

  export type TerminalUpsertWithoutSyncHistoriesInput = {
    update: XOR<TerminalUpdateWithoutSyncHistoriesInput, TerminalUncheckedUpdateWithoutSyncHistoriesInput>
    create: XOR<TerminalCreateWithoutSyncHistoriesInput, TerminalUncheckedCreateWithoutSyncHistoriesInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutSyncHistoriesInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutSyncHistoriesInput, TerminalUncheckedUpdateWithoutSyncHistoriesInput>
  }

  export type TerminalUpdateWithoutSyncHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutSyncHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type SaleOrderCreateWithoutLocationInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutLocationInput = {
    id?: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutLocationInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput>
  }

  export type SaleOrderCreateManyLocationInputEnvelope = {
    data: SaleOrderCreateManyLocationInput | SaleOrderCreateManyLocationInput[]
  }

  export type InventoryItemCreateWithoutLocationInput = {
    id: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutLocationInput = {
    id: string
    variantId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutLocationInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput>
  }

  export type InventoryItemCreateManyLocationInputEnvelope = {
    data: InventoryItemCreateManyLocationInput | InventoryItemCreateManyLocationInput[]
  }

  export type ShiftCreateWithoutLocationInput = {
    id?: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    terminal?: TerminalCreateNestedOneWithoutShiftsInput
    user: LocalUserCreateNestedOneWithoutShiftsInput
    saleOrders?: SaleOrderCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutLocationInput = {
    id?: string
    terminalId?: string | null
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutLocationInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput>
  }

  export type ShiftCreateManyLocationInputEnvelope = {
    data: ShiftCreateManyLocationInput | ShiftCreateManyLocationInput[]
  }

  export type StockAdjustmentCreateWithoutLocationInput = {
    id?: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    lineItems?: StockAdjustmentLineCreateNestedManyWithoutAdjustmentInput
  }

  export type StockAdjustmentUncheckedCreateWithoutLocationInput = {
    id?: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    lineItems?: StockAdjustmentLineUncheckedCreateNestedManyWithoutAdjustmentInput
  }

  export type StockAdjustmentCreateOrConnectWithoutLocationInput = {
    where: StockAdjustmentWhereUniqueInput
    create: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput>
  }

  export type StockAdjustmentCreateManyLocationInputEnvelope = {
    data: StockAdjustmentCreateManyLocationInput | StockAdjustmentCreateManyLocationInput[]
  }

  export type StockTransferCreateWithoutFromLocationInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    toLocation: LocationCreateNestedOneWithoutStockTransfersToInput
    lineItems?: StockTransferLineCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateWithoutFromLocationInput = {
    id?: string
    toLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: StockTransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferCreateOrConnectWithoutFromLocationInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput>
  }

  export type StockTransferCreateManyFromLocationInputEnvelope = {
    data: StockTransferCreateManyFromLocationInput | StockTransferCreateManyFromLocationInput[]
  }

  export type StockTransferCreateWithoutToLocationInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromLocation: LocationCreateNestedOneWithoutStockTransfersFromInput
    lineItems?: StockTransferLineCreateNestedManyWithoutTransferInput
  }

  export type StockTransferUncheckedCreateWithoutToLocationInput = {
    id?: string
    fromLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lineItems?: StockTransferLineUncheckedCreateNestedManyWithoutTransferInput
  }

  export type StockTransferCreateOrConnectWithoutToLocationInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput>
  }

  export type StockTransferCreateManyToLocationInputEnvelope = {
    data: StockTransferCreateManyToLocationInput | StockTransferCreateManyToLocationInput[]
  }

  export type ReturnOrderCreateWithoutLocationInput = {
    id?: string
    returnNumber: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalOrder: SaleOrderCreateNestedOneWithoutReturnOrdersInput
    customer?: CustomerCreateNestedOneWithoutReturnOrdersInput
    lines?: ReturnOrderLineCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderUncheckedCreateWithoutLocationInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    customerId?: string | null
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReturnOrderLineUncheckedCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderCreateOrConnectWithoutLocationInput = {
    where: ReturnOrderWhereUniqueInput
    create: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput>
  }

  export type ReturnOrderCreateManyLocationInputEnvelope = {
    data: ReturnOrderCreateManyLocationInput | ReturnOrderCreateManyLocationInput[]
  }

  export type SaleOrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: SaleOrderWhereUniqueInput
    update: XOR<SaleOrderUpdateWithoutLocationInput, SaleOrderUncheckedUpdateWithoutLocationInput>
    create: XOR<SaleOrderCreateWithoutLocationInput, SaleOrderUncheckedCreateWithoutLocationInput>
  }

  export type SaleOrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: SaleOrderWhereUniqueInput
    data: XOR<SaleOrderUpdateWithoutLocationInput, SaleOrderUncheckedUpdateWithoutLocationInput>
  }

  export type SaleOrderUpdateManyWithWhereWithoutLocationInput = {
    where: SaleOrderScalarWhereInput
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutLocationInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutLocationInput, InventoryItemUncheckedUpdateWithoutLocationInput>
    create: XOR<InventoryItemCreateWithoutLocationInput, InventoryItemUncheckedCreateWithoutLocationInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutLocationInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutLocationInput, InventoryItemUncheckedUpdateWithoutLocationInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutLocationInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutLocationInput>
  }

  export type InventoryItemScalarWhereInput = {
    AND?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    OR?: InventoryItemScalarWhereInput[]
    NOT?: InventoryItemScalarWhereInput | InventoryItemScalarWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    variantId?: StringFilter<"InventoryItem"> | string
    locationId?: StringFilter<"InventoryItem"> | string
    quantityOnHand?: IntFilter<"InventoryItem"> | number
    quantityReserved?: IntFilter<"InventoryItem"> | number
    quantityAvailable?: IntFilter<"InventoryItem"> | number
    reorderPoint?: IntNullableFilter<"InventoryItem"> | number | null
    reorderQuantity?: IntNullableFilter<"InventoryItem"> | number | null
    lastCountedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    lastReceivedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    syncVersion?: IntFilter<"InventoryItem"> | number
    lastSyncedAt?: DateTimeNullableFilter<"InventoryItem"> | Date | string | null
    isDirty?: BoolFilter<"InventoryItem"> | boolean
    pendingSync?: BoolFilter<"InventoryItem"> | boolean
    createdAt?: DateTimeFilter<"InventoryItem"> | Date | string
    updatedAt?: DateTimeFilter<"InventoryItem"> | Date | string
  }

  export type ShiftUpsertWithWhereUniqueWithoutLocationInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutLocationInput, ShiftUncheckedUpdateWithoutLocationInput>
    create: XOR<ShiftCreateWithoutLocationInput, ShiftUncheckedCreateWithoutLocationInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutLocationInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutLocationInput, ShiftUncheckedUpdateWithoutLocationInput>
  }

  export type ShiftUpdateManyWithWhereWithoutLocationInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutLocationInput>
  }

  export type StockAdjustmentUpsertWithWhereUniqueWithoutLocationInput = {
    where: StockAdjustmentWhereUniqueInput
    update: XOR<StockAdjustmentUpdateWithoutLocationInput, StockAdjustmentUncheckedUpdateWithoutLocationInput>
    create: XOR<StockAdjustmentCreateWithoutLocationInput, StockAdjustmentUncheckedCreateWithoutLocationInput>
  }

  export type StockAdjustmentUpdateWithWhereUniqueWithoutLocationInput = {
    where: StockAdjustmentWhereUniqueInput
    data: XOR<StockAdjustmentUpdateWithoutLocationInput, StockAdjustmentUncheckedUpdateWithoutLocationInput>
  }

  export type StockAdjustmentUpdateManyWithWhereWithoutLocationInput = {
    where: StockAdjustmentScalarWhereInput
    data: XOR<StockAdjustmentUpdateManyMutationInput, StockAdjustmentUncheckedUpdateManyWithoutLocationInput>
  }

  export type StockAdjustmentScalarWhereInput = {
    AND?: StockAdjustmentScalarWhereInput | StockAdjustmentScalarWhereInput[]
    OR?: StockAdjustmentScalarWhereInput[]
    NOT?: StockAdjustmentScalarWhereInput | StockAdjustmentScalarWhereInput[]
    id?: StringFilter<"StockAdjustment"> | string
    locationId?: StringFilter<"StockAdjustment"> | string
    adjustmentType?: EnumStockAdjustmentTypeFilter<"StockAdjustment"> | $Enums.StockAdjustmentType
    reason?: StringNullableFilter<"StockAdjustment"> | string | null
    referenceNumber?: StringNullableFilter<"StockAdjustment"> | string | null
    notes?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedBy?: StringNullableFilter<"StockAdjustment"> | string | null
    adjustedAt?: DateTimeFilter<"StockAdjustment"> | Date | string
    syncVersion?: IntFilter<"StockAdjustment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockAdjustment"> | Date | string | null
    isDirty?: BoolFilter<"StockAdjustment"> | boolean
    createdAt?: DateTimeFilter<"StockAdjustment"> | Date | string
  }

  export type StockTransferUpsertWithWhereUniqueWithoutFromLocationInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutFromLocationInput, StockTransferUncheckedUpdateWithoutFromLocationInput>
    create: XOR<StockTransferCreateWithoutFromLocationInput, StockTransferUncheckedCreateWithoutFromLocationInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutFromLocationInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutFromLocationInput, StockTransferUncheckedUpdateWithoutFromLocationInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutFromLocationInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutFromLocationInput>
  }

  export type StockTransferScalarWhereInput = {
    AND?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    OR?: StockTransferScalarWhereInput[]
    NOT?: StockTransferScalarWhereInput | StockTransferScalarWhereInput[]
    id?: StringFilter<"StockTransfer"> | string
    fromLocationId?: StringFilter<"StockTransfer"> | string
    toLocationId?: StringFilter<"StockTransfer"> | string
    transferNumber?: StringFilter<"StockTransfer"> | string
    status?: EnumTransferStatusFilter<"StockTransfer"> | $Enums.TransferStatus
    transferDate?: DateTimeFilter<"StockTransfer"> | Date | string
    notes?: StringNullableFilter<"StockTransfer"> | string | null
    createdBy?: StringNullableFilter<"StockTransfer"> | string | null
    syncVersion?: IntFilter<"StockTransfer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"StockTransfer"> | Date | string | null
    isDirty?: BoolFilter<"StockTransfer"> | boolean
    createdAt?: DateTimeFilter<"StockTransfer"> | Date | string
    updatedAt?: DateTimeFilter<"StockTransfer"> | Date | string
  }

  export type StockTransferUpsertWithWhereUniqueWithoutToLocationInput = {
    where: StockTransferWhereUniqueInput
    update: XOR<StockTransferUpdateWithoutToLocationInput, StockTransferUncheckedUpdateWithoutToLocationInput>
    create: XOR<StockTransferCreateWithoutToLocationInput, StockTransferUncheckedCreateWithoutToLocationInput>
  }

  export type StockTransferUpdateWithWhereUniqueWithoutToLocationInput = {
    where: StockTransferWhereUniqueInput
    data: XOR<StockTransferUpdateWithoutToLocationInput, StockTransferUncheckedUpdateWithoutToLocationInput>
  }

  export type StockTransferUpdateManyWithWhereWithoutToLocationInput = {
    where: StockTransferScalarWhereInput
    data: XOR<StockTransferUpdateManyMutationInput, StockTransferUncheckedUpdateManyWithoutToLocationInput>
  }

  export type ReturnOrderUpsertWithWhereUniqueWithoutLocationInput = {
    where: ReturnOrderWhereUniqueInput
    update: XOR<ReturnOrderUpdateWithoutLocationInput, ReturnOrderUncheckedUpdateWithoutLocationInput>
    create: XOR<ReturnOrderCreateWithoutLocationInput, ReturnOrderUncheckedCreateWithoutLocationInput>
  }

  export type ReturnOrderUpdateWithWhereUniqueWithoutLocationInput = {
    where: ReturnOrderWhereUniqueInput
    data: XOR<ReturnOrderUpdateWithoutLocationInput, ReturnOrderUncheckedUpdateWithoutLocationInput>
  }

  export type ReturnOrderUpdateManyWithWhereWithoutLocationInput = {
    where: ReturnOrderScalarWhereInput
    data: XOR<ReturnOrderUpdateManyMutationInput, ReturnOrderUncheckedUpdateManyWithoutLocationInput>
  }

  export type ReturnOrderScalarWhereInput = {
    AND?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
    OR?: ReturnOrderScalarWhereInput[]
    NOT?: ReturnOrderScalarWhereInput | ReturnOrderScalarWhereInput[]
    id?: StringFilter<"ReturnOrder"> | string
    returnNumber?: StringFilter<"ReturnOrder"> | string
    originalOrderId?: StringFilter<"ReturnOrder"> | string
    customerId?: StringNullableFilter<"ReturnOrder"> | string | null
    locationId?: StringFilter<"ReturnOrder"> | string
    reason?: EnumReturnReasonNullableFilter<"ReturnOrder"> | $Enums.ReturnReason | null
    notes?: StringNullableFilter<"ReturnOrder"> | string | null
    subtotal?: FloatFilter<"ReturnOrder"> | number
    taxAmount?: FloatFilter<"ReturnOrder"> | number
    total?: FloatFilter<"ReturnOrder"> | number
    refundMethod?: EnumRefundMethodNullableFilter<"ReturnOrder"> | $Enums.RefundMethod | null
    refundAmount?: FloatFilter<"ReturnOrder"> | number
    status?: EnumReturnStatusFilter<"ReturnOrder"> | $Enums.ReturnStatus
    processedBy?: StringNullableFilter<"ReturnOrder"> | string | null
    processedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    syncVersion?: IntFilter<"ReturnOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ReturnOrder"> | Date | string | null
    isDirty?: BoolFilter<"ReturnOrder"> | boolean
    syncAttempts?: IntFilter<"ReturnOrder"> | number
    createdAt?: DateTimeFilter<"ReturnOrder"> | Date | string
    updatedAt?: DateTimeFilter<"ReturnOrder"> | Date | string
  }

  export type CategoryCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    children?: CategoryCreateNestedManyWithoutParentInput
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    parentId?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type BrandCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    logoUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUncheckedCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    logoUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandCreateOrConnectWithoutProductsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
  }

  export type TaxCategoryCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TaxRateCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryUncheckedCreateWithoutProductsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    rates?: TaxRateUncheckedCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryCreateOrConnectWithoutProductsInput = {
    where: TaxCategoryWhereUniqueInput
    create: XOR<TaxCategoryCreateWithoutProductsInput, TaxCategoryUncheckedCreateWithoutProductsInput>
  }

  export type ProductVariantCreateWithoutProductInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutProductInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantCreateManyProductInputEnvelope = {
    data: ProductVariantCreateManyProductInput | ProductVariantCreateManyProductInput[]
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    children?: CategoryUpdateManyWithoutParentNestedInput
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
  }

  export type BrandUpsertWithoutProductsInput = {
    update: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxCategoryUpsertWithoutProductsInput = {
    update: XOR<TaxCategoryUpdateWithoutProductsInput, TaxCategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<TaxCategoryCreateWithoutProductsInput, TaxCategoryUncheckedCreateWithoutProductsInput>
    where?: TaxCategoryWhereInput
  }

  export type TaxCategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: TaxCategoryWhereInput
    data: XOR<TaxCategoryUpdateWithoutProductsInput, TaxCategoryUncheckedUpdateWithoutProductsInput>
  }

  export type TaxCategoryUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TaxRateUpdateManyWithoutTaxCategoryNestedInput
  }

  export type TaxCategoryUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rates?: TaxRateUncheckedUpdateManyWithoutTaxCategoryNestedInput
  }

  export type ProductVariantUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    update: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
    create: XOR<ProductVariantCreateWithoutProductInput, ProductVariantUncheckedCreateWithoutProductInput>
  }

  export type ProductVariantUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductVariantWhereUniqueInput
    data: XOR<ProductVariantUpdateWithoutProductInput, ProductVariantUncheckedUpdateWithoutProductInput>
  }

  export type ProductVariantUpdateManyWithWhereWithoutProductInput = {
    where: ProductVariantScalarWhereInput
    data: XOR<ProductVariantUpdateManyMutationInput, ProductVariantUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductVariantScalarWhereInput = {
    AND?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    OR?: ProductVariantScalarWhereInput[]
    NOT?: ProductVariantScalarWhereInput | ProductVariantScalarWhereInput[]
    id?: StringFilter<"ProductVariant"> | string
    productId?: StringFilter<"ProductVariant"> | string
    sku?: StringFilter<"ProductVariant"> | string
    name?: StringNullableFilter<"ProductVariant"> | string | null
    cost?: FloatFilter<"ProductVariant"> | number
    price?: FloatFilter<"ProductVariant"> | number
    compareAtPrice?: FloatNullableFilter<"ProductVariant"> | number | null
    trackInventory?: BoolFilter<"ProductVariant"> | boolean
    barcode?: StringNullableFilter<"ProductVariant"> | string | null
    upc?: StringNullableFilter<"ProductVariant"> | string | null
    ean?: StringNullableFilter<"ProductVariant"> | string | null
    color?: StringNullableFilter<"ProductVariant"> | string | null
    size?: StringNullableFilter<"ProductVariant"> | string | null
    material?: StringNullableFilter<"ProductVariant"> | string | null
    style?: StringNullableFilter<"ProductVariant"> | string | null
    weight?: FloatNullableFilter<"ProductVariant"> | number | null
    weightUnit?: StringNullableFilter<"ProductVariant"> | string | null
    syncVersion?: IntFilter<"ProductVariant"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ProductVariant"> | Date | string | null
    isDirty?: BoolFilter<"ProductVariant"> | boolean
    isActive?: BoolFilter<"ProductVariant"> | boolean
    createdAt?: DateTimeFilter<"ProductVariant"> | Date | string
    updatedAt?: DateTimeFilter<"ProductVariant"> | Date | string
  }

  export type ProductCreateWithoutVariantsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    taxCategory?: TaxCategoryCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    brandId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type InventoryItemCreateWithoutVariantInput = {
    id: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutInventoryItemsInput
  }

  export type InventoryItemUncheckedCreateWithoutVariantInput = {
    id: string
    locationId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutVariantInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput>
  }

  export type InventoryItemCreateManyVariantInputEnvelope = {
    data: InventoryItemCreateManyVariantInput | InventoryItemCreateManyVariantInput[]
  }

  export type SaleOrderLineCreateWithoutVariantInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: SaleOrderCreateNestedOneWithoutLinesInput
  }

  export type SaleOrderLineUncheckedCreateWithoutVariantInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderLineCreateOrConnectWithoutVariantInput = {
    where: SaleOrderLineWhereUniqueInput
    create: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput>
  }

  export type SaleOrderLineCreateManyVariantInputEnvelope = {
    data: SaleOrderLineCreateManyVariantInput | SaleOrderLineCreateManyVariantInput[]
  }

  export type ReturnOrderLineCreateWithoutVariantInput = {
    id?: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
    returnOrder: ReturnOrderCreateNestedOneWithoutLinesInput
  }

  export type ReturnOrderLineUncheckedCreateWithoutVariantInput = {
    id?: string
    returnOrderId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReturnOrderLineCreateOrConnectWithoutVariantInput = {
    where: ReturnOrderLineWhereUniqueInput
    create: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput>
  }

  export type ReturnOrderLineCreateManyVariantInputEnvelope = {
    data: ReturnOrderLineCreateManyVariantInput | ReturnOrderLineCreateManyVariantInput[]
  }

  export type StockAdjustmentLineCreateWithoutVariantInput = {
    id?: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
    adjustment: StockAdjustmentCreateNestedOneWithoutLineItemsInput
  }

  export type StockAdjustmentLineUncheckedCreateWithoutVariantInput = {
    id?: string
    adjustmentId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockAdjustmentLineCreateOrConnectWithoutVariantInput = {
    where: StockAdjustmentLineWhereUniqueInput
    create: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput>
  }

  export type StockAdjustmentLineCreateManyVariantInputEnvelope = {
    data: StockAdjustmentLineCreateManyVariantInput | StockAdjustmentLineCreateManyVariantInput[]
  }

  export type StockTransferLineCreateWithoutVariantInput = {
    id?: string
    quantity: number
    received?: number | null
    transfer: StockTransferCreateNestedOneWithoutLineItemsInput
  }

  export type StockTransferLineUncheckedCreateWithoutVariantInput = {
    id?: string
    transferId: string
    quantity: number
    received?: number | null
  }

  export type StockTransferLineCreateOrConnectWithoutVariantInput = {
    where: StockTransferLineWhereUniqueInput
    create: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput>
  }

  export type StockTransferLineCreateManyVariantInputEnvelope = {
    data: StockTransferLineCreateManyVariantInput | StockTransferLineCreateManyVariantInput[]
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    taxCategory?: TaxCategoryUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpsertWithWhereUniqueWithoutVariantInput = {
    where: InventoryItemWhereUniqueInput
    update: XOR<InventoryItemUpdateWithoutVariantInput, InventoryItemUncheckedUpdateWithoutVariantInput>
    create: XOR<InventoryItemCreateWithoutVariantInput, InventoryItemUncheckedCreateWithoutVariantInput>
  }

  export type InventoryItemUpdateWithWhereUniqueWithoutVariantInput = {
    where: InventoryItemWhereUniqueInput
    data: XOR<InventoryItemUpdateWithoutVariantInput, InventoryItemUncheckedUpdateWithoutVariantInput>
  }

  export type InventoryItemUpdateManyWithWhereWithoutVariantInput = {
    where: InventoryItemScalarWhereInput
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyWithoutVariantInput>
  }

  export type SaleOrderLineUpsertWithWhereUniqueWithoutVariantInput = {
    where: SaleOrderLineWhereUniqueInput
    update: XOR<SaleOrderLineUpdateWithoutVariantInput, SaleOrderLineUncheckedUpdateWithoutVariantInput>
    create: XOR<SaleOrderLineCreateWithoutVariantInput, SaleOrderLineUncheckedCreateWithoutVariantInput>
  }

  export type SaleOrderLineUpdateWithWhereUniqueWithoutVariantInput = {
    where: SaleOrderLineWhereUniqueInput
    data: XOR<SaleOrderLineUpdateWithoutVariantInput, SaleOrderLineUncheckedUpdateWithoutVariantInput>
  }

  export type SaleOrderLineUpdateManyWithWhereWithoutVariantInput = {
    where: SaleOrderLineScalarWhereInput
    data: XOR<SaleOrderLineUpdateManyMutationInput, SaleOrderLineUncheckedUpdateManyWithoutVariantInput>
  }

  export type SaleOrderLineScalarWhereInput = {
    AND?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
    OR?: SaleOrderLineScalarWhereInput[]
    NOT?: SaleOrderLineScalarWhereInput | SaleOrderLineScalarWhereInput[]
    id?: StringFilter<"SaleOrderLine"> | string
    orderId?: StringFilter<"SaleOrderLine"> | string
    variantId?: StringFilter<"SaleOrderLine"> | string
    quantity?: IntFilter<"SaleOrderLine"> | number
    unitPrice?: FloatFilter<"SaleOrderLine"> | number
    discountAmount?: FloatFilter<"SaleOrderLine"> | number
    taxAmount?: FloatFilter<"SaleOrderLine"> | number
    lineTotal?: FloatFilter<"SaleOrderLine"> | number
    notes?: StringNullableFilter<"SaleOrderLine"> | string | null
    syncVersion?: IntFilter<"SaleOrderLine"> | number
    createdAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
    updatedAt?: DateTimeFilter<"SaleOrderLine"> | Date | string
  }

  export type ReturnOrderLineUpsertWithWhereUniqueWithoutVariantInput = {
    where: ReturnOrderLineWhereUniqueInput
    update: XOR<ReturnOrderLineUpdateWithoutVariantInput, ReturnOrderLineUncheckedUpdateWithoutVariantInput>
    create: XOR<ReturnOrderLineCreateWithoutVariantInput, ReturnOrderLineUncheckedCreateWithoutVariantInput>
  }

  export type ReturnOrderLineUpdateWithWhereUniqueWithoutVariantInput = {
    where: ReturnOrderLineWhereUniqueInput
    data: XOR<ReturnOrderLineUpdateWithoutVariantInput, ReturnOrderLineUncheckedUpdateWithoutVariantInput>
  }

  export type ReturnOrderLineUpdateManyWithWhereWithoutVariantInput = {
    where: ReturnOrderLineScalarWhereInput
    data: XOR<ReturnOrderLineUpdateManyMutationInput, ReturnOrderLineUncheckedUpdateManyWithoutVariantInput>
  }

  export type ReturnOrderLineScalarWhereInput = {
    AND?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
    OR?: ReturnOrderLineScalarWhereInput[]
    NOT?: ReturnOrderLineScalarWhereInput | ReturnOrderLineScalarWhereInput[]
    id?: StringFilter<"ReturnOrderLine"> | string
    returnOrderId?: StringFilter<"ReturnOrderLine"> | string
    variantId?: StringFilter<"ReturnOrderLine"> | string
    originalLineId?: StringNullableFilter<"ReturnOrderLine"> | string | null
    quantity?: IntFilter<"ReturnOrderLine"> | number
    unitPrice?: FloatFilter<"ReturnOrderLine"> | number
    lineTotal?: FloatFilter<"ReturnOrderLine"> | number
    reason?: StringNullableFilter<"ReturnOrderLine"> | string | null
    createdAt?: DateTimeFilter<"ReturnOrderLine"> | Date | string
  }

  export type StockAdjustmentLineUpsertWithWhereUniqueWithoutVariantInput = {
    where: StockAdjustmentLineWhereUniqueInput
    update: XOR<StockAdjustmentLineUpdateWithoutVariantInput, StockAdjustmentLineUncheckedUpdateWithoutVariantInput>
    create: XOR<StockAdjustmentLineCreateWithoutVariantInput, StockAdjustmentLineUncheckedCreateWithoutVariantInput>
  }

  export type StockAdjustmentLineUpdateWithWhereUniqueWithoutVariantInput = {
    where: StockAdjustmentLineWhereUniqueInput
    data: XOR<StockAdjustmentLineUpdateWithoutVariantInput, StockAdjustmentLineUncheckedUpdateWithoutVariantInput>
  }

  export type StockAdjustmentLineUpdateManyWithWhereWithoutVariantInput = {
    where: StockAdjustmentLineScalarWhereInput
    data: XOR<StockAdjustmentLineUpdateManyMutationInput, StockAdjustmentLineUncheckedUpdateManyWithoutVariantInput>
  }

  export type StockAdjustmentLineScalarWhereInput = {
    AND?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
    OR?: StockAdjustmentLineScalarWhereInput[]
    NOT?: StockAdjustmentLineScalarWhereInput | StockAdjustmentLineScalarWhereInput[]
    id?: StringFilter<"StockAdjustmentLine"> | string
    adjustmentId?: StringFilter<"StockAdjustmentLine"> | string
    variantId?: StringFilter<"StockAdjustmentLine"> | string
    quantityBefore?: IntFilter<"StockAdjustmentLine"> | number
    quantityAfter?: IntFilter<"StockAdjustmentLine"> | number
    quantityChange?: IntFilter<"StockAdjustmentLine"> | number
  }

  export type StockTransferLineUpsertWithWhereUniqueWithoutVariantInput = {
    where: StockTransferLineWhereUniqueInput
    update: XOR<StockTransferLineUpdateWithoutVariantInput, StockTransferLineUncheckedUpdateWithoutVariantInput>
    create: XOR<StockTransferLineCreateWithoutVariantInput, StockTransferLineUncheckedCreateWithoutVariantInput>
  }

  export type StockTransferLineUpdateWithWhereUniqueWithoutVariantInput = {
    where: StockTransferLineWhereUniqueInput
    data: XOR<StockTransferLineUpdateWithoutVariantInput, StockTransferLineUncheckedUpdateWithoutVariantInput>
  }

  export type StockTransferLineUpdateManyWithWhereWithoutVariantInput = {
    where: StockTransferLineScalarWhereInput
    data: XOR<StockTransferLineUpdateManyMutationInput, StockTransferLineUncheckedUpdateManyWithoutVariantInput>
  }

  export type StockTransferLineScalarWhereInput = {
    AND?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
    OR?: StockTransferLineScalarWhereInput[]
    NOT?: StockTransferLineScalarWhereInput | StockTransferLineScalarWhereInput[]
    id?: StringFilter<"StockTransferLine"> | string
    transferId?: StringFilter<"StockTransferLine"> | string
    variantId?: StringFilter<"StockTransferLine"> | string
    quantity?: IntFilter<"StockTransferLine"> | number
    received?: IntNullableFilter<"StockTransferLine"> | number | null
  }

  export type CategoryCreateWithoutChildrenInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CategoryCreateNestedOneWithoutChildrenInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutChildrenInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    parentId?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutChildrenInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
  }

  export type CategoryCreateWithoutParentInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryCreateNestedManyWithoutParentInput
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateWithoutParentInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CategoryUncheckedCreateNestedManyWithoutParentInput
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryCreateOrConnectWithoutParentInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryCreateManyParentInputEnvelope = {
    data: CategoryCreateManyParentInput | CategoryCreateManyParentInput[]
  }

  export type ProductCreateWithoutCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    brand?: BrandCreateNestedOneWithoutProductsInput
    taxCategory?: TaxCategoryCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    brandId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
  }

  export type CategoryUpsertWithoutChildrenInput = {
    update: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<CategoryCreateWithoutChildrenInput, CategoryUncheckedCreateWithoutChildrenInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutChildrenInput, CategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type CategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CategoryUpdateOneWithoutChildrenNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    update: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
    create: XOR<CategoryCreateWithoutParentInput, CategoryUncheckedCreateWithoutParentInput>
  }

  export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: CategoryWhereUniqueInput
    data: XOR<CategoryUpdateWithoutParentInput, CategoryUncheckedUpdateWithoutParentInput>
  }

  export type CategoryUpdateManyWithWhereWithoutParentInput = {
    where: CategoryScalarWhereInput
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type CategoryScalarWhereInput = {
    AND?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    OR?: CategoryScalarWhereInput[]
    NOT?: CategoryScalarWhereInput | CategoryScalarWhereInput[]
    id?: StringFilter<"Category"> | string
    code?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    imageUrl?: StringNullableFilter<"Category"> | string | null
    parentId?: StringNullableFilter<"Category"> | string | null
    syncVersion?: IntFilter<"Category"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Category"> | Date | string | null
    isDirty?: BoolFilter<"Category"> | boolean
    isActive?: BoolFilter<"Category"> | boolean
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    code?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    type?: EnumProductTypeFilter<"Product"> | $Enums.ProductType
    categoryId?: StringNullableFilter<"Product"> | string | null
    brandId?: StringNullableFilter<"Product"> | string | null
    taxCategoryId?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    syncVersion?: IntFilter<"Product"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    isDirty?: BoolFilter<"Product"> | boolean
    isActive?: BoolFilter<"Product"> | boolean
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductCreateWithoutBrandInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    taxCategory?: TaxCategoryCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type CustomerGroupCreateWithoutCustomersInput = {
    id: string
    code: string
    name: string
    description?: string | null
    discountPercent?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupUncheckedCreateWithoutCustomersInput = {
    id: string
    code: string
    name: string
    description?: string | null
    discountPercent?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerGroupCreateOrConnectWithoutCustomersInput = {
    where: CustomerGroupWhereUniqueInput
    create: XOR<CustomerGroupCreateWithoutCustomersInput, CustomerGroupUncheckedCreateWithoutCustomersInput>
  }

  export type CustomerAddressCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUncheckedCreateWithoutCustomerInput = {
    id?: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressCreateOrConnectWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressCreateManyCustomerInputEnvelope = {
    data: CustomerAddressCreateManyCustomerInput | CustomerAddressCreateManyCustomerInput[]
  }

  export type SaleOrderCreateWithoutCustomerInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutCustomerInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SaleOrderCreateManyCustomerInputEnvelope = {
    data: SaleOrderCreateManyCustomerInput | SaleOrderCreateManyCustomerInput[]
  }

  export type ReturnOrderCreateWithoutCustomerInput = {
    id?: string
    returnNumber: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalOrder: SaleOrderCreateNestedOneWithoutReturnOrdersInput
    location: LocationCreateNestedOneWithoutReturnOrdersInput
    lines?: ReturnOrderLineCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReturnOrderLineUncheckedCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderCreateOrConnectWithoutCustomerInput = {
    where: ReturnOrderWhereUniqueInput
    create: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnOrderCreateManyCustomerInputEnvelope = {
    data: ReturnOrderCreateManyCustomerInput | ReturnOrderCreateManyCustomerInput[]
  }

  export type CustomerGroupUpsertWithoutCustomersInput = {
    update: XOR<CustomerGroupUpdateWithoutCustomersInput, CustomerGroupUncheckedUpdateWithoutCustomersInput>
    create: XOR<CustomerGroupCreateWithoutCustomersInput, CustomerGroupUncheckedCreateWithoutCustomersInput>
    where?: CustomerGroupWhereInput
  }

  export type CustomerGroupUpdateToOneWithWhereWithoutCustomersInput = {
    where?: CustomerGroupWhereInput
    data: XOR<CustomerGroupUpdateWithoutCustomersInput, CustomerGroupUncheckedUpdateWithoutCustomersInput>
  }

  export type CustomerGroupUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerGroupUncheckedUpdateWithoutCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    discountPercent?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUpsertWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    update: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
    create: XOR<CustomerAddressCreateWithoutCustomerInput, CustomerAddressUncheckedCreateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateWithWhereUniqueWithoutCustomerInput = {
    where: CustomerAddressWhereUniqueInput
    data: XOR<CustomerAddressUpdateWithoutCustomerInput, CustomerAddressUncheckedUpdateWithoutCustomerInput>
  }

  export type CustomerAddressUpdateManyWithWhereWithoutCustomerInput = {
    where: CustomerAddressScalarWhereInput
    data: XOR<CustomerAddressUpdateManyMutationInput, CustomerAddressUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerAddressScalarWhereInput = {
    AND?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    OR?: CustomerAddressScalarWhereInput[]
    NOT?: CustomerAddressScalarWhereInput | CustomerAddressScalarWhereInput[]
    id?: StringFilter<"CustomerAddress"> | string
    customerId?: StringFilter<"CustomerAddress"> | string
    type?: EnumAddressTypeFilter<"CustomerAddress"> | $Enums.AddressType
    addressLine1?: StringFilter<"CustomerAddress"> | string
    addressLine2?: StringNullableFilter<"CustomerAddress"> | string | null
    city?: StringFilter<"CustomerAddress"> | string
    state?: StringNullableFilter<"CustomerAddress"> | string | null
    zipCode?: StringFilter<"CustomerAddress"> | string
    country?: StringFilter<"CustomerAddress"> | string
    isDefault?: BoolFilter<"CustomerAddress"> | boolean
    createdAt?: DateTimeFilter<"CustomerAddress"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerAddress"> | Date | string
  }

  export type SaleOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SaleOrderWhereUniqueInput
    update: XOR<SaleOrderUpdateWithoutCustomerInput, SaleOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<SaleOrderCreateWithoutCustomerInput, SaleOrderUncheckedCreateWithoutCustomerInput>
  }

  export type SaleOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SaleOrderWhereUniqueInput
    data: XOR<SaleOrderUpdateWithoutCustomerInput, SaleOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type SaleOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: SaleOrderScalarWhereInput
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ReturnOrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReturnOrderWhereUniqueInput
    update: XOR<ReturnOrderUpdateWithoutCustomerInput, ReturnOrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<ReturnOrderCreateWithoutCustomerInput, ReturnOrderUncheckedCreateWithoutCustomerInput>
  }

  export type ReturnOrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReturnOrderWhereUniqueInput
    data: XOR<ReturnOrderUpdateWithoutCustomerInput, ReturnOrderUncheckedUpdateWithoutCustomerInput>
  }

  export type ReturnOrderUpdateManyWithWhereWithoutCustomerInput = {
    where: ReturnOrderScalarWhereInput
    data: XOR<ReturnOrderUpdateManyMutationInput, ReturnOrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutGroupInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutGroupInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutGroupInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput>
  }

  export type CustomerCreateManyGroupInputEnvelope = {
    data: CustomerCreateManyGroupInput | CustomerCreateManyGroupInput[]
  }

  export type CustomerUpsertWithWhereUniqueWithoutGroupInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutGroupInput, CustomerUncheckedUpdateWithoutGroupInput>
    create: XOR<CustomerCreateWithoutGroupInput, CustomerUncheckedCreateWithoutGroupInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutGroupInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutGroupInput, CustomerUncheckedUpdateWithoutGroupInput>
  }

  export type CustomerUpdateManyWithWhereWithoutGroupInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutGroupInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    code?: StringFilter<"Customer"> | string
    firstName?: StringFilter<"Customer"> | string
    lastName?: StringFilter<"Customer"> | string
    email?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Customer"> | Date | string | null
    gender?: StringNullableFilter<"Customer"> | string | null
    type?: EnumCustomerTypeFilter<"Customer"> | $Enums.CustomerType
    groupId?: StringNullableFilter<"Customer"> | string | null
    loyaltyPoints?: IntFilter<"Customer"> | number
    totalSpent?: FloatFilter<"Customer"> | number
    totalOrders?: IntFilter<"Customer"> | number
    creditLimit?: FloatNullableFilter<"Customer"> | number | null
    currentBalance?: FloatFilter<"Customer"> | number
    allowMarketing?: BoolFilter<"Customer"> | boolean
    notes?: StringNullableFilter<"Customer"> | string | null
    syncVersion?: IntFilter<"Customer"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Customer"> | Date | string | null
    isDirty?: BoolFilter<"Customer"> | boolean
    isActive?: BoolFilter<"Customer"> | boolean
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
  }

  export type CustomerCreateWithoutAddressesInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: CustomerGroupCreateNestedOneWithoutCustomersInput
    saleOrders?: SaleOrderCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAddressesInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    groupId?: string | null
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAddressesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
  }

  export type CustomerUpsertWithoutAddressesInput = {
    update: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
    create: XOR<CustomerCreateWithoutAddressesInput, CustomerUncheckedCreateWithoutAddressesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAddressesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAddressesInput, CustomerUncheckedUpdateWithoutAddressesInput>
  }

  export type CustomerUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CustomerGroupUpdateOneWithoutCustomersNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ProductVariantCreateWithoutInventoryItemsInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutInventoryItemsInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutInventoryItemsInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutInventoryItemsInput, ProductVariantUncheckedCreateWithoutInventoryItemsInput>
  }

  export type LocationCreateWithoutInventoryItemsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutInventoryItemsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutInventoryItemsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutInventoryItemsInput, LocationUncheckedCreateWithoutInventoryItemsInput>
  }

  export type ProductVariantUpsertWithoutInventoryItemsInput = {
    update: XOR<ProductVariantUpdateWithoutInventoryItemsInput, ProductVariantUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<ProductVariantCreateWithoutInventoryItemsInput, ProductVariantUncheckedCreateWithoutInventoryItemsInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutInventoryItemsInput, ProductVariantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type ProductVariantUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type LocationUpsertWithoutInventoryItemsInput = {
    update: XOR<LocationUpdateWithoutInventoryItemsInput, LocationUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<LocationCreateWithoutInventoryItemsInput, LocationUncheckedCreateWithoutInventoryItemsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutInventoryItemsInput, LocationUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type LocationUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateWithoutStockAdjustmentsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStockAdjustmentsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStockAdjustmentsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockAdjustmentsInput, LocationUncheckedCreateWithoutStockAdjustmentsInput>
  }

  export type StockAdjustmentLineCreateWithoutAdjustmentInput = {
    id?: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
    variant: ProductVariantCreateNestedOneWithoutStockAdjustmentLinesInput
  }

  export type StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput = {
    id?: string
    variantId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockAdjustmentLineCreateOrConnectWithoutAdjustmentInput = {
    where: StockAdjustmentLineWhereUniqueInput
    create: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput>
  }

  export type StockAdjustmentLineCreateManyAdjustmentInputEnvelope = {
    data: StockAdjustmentLineCreateManyAdjustmentInput | StockAdjustmentLineCreateManyAdjustmentInput[]
  }

  export type LocationUpsertWithoutStockAdjustmentsInput = {
    update: XOR<LocationUpdateWithoutStockAdjustmentsInput, LocationUncheckedUpdateWithoutStockAdjustmentsInput>
    create: XOR<LocationCreateWithoutStockAdjustmentsInput, LocationUncheckedCreateWithoutStockAdjustmentsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockAdjustmentsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockAdjustmentsInput, LocationUncheckedUpdateWithoutStockAdjustmentsInput>
  }

  export type LocationUpdateWithoutStockAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type StockAdjustmentLineUpsertWithWhereUniqueWithoutAdjustmentInput = {
    where: StockAdjustmentLineWhereUniqueInput
    update: XOR<StockAdjustmentLineUpdateWithoutAdjustmentInput, StockAdjustmentLineUncheckedUpdateWithoutAdjustmentInput>
    create: XOR<StockAdjustmentLineCreateWithoutAdjustmentInput, StockAdjustmentLineUncheckedCreateWithoutAdjustmentInput>
  }

  export type StockAdjustmentLineUpdateWithWhereUniqueWithoutAdjustmentInput = {
    where: StockAdjustmentLineWhereUniqueInput
    data: XOR<StockAdjustmentLineUpdateWithoutAdjustmentInput, StockAdjustmentLineUncheckedUpdateWithoutAdjustmentInput>
  }

  export type StockAdjustmentLineUpdateManyWithWhereWithoutAdjustmentInput = {
    where: StockAdjustmentLineScalarWhereInput
    data: XOR<StockAdjustmentLineUpdateManyMutationInput, StockAdjustmentLineUncheckedUpdateManyWithoutAdjustmentInput>
  }

  export type StockAdjustmentCreateWithoutLineItemsInput = {
    id?: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    location: LocationCreateNestedOneWithoutStockAdjustmentsInput
  }

  export type StockAdjustmentUncheckedCreateWithoutLineItemsInput = {
    id?: string
    locationId: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type StockAdjustmentCreateOrConnectWithoutLineItemsInput = {
    where: StockAdjustmentWhereUniqueInput
    create: XOR<StockAdjustmentCreateWithoutLineItemsInput, StockAdjustmentUncheckedCreateWithoutLineItemsInput>
  }

  export type ProductVariantCreateWithoutStockAdjustmentLinesInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutStockAdjustmentLinesInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockAdjustmentLinesInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedCreateWithoutStockAdjustmentLinesInput>
  }

  export type StockAdjustmentUpsertWithoutLineItemsInput = {
    update: XOR<StockAdjustmentUpdateWithoutLineItemsInput, StockAdjustmentUncheckedUpdateWithoutLineItemsInput>
    create: XOR<StockAdjustmentCreateWithoutLineItemsInput, StockAdjustmentUncheckedCreateWithoutLineItemsInput>
    where?: StockAdjustmentWhereInput
  }

  export type StockAdjustmentUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: StockAdjustmentWhereInput
    data: XOR<StockAdjustmentUpdateWithoutLineItemsInput, StockAdjustmentUncheckedUpdateWithoutLineItemsInput>
  }

  export type StockAdjustmentUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutStockAdjustmentsNestedInput
  }

  export type StockAdjustmentUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUpsertWithoutStockAdjustmentLinesInput = {
    update: XOR<ProductVariantUpdateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedUpdateWithoutStockAdjustmentLinesInput>
    create: XOR<ProductVariantCreateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedCreateWithoutStockAdjustmentLinesInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockAdjustmentLinesInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockAdjustmentLinesInput, ProductVariantUncheckedUpdateWithoutStockAdjustmentLinesInput>
  }

  export type ProductVariantUpdateWithoutStockAdjustmentLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockAdjustmentLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type LocationCreateWithoutStockTransfersFromInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStockTransfersFromInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStockTransfersFromInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockTransfersFromInput, LocationUncheckedCreateWithoutStockTransfersFromInput>
  }

  export type LocationCreateWithoutStockTransfersToInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutStockTransfersToInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutStockTransfersToInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStockTransfersToInput, LocationUncheckedCreateWithoutStockTransfersToInput>
  }

  export type StockTransferLineCreateWithoutTransferInput = {
    id?: string
    quantity: number
    received?: number | null
    variant: ProductVariantCreateNestedOneWithoutStockTransferLinesInput
  }

  export type StockTransferLineUncheckedCreateWithoutTransferInput = {
    id?: string
    variantId: string
    quantity: number
    received?: number | null
  }

  export type StockTransferLineCreateOrConnectWithoutTransferInput = {
    where: StockTransferLineWhereUniqueInput
    create: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput>
  }

  export type StockTransferLineCreateManyTransferInputEnvelope = {
    data: StockTransferLineCreateManyTransferInput | StockTransferLineCreateManyTransferInput[]
  }

  export type LocationUpsertWithoutStockTransfersFromInput = {
    update: XOR<LocationUpdateWithoutStockTransfersFromInput, LocationUncheckedUpdateWithoutStockTransfersFromInput>
    create: XOR<LocationCreateWithoutStockTransfersFromInput, LocationUncheckedCreateWithoutStockTransfersFromInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockTransfersFromInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockTransfersFromInput, LocationUncheckedUpdateWithoutStockTransfersFromInput>
  }

  export type LocationUpdateWithoutStockTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockTransfersFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUpsertWithoutStockTransfersToInput = {
    update: XOR<LocationUpdateWithoutStockTransfersToInput, LocationUncheckedUpdateWithoutStockTransfersToInput>
    create: XOR<LocationCreateWithoutStockTransfersToInput, LocationUncheckedCreateWithoutStockTransfersToInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStockTransfersToInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStockTransfersToInput, LocationUncheckedUpdateWithoutStockTransfersToInput>
  }

  export type LocationUpdateWithoutStockTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStockTransfersToInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type StockTransferLineUpsertWithWhereUniqueWithoutTransferInput = {
    where: StockTransferLineWhereUniqueInput
    update: XOR<StockTransferLineUpdateWithoutTransferInput, StockTransferLineUncheckedUpdateWithoutTransferInput>
    create: XOR<StockTransferLineCreateWithoutTransferInput, StockTransferLineUncheckedCreateWithoutTransferInput>
  }

  export type StockTransferLineUpdateWithWhereUniqueWithoutTransferInput = {
    where: StockTransferLineWhereUniqueInput
    data: XOR<StockTransferLineUpdateWithoutTransferInput, StockTransferLineUncheckedUpdateWithoutTransferInput>
  }

  export type StockTransferLineUpdateManyWithWhereWithoutTransferInput = {
    where: StockTransferLineScalarWhereInput
    data: XOR<StockTransferLineUpdateManyMutationInput, StockTransferLineUncheckedUpdateManyWithoutTransferInput>
  }

  export type StockTransferCreateWithoutLineItemsInput = {
    id?: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fromLocation: LocationCreateNestedOneWithoutStockTransfersFromInput
    toLocation: LocationCreateNestedOneWithoutStockTransfersToInput
  }

  export type StockTransferUncheckedCreateWithoutLineItemsInput = {
    id?: string
    fromLocationId: string
    toLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferCreateOrConnectWithoutLineItemsInput = {
    where: StockTransferWhereUniqueInput
    create: XOR<StockTransferCreateWithoutLineItemsInput, StockTransferUncheckedCreateWithoutLineItemsInput>
  }

  export type ProductVariantCreateWithoutStockTransferLinesInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutStockTransferLinesInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutStockTransferLinesInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutStockTransferLinesInput, ProductVariantUncheckedCreateWithoutStockTransferLinesInput>
  }

  export type StockTransferUpsertWithoutLineItemsInput = {
    update: XOR<StockTransferUpdateWithoutLineItemsInput, StockTransferUncheckedUpdateWithoutLineItemsInput>
    create: XOR<StockTransferCreateWithoutLineItemsInput, StockTransferUncheckedCreateWithoutLineItemsInput>
    where?: StockTransferWhereInput
  }

  export type StockTransferUpdateToOneWithWhereWithoutLineItemsInput = {
    where?: StockTransferWhereInput
    data: XOR<StockTransferUpdateWithoutLineItemsInput, StockTransferUncheckedUpdateWithoutLineItemsInput>
  }

  export type StockTransferUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromLocation?: LocationUpdateOneRequiredWithoutStockTransfersFromNestedInput
    toLocation?: LocationUpdateOneRequiredWithoutStockTransfersToNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutLineItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromLocationId?: StringFieldUpdateOperationsInput | string
    toLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUpsertWithoutStockTransferLinesInput = {
    update: XOR<ProductVariantUpdateWithoutStockTransferLinesInput, ProductVariantUncheckedUpdateWithoutStockTransferLinesInput>
    create: XOR<ProductVariantCreateWithoutStockTransferLinesInput, ProductVariantUncheckedCreateWithoutStockTransferLinesInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutStockTransferLinesInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutStockTransferLinesInput, ProductVariantUncheckedUpdateWithoutStockTransferLinesInput>
  }

  export type ProductVariantUpdateWithoutStockTransferLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutStockTransferLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type LocationCreateWithoutSaleOrdersInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutSaleOrdersInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutSaleOrdersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutSaleOrdersInput, LocationUncheckedCreateWithoutSaleOrdersInput>
  }

  export type TerminalCreateWithoutSaleOrdersInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    shifts?: ShiftCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutSaleOrdersInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutSaleOrdersInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutSaleOrdersInput, TerminalUncheckedCreateWithoutSaleOrdersInput>
  }

  export type CustomerCreateWithoutSaleOrdersInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: CustomerGroupCreateNestedOneWithoutCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSaleOrdersInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    groupId?: string | null
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSaleOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSaleOrdersInput, CustomerUncheckedCreateWithoutSaleOrdersInput>
  }

  export type ShiftCreateWithoutSaleOrdersInput = {
    id?: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    location: LocationCreateNestedOneWithoutShiftsInput
    terminal?: TerminalCreateNestedOneWithoutShiftsInput
    user: LocalUserCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutSaleOrdersInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ShiftCreateOrConnectWithoutSaleOrdersInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutSaleOrdersInput, ShiftUncheckedCreateWithoutSaleOrdersInput>
  }

  export type LocalUserCreateWithoutSaleOrdersInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type LocalUserUncheckedCreateWithoutSaleOrdersInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type LocalUserCreateOrConnectWithoutSaleOrdersInput = {
    where: LocalUserWhereUniqueInput
    create: XOR<LocalUserCreateWithoutSaleOrdersInput, LocalUserUncheckedCreateWithoutSaleOrdersInput>
  }

  export type SaleOrderLineCreateWithoutOrderInput = {
    id?: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutSaleOrderLinesInput
  }

  export type SaleOrderLineUncheckedCreateWithoutOrderInput = {
    id?: string
    variantId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderLineCreateOrConnectWithoutOrderInput = {
    where: SaleOrderLineWhereUniqueInput
    create: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type SaleOrderLineCreateManyOrderInputEnvelope = {
    data: SaleOrderLineCreateManyOrderInput | SaleOrderLineCreateManyOrderInput[]
  }

  export type PaymentCreateWithoutOrderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentCreateManyOrderInputEnvelope = {
    data: PaymentCreateManyOrderInput | PaymentCreateManyOrderInput[]
  }

  export type DiscountCreateWithoutOrderInput = {
    id?: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type DiscountUncheckedCreateWithoutOrderInput = {
    id?: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type DiscountCreateOrConnectWithoutOrderInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput>
  }

  export type DiscountCreateManyOrderInputEnvelope = {
    data: DiscountCreateManyOrderInput | DiscountCreateManyOrderInput[]
  }

  export type ReturnOrderCreateWithoutOriginalOrderInput = {
    id?: string
    returnNumber: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutReturnOrdersInput
    location: LocationCreateNestedOneWithoutReturnOrdersInput
    lines?: ReturnOrderLineCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderUncheckedCreateWithoutOriginalOrderInput = {
    id?: string
    returnNumber: string
    customerId?: string | null
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: ReturnOrderLineUncheckedCreateNestedManyWithoutReturnOrderInput
  }

  export type ReturnOrderCreateOrConnectWithoutOriginalOrderInput = {
    where: ReturnOrderWhereUniqueInput
    create: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput>
  }

  export type ReturnOrderCreateManyOriginalOrderInputEnvelope = {
    data: ReturnOrderCreateManyOriginalOrderInput | ReturnOrderCreateManyOriginalOrderInput[]
  }

  export type ParkedOrderCreateWithoutOrderInput = {
    id?: string
    parkNumber: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ParkedOrderUncheckedCreateWithoutOrderInput = {
    id?: string
    parkNumber: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ParkedOrderCreateOrConnectWithoutOrderInput = {
    where: ParkedOrderWhereUniqueInput
    create: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput>
  }

  export type ParkedOrderCreateManyOrderInputEnvelope = {
    data: ParkedOrderCreateManyOrderInput | ParkedOrderCreateManyOrderInput[]
  }

  export type ExchangeOrderCreateWithoutOriginalOrderInput = {
    id?: string
    exchangeNumber: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    newOrder: SaleOrderCreateNestedOneWithoutExchangesToInput
  }

  export type ExchangeOrderUncheckedCreateWithoutOriginalOrderInput = {
    id?: string
    exchangeNumber: string
    newOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderCreateOrConnectWithoutOriginalOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    create: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput>
  }

  export type ExchangeOrderCreateManyOriginalOrderInputEnvelope = {
    data: ExchangeOrderCreateManyOriginalOrderInput | ExchangeOrderCreateManyOriginalOrderInput[]
  }

  export type ExchangeOrderCreateWithoutNewOrderInput = {
    id?: string
    exchangeNumber: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    originalOrder: SaleOrderCreateNestedOneWithoutExchangesFromInput
  }

  export type ExchangeOrderUncheckedCreateWithoutNewOrderInput = {
    id?: string
    exchangeNumber: string
    originalOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderCreateOrConnectWithoutNewOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    create: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput>
  }

  export type ExchangeOrderCreateManyNewOrderInputEnvelope = {
    data: ExchangeOrderCreateManyNewOrderInput | ExchangeOrderCreateManyNewOrderInput[]
  }

  export type LocationUpsertWithoutSaleOrdersInput = {
    update: XOR<LocationUpdateWithoutSaleOrdersInput, LocationUncheckedUpdateWithoutSaleOrdersInput>
    create: XOR<LocationCreateWithoutSaleOrdersInput, LocationUncheckedCreateWithoutSaleOrdersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutSaleOrdersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutSaleOrdersInput, LocationUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type LocationUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type TerminalUpsertWithoutSaleOrdersInput = {
    update: XOR<TerminalUpdateWithoutSaleOrdersInput, TerminalUncheckedUpdateWithoutSaleOrdersInput>
    create: XOR<TerminalCreateWithoutSaleOrdersInput, TerminalUncheckedCreateWithoutSaleOrdersInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutSaleOrdersInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutSaleOrdersInput, TerminalUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type TerminalUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type CustomerUpsertWithoutSaleOrdersInput = {
    update: XOR<CustomerUpdateWithoutSaleOrdersInput, CustomerUncheckedUpdateWithoutSaleOrdersInput>
    create: XOR<CustomerCreateWithoutSaleOrdersInput, CustomerUncheckedCreateWithoutSaleOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSaleOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSaleOrdersInput, CustomerUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type CustomerUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CustomerGroupUpdateOneWithoutCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type ShiftUpsertWithoutSaleOrdersInput = {
    update: XOR<ShiftUpdateWithoutSaleOrdersInput, ShiftUncheckedUpdateWithoutSaleOrdersInput>
    create: XOR<ShiftCreateWithoutSaleOrdersInput, ShiftUncheckedCreateWithoutSaleOrdersInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutSaleOrdersInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutSaleOrdersInput, ShiftUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type ShiftUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutShiftsNestedInput
    terminal?: TerminalUpdateOneWithoutShiftsNestedInput
    user?: LocalUserUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LocalUserUpsertWithoutSaleOrdersInput = {
    update: XOR<LocalUserUpdateWithoutSaleOrdersInput, LocalUserUncheckedUpdateWithoutSaleOrdersInput>
    create: XOR<LocalUserCreateWithoutSaleOrdersInput, LocalUserUncheckedCreateWithoutSaleOrdersInput>
    where?: LocalUserWhereInput
  }

  export type LocalUserUpdateToOneWithWhereWithoutSaleOrdersInput = {
    where?: LocalUserWhereInput
    data: XOR<LocalUserUpdateWithoutSaleOrdersInput, LocalUserUncheckedUpdateWithoutSaleOrdersInput>
  }

  export type LocalUserUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type LocalUserUncheckedUpdateWithoutSaleOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SaleOrderLineUpsertWithWhereUniqueWithoutOrderInput = {
    where: SaleOrderLineWhereUniqueInput
    update: XOR<SaleOrderLineUpdateWithoutOrderInput, SaleOrderLineUncheckedUpdateWithoutOrderInput>
    create: XOR<SaleOrderLineCreateWithoutOrderInput, SaleOrderLineUncheckedCreateWithoutOrderInput>
  }

  export type SaleOrderLineUpdateWithWhereUniqueWithoutOrderInput = {
    where: SaleOrderLineWhereUniqueInput
    data: XOR<SaleOrderLineUpdateWithoutOrderInput, SaleOrderLineUncheckedUpdateWithoutOrderInput>
  }

  export type SaleOrderLineUpdateManyWithWhereWithoutOrderInput = {
    where: SaleOrderLineScalarWhereInput
    data: XOR<SaleOrderLineUpdateManyMutationInput, SaleOrderLineUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutOrderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    orderId?: StringFilter<"Payment"> | string
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    reference?: StringNullableFilter<"Payment"> | string | null
    cardLast4?: StringNullableFilter<"Payment"> | string | null
    cardBrand?: StringNullableFilter<"Payment"> | string | null
    authCode?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    syncVersion?: IntFilter<"Payment"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    isDirty?: BoolFilter<"Payment"> | boolean
    syncPriority?: IntFilter<"Payment"> | number
    processedAt?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type DiscountUpsertWithWhereUniqueWithoutOrderInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutOrderInput, DiscountUncheckedUpdateWithoutOrderInput>
    create: XOR<DiscountCreateWithoutOrderInput, DiscountUncheckedCreateWithoutOrderInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutOrderInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutOrderInput, DiscountUncheckedUpdateWithoutOrderInput>
  }

  export type DiscountUpdateManyWithWhereWithoutOrderInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutOrderInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    OR?: DiscountScalarWhereInput[]
    NOT?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    id?: StringFilter<"Discount"> | string
    orderId?: StringFilter<"Discount"> | string
    type?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    name?: StringFilter<"Discount"> | string
    code?: StringNullableFilter<"Discount"> | string | null
    amount?: FloatFilter<"Discount"> | number
    percent?: FloatNullableFilter<"Discount"> | number | null
    syncVersion?: IntFilter<"Discount"> | number
    lastSyncedAt?: DateTimeNullableFilter<"Discount"> | Date | string | null
    isDirty?: BoolFilter<"Discount"> | boolean
    createdAt?: DateTimeFilter<"Discount"> | Date | string
  }

  export type ReturnOrderUpsertWithWhereUniqueWithoutOriginalOrderInput = {
    where: ReturnOrderWhereUniqueInput
    update: XOR<ReturnOrderUpdateWithoutOriginalOrderInput, ReturnOrderUncheckedUpdateWithoutOriginalOrderInput>
    create: XOR<ReturnOrderCreateWithoutOriginalOrderInput, ReturnOrderUncheckedCreateWithoutOriginalOrderInput>
  }

  export type ReturnOrderUpdateWithWhereUniqueWithoutOriginalOrderInput = {
    where: ReturnOrderWhereUniqueInput
    data: XOR<ReturnOrderUpdateWithoutOriginalOrderInput, ReturnOrderUncheckedUpdateWithoutOriginalOrderInput>
  }

  export type ReturnOrderUpdateManyWithWhereWithoutOriginalOrderInput = {
    where: ReturnOrderScalarWhereInput
    data: XOR<ReturnOrderUpdateManyMutationInput, ReturnOrderUncheckedUpdateManyWithoutOriginalOrderInput>
  }

  export type ParkedOrderUpsertWithWhereUniqueWithoutOrderInput = {
    where: ParkedOrderWhereUniqueInput
    update: XOR<ParkedOrderUpdateWithoutOrderInput, ParkedOrderUncheckedUpdateWithoutOrderInput>
    create: XOR<ParkedOrderCreateWithoutOrderInput, ParkedOrderUncheckedCreateWithoutOrderInput>
  }

  export type ParkedOrderUpdateWithWhereUniqueWithoutOrderInput = {
    where: ParkedOrderWhereUniqueInput
    data: XOR<ParkedOrderUpdateWithoutOrderInput, ParkedOrderUncheckedUpdateWithoutOrderInput>
  }

  export type ParkedOrderUpdateManyWithWhereWithoutOrderInput = {
    where: ParkedOrderScalarWhereInput
    data: XOR<ParkedOrderUpdateManyMutationInput, ParkedOrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type ParkedOrderScalarWhereInput = {
    AND?: ParkedOrderScalarWhereInput | ParkedOrderScalarWhereInput[]
    OR?: ParkedOrderScalarWhereInput[]
    NOT?: ParkedOrderScalarWhereInput | ParkedOrderScalarWhereInput[]
    id?: StringFilter<"ParkedOrder"> | string
    parkNumber?: StringFilter<"ParkedOrder"> | string
    orderId?: StringFilter<"ParkedOrder"> | string
    customerId?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedBy?: StringNullableFilter<"ParkedOrder"> | string | null
    parkedAt?: DateTimeFilter<"ParkedOrder"> | Date | string
    expiryDate?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    notes?: StringNullableFilter<"ParkedOrder"> | string | null
    syncVersion?: IntFilter<"ParkedOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ParkedOrder"> | Date | string | null
    isDirty?: BoolFilter<"ParkedOrder"> | boolean
  }

  export type ExchangeOrderUpsertWithWhereUniqueWithoutOriginalOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    update: XOR<ExchangeOrderUpdateWithoutOriginalOrderInput, ExchangeOrderUncheckedUpdateWithoutOriginalOrderInput>
    create: XOR<ExchangeOrderCreateWithoutOriginalOrderInput, ExchangeOrderUncheckedCreateWithoutOriginalOrderInput>
  }

  export type ExchangeOrderUpdateWithWhereUniqueWithoutOriginalOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    data: XOR<ExchangeOrderUpdateWithoutOriginalOrderInput, ExchangeOrderUncheckedUpdateWithoutOriginalOrderInput>
  }

  export type ExchangeOrderUpdateManyWithWhereWithoutOriginalOrderInput = {
    where: ExchangeOrderScalarWhereInput
    data: XOR<ExchangeOrderUpdateManyMutationInput, ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderInput>
  }

  export type ExchangeOrderScalarWhereInput = {
    AND?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
    OR?: ExchangeOrderScalarWhereInput[]
    NOT?: ExchangeOrderScalarWhereInput | ExchangeOrderScalarWhereInput[]
    id?: StringFilter<"ExchangeOrder"> | string
    exchangeNumber?: StringFilter<"ExchangeOrder"> | string
    originalOrderId?: StringFilter<"ExchangeOrder"> | string
    newOrderId?: StringFilter<"ExchangeOrder"> | string
    priceDifference?: FloatFilter<"ExchangeOrder"> | number
    additionalPayment?: FloatFilter<"ExchangeOrder"> | number
    refundAmount?: FloatFilter<"ExchangeOrder"> | number
    processedBy?: StringNullableFilter<"ExchangeOrder"> | string | null
    processedAt?: DateTimeFilter<"ExchangeOrder"> | Date | string
    syncVersion?: IntFilter<"ExchangeOrder"> | number
    lastSyncedAt?: DateTimeNullableFilter<"ExchangeOrder"> | Date | string | null
    isDirty?: BoolFilter<"ExchangeOrder"> | boolean
  }

  export type ExchangeOrderUpsertWithWhereUniqueWithoutNewOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    update: XOR<ExchangeOrderUpdateWithoutNewOrderInput, ExchangeOrderUncheckedUpdateWithoutNewOrderInput>
    create: XOR<ExchangeOrderCreateWithoutNewOrderInput, ExchangeOrderUncheckedCreateWithoutNewOrderInput>
  }

  export type ExchangeOrderUpdateWithWhereUniqueWithoutNewOrderInput = {
    where: ExchangeOrderWhereUniqueInput
    data: XOR<ExchangeOrderUpdateWithoutNewOrderInput, ExchangeOrderUncheckedUpdateWithoutNewOrderInput>
  }

  export type ExchangeOrderUpdateManyWithWhereWithoutNewOrderInput = {
    where: ExchangeOrderScalarWhereInput
    data: XOR<ExchangeOrderUpdateManyMutationInput, ExchangeOrderUncheckedUpdateManyWithoutNewOrderInput>
  }

  export type SaleOrderCreateWithoutLinesInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutLinesInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutLinesInput, SaleOrderUncheckedCreateWithoutLinesInput>
  }

  export type ProductVariantCreateWithoutSaleOrderLinesInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutSaleOrderLinesInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    returnOrderLines?: ReturnOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutSaleOrderLinesInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutSaleOrderLinesInput, ProductVariantUncheckedCreateWithoutSaleOrderLinesInput>
  }

  export type SaleOrderUpsertWithoutLinesInput = {
    update: XOR<SaleOrderUpdateWithoutLinesInput, SaleOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<SaleOrderCreateWithoutLinesInput, SaleOrderUncheckedCreateWithoutLinesInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutLinesInput, SaleOrderUncheckedUpdateWithoutLinesInput>
  }

  export type SaleOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type ProductVariantUpsertWithoutSaleOrderLinesInput = {
    update: XOR<ProductVariantUpdateWithoutSaleOrderLinesInput, ProductVariantUncheckedUpdateWithoutSaleOrderLinesInput>
    create: XOR<ProductVariantCreateWithoutSaleOrderLinesInput, ProductVariantUncheckedCreateWithoutSaleOrderLinesInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutSaleOrderLinesInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutSaleOrderLinesInput, ProductVariantUncheckedUpdateWithoutSaleOrderLinesInput>
  }

  export type ProductVariantUpdateWithoutSaleOrderLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutSaleOrderLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type SaleOrderCreateWithoutPaymentsInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutPaymentsInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutPaymentsInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutPaymentsInput, SaleOrderUncheckedCreateWithoutPaymentsInput>
  }

  export type SaleOrderUpsertWithoutPaymentsInput = {
    update: XOR<SaleOrderUpdateWithoutPaymentsInput, SaleOrderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SaleOrderCreateWithoutPaymentsInput, SaleOrderUncheckedCreateWithoutPaymentsInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutPaymentsInput, SaleOrderUncheckedUpdateWithoutPaymentsInput>
  }

  export type SaleOrderUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderCreateWithoutDiscountsInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutDiscountsInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutDiscountsInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutDiscountsInput, SaleOrderUncheckedCreateWithoutDiscountsInput>
  }

  export type SaleOrderUpsertWithoutDiscountsInput = {
    update: XOR<SaleOrderUpdateWithoutDiscountsInput, SaleOrderUncheckedUpdateWithoutDiscountsInput>
    create: XOR<SaleOrderCreateWithoutDiscountsInput, SaleOrderUncheckedCreateWithoutDiscountsInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutDiscountsInput, SaleOrderUncheckedUpdateWithoutDiscountsInput>
  }

  export type SaleOrderUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderCreateWithoutReturnOrdersInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutReturnOrdersInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutReturnOrdersInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutReturnOrdersInput, SaleOrderUncheckedCreateWithoutReturnOrdersInput>
  }

  export type CustomerCreateWithoutReturnOrdersInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    group?: CustomerGroupCreateNestedOneWithoutCustomersInput
    addresses?: CustomerAddressCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutReturnOrdersInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    groupId?: string | null
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: CustomerAddressUncheckedCreateNestedManyWithoutCustomerInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutReturnOrdersInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutReturnOrdersInput, CustomerUncheckedCreateWithoutReturnOrdersInput>
  }

  export type LocationCreateWithoutReturnOrdersInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    shifts?: ShiftCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
  }

  export type LocationUncheckedCreateWithoutReturnOrdersInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
  }

  export type LocationCreateOrConnectWithoutReturnOrdersInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutReturnOrdersInput, LocationUncheckedCreateWithoutReturnOrdersInput>
  }

  export type ReturnOrderLineCreateWithoutReturnOrderInput = {
    id?: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
    variant: ProductVariantCreateNestedOneWithoutReturnOrderLinesInput
  }

  export type ReturnOrderLineUncheckedCreateWithoutReturnOrderInput = {
    id?: string
    variantId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReturnOrderLineCreateOrConnectWithoutReturnOrderInput = {
    where: ReturnOrderLineWhereUniqueInput
    create: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput>
  }

  export type ReturnOrderLineCreateManyReturnOrderInputEnvelope = {
    data: ReturnOrderLineCreateManyReturnOrderInput | ReturnOrderLineCreateManyReturnOrderInput[]
  }

  export type SaleOrderUpsertWithoutReturnOrdersInput = {
    update: XOR<SaleOrderUpdateWithoutReturnOrdersInput, SaleOrderUncheckedUpdateWithoutReturnOrdersInput>
    create: XOR<SaleOrderCreateWithoutReturnOrdersInput, SaleOrderUncheckedCreateWithoutReturnOrdersInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutReturnOrdersInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutReturnOrdersInput, SaleOrderUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type SaleOrderUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type CustomerUpsertWithoutReturnOrdersInput = {
    update: XOR<CustomerUpdateWithoutReturnOrdersInput, CustomerUncheckedUpdateWithoutReturnOrdersInput>
    create: XOR<CustomerCreateWithoutReturnOrdersInput, CustomerUncheckedCreateWithoutReturnOrdersInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutReturnOrdersInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutReturnOrdersInput, CustomerUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type CustomerUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    group?: CustomerGroupUpdateOneWithoutCustomersNestedInput
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type LocationUpsertWithoutReturnOrdersInput = {
    update: XOR<LocationUpdateWithoutReturnOrdersInput, LocationUncheckedUpdateWithoutReturnOrdersInput>
    create: XOR<LocationCreateWithoutReturnOrdersInput, LocationUncheckedCreateWithoutReturnOrdersInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutReturnOrdersInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutReturnOrdersInput, LocationUncheckedUpdateWithoutReturnOrdersInput>
  }

  export type LocationUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutReturnOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
  }

  export type ReturnOrderLineUpsertWithWhereUniqueWithoutReturnOrderInput = {
    where: ReturnOrderLineWhereUniqueInput
    update: XOR<ReturnOrderLineUpdateWithoutReturnOrderInput, ReturnOrderLineUncheckedUpdateWithoutReturnOrderInput>
    create: XOR<ReturnOrderLineCreateWithoutReturnOrderInput, ReturnOrderLineUncheckedCreateWithoutReturnOrderInput>
  }

  export type ReturnOrderLineUpdateWithWhereUniqueWithoutReturnOrderInput = {
    where: ReturnOrderLineWhereUniqueInput
    data: XOR<ReturnOrderLineUpdateWithoutReturnOrderInput, ReturnOrderLineUncheckedUpdateWithoutReturnOrderInput>
  }

  export type ReturnOrderLineUpdateManyWithWhereWithoutReturnOrderInput = {
    where: ReturnOrderLineScalarWhereInput
    data: XOR<ReturnOrderLineUpdateManyMutationInput, ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderInput>
  }

  export type ReturnOrderCreateWithoutLinesInput = {
    id?: string
    returnNumber: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    originalOrder: SaleOrderCreateNestedOneWithoutReturnOrdersInput
    customer?: CustomerCreateNestedOneWithoutReturnOrdersInput
    location: LocationCreateNestedOneWithoutReturnOrdersInput
  }

  export type ReturnOrderUncheckedCreateWithoutLinesInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    customerId?: string | null
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnOrderCreateOrConnectWithoutLinesInput = {
    where: ReturnOrderWhereUniqueInput
    create: XOR<ReturnOrderCreateWithoutLinesInput, ReturnOrderUncheckedCreateWithoutLinesInput>
  }

  export type ProductVariantCreateWithoutReturnOrderLinesInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantUncheckedCreateWithoutReturnOrderLinesInput = {
    id: string
    productId: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutVariantInput
    saleOrderLines?: SaleOrderLineUncheckedCreateNestedManyWithoutVariantInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedCreateNestedManyWithoutVariantInput
    stockTransferLines?: StockTransferLineUncheckedCreateNestedManyWithoutVariantInput
  }

  export type ProductVariantCreateOrConnectWithoutReturnOrderLinesInput = {
    where: ProductVariantWhereUniqueInput
    create: XOR<ProductVariantCreateWithoutReturnOrderLinesInput, ProductVariantUncheckedCreateWithoutReturnOrderLinesInput>
  }

  export type ReturnOrderUpsertWithoutLinesInput = {
    update: XOR<ReturnOrderUpdateWithoutLinesInput, ReturnOrderUncheckedUpdateWithoutLinesInput>
    create: XOR<ReturnOrderCreateWithoutLinesInput, ReturnOrderUncheckedCreateWithoutLinesInput>
    where?: ReturnOrderWhereInput
  }

  export type ReturnOrderUpdateToOneWithWhereWithoutLinesInput = {
    where?: ReturnOrderWhereInput
    data: XOR<ReturnOrderUpdateWithoutLinesInput, ReturnOrderUncheckedUpdateWithoutLinesInput>
  }

  export type ReturnOrderUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOrder?: SaleOrderUpdateOneRequiredWithoutReturnOrdersNestedInput
    customer?: CustomerUpdateOneWithoutReturnOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutReturnOrdersNestedInput
  }

  export type ReturnOrderUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantUpsertWithoutReturnOrderLinesInput = {
    update: XOR<ProductVariantUpdateWithoutReturnOrderLinesInput, ProductVariantUncheckedUpdateWithoutReturnOrderLinesInput>
    create: XOR<ProductVariantCreateWithoutReturnOrderLinesInput, ProductVariantUncheckedCreateWithoutReturnOrderLinesInput>
    where?: ProductVariantWhereInput
  }

  export type ProductVariantUpdateToOneWithWhereWithoutReturnOrderLinesInput = {
    where?: ProductVariantWhereInput
    data: XOR<ProductVariantUpdateWithoutReturnOrderLinesInput, ProductVariantUncheckedUpdateWithoutReturnOrderLinesInput>
  }

  export type ProductVariantUpdateWithoutReturnOrderLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutReturnOrderLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type SaleOrderCreateWithoutExchangesFromInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutExchangesFromInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutExchangesFromInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutExchangesFromInput, SaleOrderUncheckedCreateWithoutExchangesFromInput>
  }

  export type SaleOrderCreateWithoutExchangesToInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutExchangesToInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutExchangesToInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutExchangesToInput, SaleOrderUncheckedCreateWithoutExchangesToInput>
  }

  export type SaleOrderUpsertWithoutExchangesFromInput = {
    update: XOR<SaleOrderUpdateWithoutExchangesFromInput, SaleOrderUncheckedUpdateWithoutExchangesFromInput>
    create: XOR<SaleOrderCreateWithoutExchangesFromInput, SaleOrderUncheckedCreateWithoutExchangesFromInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutExchangesFromInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutExchangesFromInput, SaleOrderUncheckedUpdateWithoutExchangesFromInput>
  }

  export type SaleOrderUpdateWithoutExchangesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutExchangesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUpsertWithoutExchangesToInput = {
    update: XOR<SaleOrderUpdateWithoutExchangesToInput, SaleOrderUncheckedUpdateWithoutExchangesToInput>
    create: XOR<SaleOrderCreateWithoutExchangesToInput, SaleOrderUncheckedCreateWithoutExchangesToInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutExchangesToInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutExchangesToInput, SaleOrderUncheckedUpdateWithoutExchangesToInput>
  }

  export type SaleOrderUpdateWithoutExchangesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutExchangesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
  }

  export type SaleOrderCreateWithoutParkedOrdersInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    shift?: ShiftCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutParkedOrdersInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutParkedOrdersInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutParkedOrdersInput, SaleOrderUncheckedCreateWithoutParkedOrdersInput>
  }

  export type SaleOrderUpsertWithoutParkedOrdersInput = {
    update: XOR<SaleOrderUpdateWithoutParkedOrdersInput, SaleOrderUncheckedUpdateWithoutParkedOrdersInput>
    create: XOR<SaleOrderCreateWithoutParkedOrdersInput, SaleOrderUncheckedCreateWithoutParkedOrdersInput>
    where?: SaleOrderWhereInput
  }

  export type SaleOrderUpdateToOneWithWhereWithoutParkedOrdersInput = {
    where?: SaleOrderWhereInput
    data: XOR<SaleOrderUpdateWithoutParkedOrdersInput, SaleOrderUncheckedUpdateWithoutParkedOrdersInput>
  }

  export type SaleOrderUpdateWithoutParkedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutParkedOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type LocationCreateWithoutShiftsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutShiftsInput = {
    id: string
    code: string
    name: string
    type?: $Enums.LocationType
    address?: string | null
    phone?: string | null
    centralLocationId?: string | null
    centralBranchId?: string | null
    timezone?: string
    taxRate?: number
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutLocationInput
    inventoryItems?: InventoryItemUncheckedCreateNestedManyWithoutLocationInput
    stockAdjustments?: StockAdjustmentUncheckedCreateNestedManyWithoutLocationInput
    stockTransfersFrom?: StockTransferUncheckedCreateNestedManyWithoutFromLocationInput
    stockTransfersTo?: StockTransferUncheckedCreateNestedManyWithoutToLocationInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutShiftsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutShiftsInput, LocationUncheckedCreateWithoutShiftsInput>
  }

  export type TerminalCreateWithoutShiftsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutShiftsInput = {
    id: string
    terminalCode: string
    terminalName: string
    macAddress: string
    centralTerminalId: string
    centralStoreId: string
    centralBranchId: string
    centralLocationId?: string | null
    apiKey: string
    sessionToken?: string | null
    sessionExpiry?: Date | string | null
    storeName?: string | null
    branchName?: string | null
    locationName?: string | null
    features: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    lastLoginAt?: Date | string | null
    currentShiftId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TerminalSessionUncheckedCreateNestedManyWithoutTerminalInput
    operationModes?: OperationModeUncheckedCreateNestedManyWithoutTerminalInput
    connectionLogs?: ConnectionLogUncheckedCreateNestedManyWithoutTerminalInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutTerminalInput
    outboxes?: OutboxUncheckedCreateNestedManyWithoutTerminalInput
    syncHistories?: SyncHistoryUncheckedCreateNestedManyWithoutTerminalInput
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutShiftsInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutShiftsInput, TerminalUncheckedCreateWithoutShiftsInput>
  }

  export type LocalUserCreateWithoutShiftsInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type LocalUserUncheckedCreateWithoutShiftsInput = {
    id: string
    username: string
    email: string
    passwordHash: string
    firstName: string
    lastName: string
    pinCode?: string | null
    role: $Enums.UserRole
    permissions: JsonNullValueInput | InputJsonValue
    centralUserId?: string | null
    isActive?: boolean
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    saleOrders?: SaleOrderUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type LocalUserCreateOrConnectWithoutShiftsInput = {
    where: LocalUserWhereUniqueInput
    create: XOR<LocalUserCreateWithoutShiftsInput, LocalUserUncheckedCreateWithoutShiftsInput>
  }

  export type SaleOrderCreateWithoutShiftInput = {
    id?: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutSaleOrdersInput
    terminal?: TerminalCreateNestedOneWithoutSaleOrdersInput
    customer?: CustomerCreateNestedOneWithoutSaleOrdersInput
    user?: LocalUserCreateNestedOneWithoutSaleOrdersInput
    lines?: SaleOrderLineCreateNestedManyWithoutOrderInput
    payments?: PaymentCreateNestedManyWithoutOrderInput
    discounts?: DiscountCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderUncheckedCreateWithoutShiftInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: SaleOrderLineUncheckedCreateNestedManyWithoutOrderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutOrderInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderInput
    returnOrders?: ReturnOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    parkedOrders?: ParkedOrderUncheckedCreateNestedManyWithoutOrderInput
    exchangesFrom?: ExchangeOrderUncheckedCreateNestedManyWithoutOriginalOrderInput
    exchangesTo?: ExchangeOrderUncheckedCreateNestedManyWithoutNewOrderInput
  }

  export type SaleOrderCreateOrConnectWithoutShiftInput = {
    where: SaleOrderWhereUniqueInput
    create: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput>
  }

  export type SaleOrderCreateManyShiftInputEnvelope = {
    data: SaleOrderCreateManyShiftInput | SaleOrderCreateManyShiftInput[]
  }

  export type LocationUpsertWithoutShiftsInput = {
    update: XOR<LocationUpdateWithoutShiftsInput, LocationUncheckedUpdateWithoutShiftsInput>
    create: XOR<LocationCreateWithoutShiftsInput, LocationUncheckedCreateWithoutShiftsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutShiftsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutShiftsInput, LocationUncheckedUpdateWithoutShiftsInput>
  }

  export type LocationUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLocationTypeFieldUpdateOperationsInput | $Enums.LocationType
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    centralBranchId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    taxRate?: FloatFieldUpdateOperationsInput | number
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutLocationNestedInput
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutLocationNestedInput
    stockAdjustments?: StockAdjustmentUncheckedUpdateManyWithoutLocationNestedInput
    stockTransfersFrom?: StockTransferUncheckedUpdateManyWithoutFromLocationNestedInput
    stockTransfersTo?: StockTransferUncheckedUpdateManyWithoutToLocationNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type TerminalUpsertWithoutShiftsInput = {
    update: XOR<TerminalUpdateWithoutShiftsInput, TerminalUncheckedUpdateWithoutShiftsInput>
    create: XOR<TerminalCreateWithoutShiftsInput, TerminalUncheckedCreateWithoutShiftsInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutShiftsInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutShiftsInput, TerminalUncheckedUpdateWithoutShiftsInput>
  }

  export type TerminalUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalCode?: StringFieldUpdateOperationsInput | string
    terminalName?: StringFieldUpdateOperationsInput | string
    macAddress?: StringFieldUpdateOperationsInput | string
    centralTerminalId?: StringFieldUpdateOperationsInput | string
    centralStoreId?: StringFieldUpdateOperationsInput | string
    centralBranchId?: StringFieldUpdateOperationsInput | string
    centralLocationId?: NullableStringFieldUpdateOperationsInput | string | null
    apiKey?: StringFieldUpdateOperationsInput | string
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    sessionExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    storeName?: NullableStringFieldUpdateOperationsInput | string | null
    branchName?: NullableStringFieldUpdateOperationsInput | string | null
    locationName?: NullableStringFieldUpdateOperationsInput | string | null
    features?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentShiftId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TerminalSessionUncheckedUpdateManyWithoutTerminalNestedInput
    operationModes?: OperationModeUncheckedUpdateManyWithoutTerminalNestedInput
    connectionLogs?: ConnectionLogUncheckedUpdateManyWithoutTerminalNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutTerminalNestedInput
    outboxes?: OutboxUncheckedUpdateManyWithoutTerminalNestedInput
    syncHistories?: SyncHistoryUncheckedUpdateManyWithoutTerminalNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type LocalUserUpsertWithoutShiftsInput = {
    update: XOR<LocalUserUpdateWithoutShiftsInput, LocalUserUncheckedUpdateWithoutShiftsInput>
    create: XOR<LocalUserCreateWithoutShiftsInput, LocalUserUncheckedCreateWithoutShiftsInput>
    where?: LocalUserWhereInput
  }

  export type LocalUserUpdateToOneWithWhereWithoutShiftsInput = {
    where?: LocalUserWhereInput
    data: XOR<LocalUserUpdateWithoutShiftsInput, LocalUserUncheckedUpdateWithoutShiftsInput>
  }

  export type LocalUserUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type LocalUserUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    pinCode?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    permissions?: JsonNullValueInput | InputJsonValue
    centralUserId?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SaleOrderUpsertWithWhereUniqueWithoutShiftInput = {
    where: SaleOrderWhereUniqueInput
    update: XOR<SaleOrderUpdateWithoutShiftInput, SaleOrderUncheckedUpdateWithoutShiftInput>
    create: XOR<SaleOrderCreateWithoutShiftInput, SaleOrderUncheckedCreateWithoutShiftInput>
  }

  export type SaleOrderUpdateWithWhereUniqueWithoutShiftInput = {
    where: SaleOrderWhereUniqueInput
    data: XOR<SaleOrderUpdateWithoutShiftInput, SaleOrderUncheckedUpdateWithoutShiftInput>
  }

  export type SaleOrderUpdateManyWithWhereWithoutShiftInput = {
    where: SaleOrderScalarWhereInput
    data: XOR<SaleOrderUpdateManyMutationInput, SaleOrderUncheckedUpdateManyWithoutShiftInput>
  }

  export type ProductCreateWithoutTaxCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutProductsInput
    brand?: BrandCreateNestedOneWithoutProductsInput
    variants?: ProductVariantCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTaxCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    brandId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: ProductVariantUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTaxCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput>
  }

  export type ProductCreateManyTaxCategoryInputEnvelope = {
    data: ProductCreateManyTaxCategoryInput | ProductCreateManyTaxCategoryInput[]
  }

  export type TaxRateCreateWithoutTaxCategoryInput = {
    id?: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateUncheckedCreateWithoutTaxCategoryInput = {
    id?: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateCreateOrConnectWithoutTaxCategoryInput = {
    where: TaxRateWhereUniqueInput
    create: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput>
  }

  export type TaxRateCreateManyTaxCategoryInputEnvelope = {
    data: TaxRateCreateManyTaxCategoryInput | TaxRateCreateManyTaxCategoryInput[]
  }

  export type ProductUpsertWithWhereUniqueWithoutTaxCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutTaxCategoryInput, ProductUncheckedUpdateWithoutTaxCategoryInput>
    create: XOR<ProductCreateWithoutTaxCategoryInput, ProductUncheckedCreateWithoutTaxCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutTaxCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutTaxCategoryInput, ProductUncheckedUpdateWithoutTaxCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutTaxCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutTaxCategoryInput>
  }

  export type TaxRateUpsertWithWhereUniqueWithoutTaxCategoryInput = {
    where: TaxRateWhereUniqueInput
    update: XOR<TaxRateUpdateWithoutTaxCategoryInput, TaxRateUncheckedUpdateWithoutTaxCategoryInput>
    create: XOR<TaxRateCreateWithoutTaxCategoryInput, TaxRateUncheckedCreateWithoutTaxCategoryInput>
  }

  export type TaxRateUpdateWithWhereUniqueWithoutTaxCategoryInput = {
    where: TaxRateWhereUniqueInput
    data: XOR<TaxRateUpdateWithoutTaxCategoryInput, TaxRateUncheckedUpdateWithoutTaxCategoryInput>
  }

  export type TaxRateUpdateManyWithWhereWithoutTaxCategoryInput = {
    where: TaxRateScalarWhereInput
    data: XOR<TaxRateUpdateManyMutationInput, TaxRateUncheckedUpdateManyWithoutTaxCategoryInput>
  }

  export type TaxRateScalarWhereInput = {
    AND?: TaxRateScalarWhereInput | TaxRateScalarWhereInput[]
    OR?: TaxRateScalarWhereInput[]
    NOT?: TaxRateScalarWhereInput | TaxRateScalarWhereInput[]
    id?: StringFilter<"TaxRate"> | string
    taxCategoryId?: StringFilter<"TaxRate"> | string
    name?: StringFilter<"TaxRate"> | string
    rate?: FloatFilter<"TaxRate"> | number
    country?: StringNullableFilter<"TaxRate"> | string | null
    state?: StringNullableFilter<"TaxRate"> | string | null
    city?: StringNullableFilter<"TaxRate"> | string | null
    isActive?: BoolFilter<"TaxRate"> | boolean
    effectiveFrom?: DateTimeFilter<"TaxRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    syncVersion?: IntFilter<"TaxRate"> | number
    lastSyncedAt?: DateTimeNullableFilter<"TaxRate"> | Date | string | null
    isDirty?: BoolFilter<"TaxRate"> | boolean
    createdAt?: DateTimeFilter<"TaxRate"> | Date | string
    updatedAt?: DateTimeFilter<"TaxRate"> | Date | string
  }

  export type TaxCategoryCreateWithoutRatesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryUncheckedCreateWithoutRatesInput = {
    id: string
    code: string
    name: string
    description?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutTaxCategoryInput
  }

  export type TaxCategoryCreateOrConnectWithoutRatesInput = {
    where: TaxCategoryWhereUniqueInput
    create: XOR<TaxCategoryCreateWithoutRatesInput, TaxCategoryUncheckedCreateWithoutRatesInput>
  }

  export type TaxCategoryUpsertWithoutRatesInput = {
    update: XOR<TaxCategoryUpdateWithoutRatesInput, TaxCategoryUncheckedUpdateWithoutRatesInput>
    create: XOR<TaxCategoryCreateWithoutRatesInput, TaxCategoryUncheckedCreateWithoutRatesInput>
    where?: TaxCategoryWhereInput
  }

  export type TaxCategoryUpdateToOneWithWhereWithoutRatesInput = {
    where?: TaxCategoryWhereInput
    data: XOR<TaxCategoryUpdateWithoutRatesInput, TaxCategoryUncheckedUpdateWithoutRatesInput>
  }

  export type TaxCategoryUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutTaxCategoryNestedInput
  }

  export type TaxCategoryUncheckedUpdateWithoutRatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutTaxCategoryNestedInput
  }

  export type TerminalSessionCreateManyTerminalInput = {
    id?: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    ipAddress?: string | null
    isActive?: boolean
  }

  export type OperationModeCreateManyTerminalInput = {
    id?: string
    currentMode?: $Enums.OperationModeType
    lastModeChange?: Date | string
    lastOnlineCheck?: Date | string | null
    centralBaseURL: string
    syncEndpoint: string
    heartbeatInterval?: number
    maxOfflineHours?: number
    offlineSince?: Date | string | null
  }

  export type ConnectionLogCreateManyTerminalInput = {
    id?: string
    mode: $Enums.OperationModeType
    timestamp?: Date | string
    durationMs?: number | null
    errorMessage?: string | null
    success?: boolean
  }

  export type UserSessionCreateManyTerminalInput = {
    id?: string
    userId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type OutboxCreateManyTerminalInput = {
    id?: string
    entityType: string
    entityId: string
    operation: $Enums.SyncOperation
    data: JsonNullValueInput | InputJsonValue
    createdInMode: $Enums.OperationModeType
    shiftId?: string | null
    userId?: string | null
    syncPriority?: number
    attemptCount?: number
    maxAttempts?: number
    lastAttemptAt?: Date | string | null
    errorMessage?: string | null
    createdAt?: Date | string
    localTimestamp?: Date | string
    syncVersion?: number
  }

  export type SyncHistoryCreateManyTerminalInput = {
    id?: string
    syncType: $Enums.SyncType
    direction: $Enums.SyncDirection
    entitiesProcessed?: number
    successCount?: number
    failureCount?: number
    conflictsFound?: number
    startedAt?: Date | string
    completedAt?: Date | string | null
    durationMs?: number | null
    success?: boolean
    errorMessage?: string | null
  }

  export type SaleOrderCreateManyTerminalInput = {
    id?: string
    locationId: string
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateManyTerminalInput = {
    id?: string
    locationId: string
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type TerminalSessionUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TerminalSessionUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TerminalSessionUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OperationModeUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationModeUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperationModeUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    currentMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    lastModeChange?: DateTimeFieldUpdateOperationsInput | Date | string
    lastOnlineCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    centralBaseURL?: StringFieldUpdateOperationsInput | string
    syncEndpoint?: StringFieldUpdateOperationsInput | string
    heartbeatInterval?: IntFieldUpdateOperationsInput | number
    maxOfflineHours?: IntFieldUpdateOperationsInput | number
    offlineSince?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConnectionLogUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionLogUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionLogUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    mode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: LocalUserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OutboxUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type OutboxUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type OutboxUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    operation?: EnumSyncOperationFieldUpdateOperationsInput | $Enums.SyncOperation
    data?: JsonNullValueInput | InputJsonValue
    createdInMode?: EnumOperationModeTypeFieldUpdateOperationsInput | $Enums.OperationModeType
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    syncPriority?: IntFieldUpdateOperationsInput | number
    attemptCount?: IntFieldUpdateOperationsInput | number
    maxAttempts?: IntFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    localTimestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
  }

  export type SyncHistoryUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncHistoryUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    syncType?: EnumSyncTypeFieldUpdateOperationsInput | $Enums.SyncType
    direction?: EnumSyncDirectionFieldUpdateOperationsInput | $Enums.SyncDirection
    entitiesProcessed?: IntFieldUpdateOperationsInput | number
    successCount?: IntFieldUpdateOperationsInput | number
    failureCount?: IntFieldUpdateOperationsInput | number
    conflictsFound?: IntFieldUpdateOperationsInput | number
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleOrderUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutShiftsNestedInput
    user?: LocalUserUpdateOneRequiredWithoutShiftsNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftCreateManyUserInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type SaleOrderCreateManyUserInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    terminalId: string
    sessionToken: string
    startedAt?: Date | string
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
  }

  export type ShiftUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    location?: LocationUpdateOneRequiredWithoutShiftsNestedInput
    terminal?: TerminalUpdateOneWithoutShiftsNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SaleOrderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    terminal?: TerminalUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SaleOrderCreateManyLocationInput = {
    id?: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryItemCreateManyLocationInput = {
    id: string
    variantId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateManyLocationInput = {
    id?: string
    terminalId?: string | null
    userId: string
    shiftNumber: string
    registerId?: string | null
    openingCash?: number
    closingCash?: number | null
    expectedCash?: number | null
    cashDifference?: number | null
    totalSales?: number
    totalRefunds?: number
    totalTransactions?: number
    openedAt?: Date | string
    closedAt?: Date | string | null
    status?: $Enums.ShiftStatus
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type StockAdjustmentCreateManyLocationInput = {
    id?: string
    adjustmentType: $Enums.StockAdjustmentType
    reason?: string | null
    referenceNumber?: string | null
    notes?: string | null
    adjustedBy?: string | null
    adjustedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type StockTransferCreateManyFromLocationInput = {
    id?: string
    toLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StockTransferCreateManyToLocationInput = {
    id?: string
    fromLocationId: string
    transferNumber: string
    status?: $Enums.TransferStatus
    transferDate?: Date | string
    notes?: string | null
    createdBy?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnOrderCreateManyLocationInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    customerId?: string | null
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    terminal?: TerminalUpdateOneWithoutShiftsNestedInput
    user?: LocalUserUpdateOneRequiredWithoutShiftsNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    shiftNumber?: StringFieldUpdateOperationsInput | string
    registerId?: NullableStringFieldUpdateOperationsInput | string | null
    openingCash?: FloatFieldUpdateOperationsInput | number
    closingCash?: NullableFloatFieldUpdateOperationsInput | number | null
    expectedCash?: NullableFloatFieldUpdateOperationsInput | number | null
    cashDifference?: NullableFloatFieldUpdateOperationsInput | number | null
    totalSales?: FloatFieldUpdateOperationsInput | number
    totalRefunds?: FloatFieldUpdateOperationsInput | number
    totalTransactions?: IntFieldUpdateOperationsInput | number
    openedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumShiftStatusFieldUpdateOperationsInput | $Enums.ShiftStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StockAdjustmentUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockAdjustmentLineUpdateManyWithoutAdjustmentNestedInput
  }

  export type StockAdjustmentUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockAdjustmentLineUncheckedUpdateManyWithoutAdjustmentNestedInput
  }

  export type StockAdjustmentUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumStockAdjustmentTypeFieldUpdateOperationsInput | $Enums.StockAdjustmentType
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedBy?: NullableStringFieldUpdateOperationsInput | string | null
    adjustedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUpdateWithoutFromLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toLocation?: LocationUpdateOneRequiredWithoutStockTransfersToNestedInput
    lineItems?: StockTransferLineUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutFromLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    toLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockTransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutFromLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    toLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockTransferUpdateWithoutToLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromLocation?: LocationUpdateOneRequiredWithoutStockTransfersFromNestedInput
    lineItems?: StockTransferLineUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateWithoutToLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineItems?: StockTransferLineUncheckedUpdateManyWithoutTransferNestedInput
  }

  export type StockTransferUncheckedUpdateManyWithoutToLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromLocationId?: StringFieldUpdateOperationsInput | string
    transferNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumTransferStatusFieldUpdateOperationsInput | $Enums.TransferStatus
    transferDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOrder?: SaleOrderUpdateOneRequiredWithoutReturnOrdersNestedInput
    customer?: CustomerUpdateOneWithoutReturnOrdersNestedInput
    lines?: ReturnOrderLineUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductVariantCreateManyProductInput = {
    id: string
    sku: string
    name?: string | null
    cost?: number
    price: number
    compareAtPrice?: number | null
    trackInventory?: boolean
    barcode?: string | null
    upc?: string | null
    ean?: string | null
    color?: string | null
    size?: string | null
    material?: string | null
    style?: string | null
    weight?: number | null
    weightUnit?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductVariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inventoryItems?: InventoryItemUncheckedUpdateManyWithoutVariantNestedInput
    saleOrderLines?: SaleOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    returnOrderLines?: ReturnOrderLineUncheckedUpdateManyWithoutVariantNestedInput
    stockAdjustmentLines?: StockAdjustmentLineUncheckedUpdateManyWithoutVariantNestedInput
    stockTransferLines?: StockTransferLineUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductVariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: FloatFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    compareAtPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    trackInventory?: BoolFieldUpdateOperationsInput | boolean
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    upc?: NullableStringFieldUpdateOperationsInput | string | null
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    material?: NullableStringFieldUpdateOperationsInput | string | null
    style?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    weightUnit?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateManyVariantInput = {
    id: string
    locationId: string
    quantityOnHand?: number
    quantityReserved?: number
    quantityAvailable?: number
    reorderPoint?: number | null
    reorderQuantity?: number | null
    lastCountedAt?: Date | string | null
    lastReceivedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    pendingSync?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderLineCreateManyVariantInput = {
    id?: string
    orderId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnOrderLineCreateManyVariantInput = {
    id?: string
    returnOrderId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type StockAdjustmentLineCreateManyVariantInput = {
    id?: string
    adjustmentId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockTransferLineCreateManyVariantInput = {
    id?: string
    transferId: string
    quantity: number
    received?: number | null
  }

  export type InventoryItemUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type InventoryItemUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    quantityOnHand?: IntFieldUpdateOperationsInput | number
    quantityReserved?: IntFieldUpdateOperationsInput | number
    quantityAvailable?: IntFieldUpdateOperationsInput | number
    reorderPoint?: NullableIntFieldUpdateOperationsInput | number | null
    reorderQuantity?: NullableIntFieldUpdateOperationsInput | number | null
    lastCountedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReceivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    pendingSync?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: SaleOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type SaleOrderLineUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnOrder?: ReturnOrderUpdateOneRequiredWithoutLinesNestedInput
  }

  export type ReturnOrderLineUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnOrderId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnOrderId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAdjustmentLineUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
    adjustment?: StockAdjustmentUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type StockAdjustmentLineUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockAdjustmentLineUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockTransferLineUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
    transfer?: StockTransferUpdateOneRequiredWithoutLineItemsNestedInput
  }

  export type StockTransferLineUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockTransferLineUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    transferId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateManyParentInput = {
    id: string
    code: string
    name: string
    description?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    brandId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUpdateManyWithoutParentNestedInput
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CategoryUncheckedUpdateManyWithoutParentNestedInput
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneWithoutProductsNestedInput
    taxCategory?: TaxCategoryUpdateOneWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyBrandInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    taxCategoryId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    taxCategory?: TaxCategoryUpdateOneWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    taxCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressCreateManyCustomerInput = {
    id?: string
    type: $Enums.AddressType
    addressLine1: string
    addressLine2?: string | null
    city: string
    state?: string | null
    zipCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderCreateManyCustomerInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    shiftId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReturnOrderCreateManyCustomerInput = {
    id?: string
    returnNumber: string
    originalOrderId: string
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerAddressUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerAddressUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAddressTypeFieldUpdateOperationsInput | $Enums.AddressType
    addressLine1?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    shift?: ShiftUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalOrder?: SaleOrderUpdateOneRequiredWithoutReturnOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutReturnOrdersNestedInput
    lines?: ReturnOrderLineUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateManyGroupInput = {
    id: string
    code: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    type?: $Enums.CustomerType
    loyaltyPoints?: number
    totalSpent?: number
    totalOrders?: number
    creditLimit?: number | null
    currentBalance?: number
    allowMarketing?: boolean
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: CustomerAddressUncheckedUpdateManyWithoutCustomerNestedInput
    saleOrders?: SaleOrderUncheckedUpdateManyWithoutCustomerNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumCustomerTypeFieldUpdateOperationsInput | $Enums.CustomerType
    loyaltyPoints?: IntFieldUpdateOperationsInput | number
    totalSpent?: FloatFieldUpdateOperationsInput | number
    totalOrders?: IntFieldUpdateOperationsInput | number
    creditLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    currentBalance?: FloatFieldUpdateOperationsInput | number
    allowMarketing?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockAdjustmentLineCreateManyAdjustmentInput = {
    id?: string
    variantId: string
    quantityBefore: number
    quantityAfter: number
    quantityChange: number
  }

  export type StockAdjustmentLineUpdateWithoutAdjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
    variant?: ProductVariantUpdateOneRequiredWithoutStockAdjustmentLinesNestedInput
  }

  export type StockAdjustmentLineUncheckedUpdateWithoutAdjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockAdjustmentLineUncheckedUpdateManyWithoutAdjustmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantityBefore?: IntFieldUpdateOperationsInput | number
    quantityAfter?: IntFieldUpdateOperationsInput | number
    quantityChange?: IntFieldUpdateOperationsInput | number
  }

  export type StockTransferLineCreateManyTransferInput = {
    id?: string
    variantId: string
    quantity: number
    received?: number | null
  }

  export type StockTransferLineUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
    variant?: ProductVariantUpdateOneRequiredWithoutStockTransferLinesNestedInput
  }

  export type StockTransferLineUncheckedUpdateWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StockTransferLineUncheckedUpdateManyWithoutTransferInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    received?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SaleOrderLineCreateManyOrderInput = {
    id?: string
    variantId: string
    quantity: number
    unitPrice: number
    discountAmount?: number
    taxAmount?: number
    lineTotal: number
    notes?: string | null
    syncVersion?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyOrderInput = {
    id?: string
    method: $Enums.PaymentMethod
    amount: number
    currency?: string
    reference?: string | null
    cardLast4?: string | null
    cardBrand?: string | null
    authCode?: string | null
    status?: $Enums.PaymentStatus
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    processedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateManyOrderInput = {
    id?: string
    type: $Enums.DiscountType
    name: string
    code?: string | null
    amount: number
    percent?: number | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
  }

  export type ReturnOrderCreateManyOriginalOrderInput = {
    id?: string
    returnNumber: string
    customerId?: string | null
    locationId: string
    reason?: $Enums.ReturnReason | null
    notes?: string | null
    subtotal?: number
    taxAmount?: number
    total?: number
    refundMethod?: $Enums.RefundMethod | null
    refundAmount?: number
    status?: $Enums.ReturnStatus
    processedBy?: string | null
    processedAt?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParkedOrderCreateManyOrderInput = {
    id?: string
    parkNumber: string
    customerId?: string | null
    parkedBy?: string | null
    parkedAt?: Date | string
    expiryDate?: Date | string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderCreateManyOriginalOrderInput = {
    id?: string
    exchangeNumber: string
    newOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type ExchangeOrderCreateManyNewOrderInput = {
    id?: string
    exchangeNumber: string
    originalOrderId: string
    priceDifference?: number
    additionalPayment?: number
    refundAmount?: number
    processedBy?: string | null
    processedAt?: Date | string
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
  }

  export type SaleOrderLineUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutSaleOrderLinesNestedInput
  }

  export type SaleOrderLineUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderLineUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    cardLast4?: NullableStringFieldUpdateOperationsInput | string | null
    cardBrand?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    percent?: NullableFloatFieldUpdateOperationsInput | number | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderUpdateWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutReturnOrdersNestedInput
    location?: LocationUpdateOneRequiredWithoutReturnOrdersNestedInput
    lines?: ReturnOrderLineUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderNestedInput
  }

  export type ReturnOrderUncheckedUpdateManyWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    returnNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    locationId?: StringFieldUpdateOperationsInput | string
    reason?: NullableEnumReturnReasonFieldUpdateOperationsInput | $Enums.ReturnReason | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    refundMethod?: NullableEnumRefundMethodFieldUpdateOperationsInput | $Enums.RefundMethod | null
    refundAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumReturnStatusFieldUpdateOperationsInput | $Enums.ReturnStatus
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParkedOrderUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkedOrderUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ParkedOrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    parkNumber?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    parkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    parkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderUpdateWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    newOrder?: SaleOrderUpdateOneRequiredWithoutExchangesToNestedInput
  }

  export type ExchangeOrderUncheckedUpdateWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    newOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    newOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderUpdateWithoutNewOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    originalOrder?: SaleOrderUpdateOneRequiredWithoutExchangesFromNestedInput
  }

  export type ExchangeOrderUncheckedUpdateWithoutNewOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExchangeOrderUncheckedUpdateManyWithoutNewOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    exchangeNumber?: StringFieldUpdateOperationsInput | string
    originalOrderId?: StringFieldUpdateOperationsInput | string
    priceDifference?: FloatFieldUpdateOperationsInput | number
    additionalPayment?: FloatFieldUpdateOperationsInput | number
    refundAmount?: FloatFieldUpdateOperationsInput | number
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReturnOrderLineCreateManyReturnOrderInput = {
    id?: string
    variantId: string
    originalLineId?: string | null
    quantity: number
    unitPrice: number
    lineTotal: number
    reason?: string | null
    createdAt?: Date | string
  }

  export type ReturnOrderLineUpdateWithoutReturnOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: ProductVariantUpdateOneRequiredWithoutReturnOrderLinesNestedInput
  }

  export type ReturnOrderLineUncheckedUpdateWithoutReturnOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReturnOrderLineUncheckedUpdateManyWithoutReturnOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    originalLineId?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    lineTotal?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleOrderCreateManyShiftInput = {
    id?: string
    locationId: string
    terminalId?: string | null
    orderNumber: string
    type?: $Enums.OrderType
    status?: $Enums.OrderStatus
    source?: $Enums.OrderSource
    customerId?: string | null
    userId?: string | null
    subtotal?: number
    taxAmount?: number
    discountAmount?: number
    total?: number
    completedAt?: Date | string | null
    voidedAt?: Date | string | null
    voidReason?: string | null
    receiptPrinted?: boolean
    receiptEmailed?: boolean
    receiptPrintedAt?: Date | string | null
    receiptEmailedAt?: Date | string | null
    receiptNumber?: string | null
    discountReason?: string | null
    notes?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    syncPriority?: number
    syncAttempts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleOrderUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutSaleOrdersNestedInput
    terminal?: TerminalUpdateOneWithoutSaleOrdersNestedInput
    customer?: CustomerUpdateOneWithoutSaleOrdersNestedInput
    user?: LocalUserUpdateOneWithoutSaleOrdersNestedInput
    lines?: SaleOrderLineUpdateManyWithoutOrderNestedInput
    payments?: PaymentUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: SaleOrderLineUncheckedUpdateManyWithoutOrderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutOrderNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderNestedInput
    returnOrders?: ReturnOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    parkedOrders?: ParkedOrderUncheckedUpdateManyWithoutOrderNestedInput
    exchangesFrom?: ExchangeOrderUncheckedUpdateManyWithoutOriginalOrderNestedInput
    exchangesTo?: ExchangeOrderUncheckedUpdateManyWithoutNewOrderNestedInput
  }

  export type SaleOrderUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    orderNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    source?: EnumOrderSourceFieldUpdateOperationsInput | $Enums.OrderSource
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    receiptPrinted?: BoolFieldUpdateOperationsInput | boolean
    receiptEmailed?: BoolFieldUpdateOperationsInput | boolean
    receiptPrintedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptEmailedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiptNumber?: NullableStringFieldUpdateOperationsInput | string | null
    discountReason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    syncPriority?: IntFieldUpdateOperationsInput | number
    syncAttempts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyTaxCategoryInput = {
    id: string
    code: string
    name: string
    description?: string | null
    type?: $Enums.ProductType
    categoryId?: string | null
    brandId?: string | null
    imageUrl?: string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxRateCreateManyTaxCategoryInput = {
    id?: string
    name: string
    rate: number
    country?: string | null
    state?: string | null
    city?: string | null
    isActive?: boolean
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    syncVersion?: number
    lastSyncedAt?: Date | string | null
    isDirty?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutProductsNestedInput
    brand?: BrandUpdateOneWithoutProductsNestedInput
    variants?: ProductVariantUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: ProductVariantUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumProductTypeFieldUpdateOperationsInput | $Enums.ProductType
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    brandId?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUpdateWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxRateUncheckedUpdateManyWithoutTaxCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    country?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncVersion?: IntFieldUpdateOperationsInput | number
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDirty?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}